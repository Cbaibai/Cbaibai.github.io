<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>摆摆笔记</title>
  
  <subtitle>书写，是对思维的缓存！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://baibainote.pro/"/>
  <updated>2020-10-27T13:16:20.346Z</updated>
  <id>https://baibainote.pro/</id>
  
  <author>
    <name>Cbaibai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://baibainote.pro/2020/10/30/Lamda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://baibainote.pro/2020/10/30/Lamda 表达式/</id>
    <published>2020-10-30T13:14:18.397Z</published>
    <updated>2020-10-27T13:16:20.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>[toc]</p><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>Lambda 表达式是在 Java 8 中引入的，并且成为了 Java 8 最大的特点。它使得功能性编程变得非常便利，极大地简化了开发工作。</p><h2 id="Lambda-表达式的语法与特征"><a href="#Lambda-表达式的语法与特征" class="headerlink" title="Lambda 表达式的语法与特征"></a>Lambda 表达式的语法与特征</h2><p>一个 Lambda 表达式具有下面这样的语法特征。它由三个部分组成：第一部分为一个括号内用逗号分隔的参数列表，参数即函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块。语法如下：<br><pre><code class="hljs gams"><span class="hljs-keyword">parameter</span> -&gt; expression <span class="hljs-comment">body</span></code></pre></p><p>下面列举了 Lambda 表达式的几个最重要的特征：</p><ul><li><strong>可选的类型声明</strong>：你不用去声明参数的类型。编译器可以从参数的值来推断它是什么类型。</li><li><strong>可选的参数周围的括号</strong>：你可以不用在括号内声明单个参数。但是对于很多参数的情况，括号是必需的。</li><li><strong>可选的大括号</strong>：如果表达式体里面只有一个语句，那么你不必用大括号括起来。</li><li><strong>可选的返回关键字</strong>：如果表达式体只有单个表达式用于值的返回，那么编译器会自动完成这一步。若要指示表达式来返回某个值，则需要使用大括号。</li></ul><p>Java 语言的设计者们思考了很多如何让现有的功能和 Lambda 表达式友好兼容。于是就有了函数接口这个概念。<strong>函数接口是一种只有一个方法的接口，函数接口可以隐式地转换成 Lambda 表达式。</strong></p><blockquote><p><strong>函数式接口的重要属性是</strong>：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码。</p></blockquote><h2 id="一个Lambda表达式的例子"><a href="#一个Lambda表达式的例子" class="headerlink" title="一个Lambda表达式的例子"></a>一个Lambda表达式的例子</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;        NewFeaturesTester tester = <span class="hljs-keyword">new</span> NewFeaturesTester();        <span class="hljs-comment">/*--- Lambda 表达式可以实现接口 ---*/</span>        <span class="hljs-comment">// 带有类型声明的表达式</span>        MathOperation addition = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a + b;        <span class="hljs-comment">// 没有类型声明的表达式</span>        MathOperation subtraction = (a, b) -&gt; a - b;        <span class="hljs-comment">// 带有大括号、带有返回语句的表达式</span>        MathOperation multiplication = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123; <span class="hljs-keyword">return</span> a * b; &#125;;        <span class="hljs-comment">// 没有大括号和 return 语句的表达式</span>        MathOperation division = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a / b;        <span class="hljs-comment">// 输出结果</span>        System.out.println(<span class="hljs-string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, addition));        System.out.println(<span class="hljs-string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, subtraction));        System.out.println(<span class="hljs-string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, multiplication));        System.out.println(<span class="hljs-string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, division));        <span class="hljs-comment">// 没有括号的表达式</span>        GreetingService greetService1 = message -&gt;        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);        <span class="hljs-comment">// 有括号的表达式</span>         GreetingService greetService2 = (message) -&gt;        System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);        <span class="hljs-comment">// 调用 sayMessage 方法输出结果</span>        greetService1.sayMessage(<span class="hljs-string">&quot;Shiyanlou&quot;</span>);        greetService2.sayMessage(<span class="hljs-string">&quot;Classmate&quot;</span>);    &#125;    <span class="hljs-comment">// 下面是定义的一些接口和方法(函数式接口)</span>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MathOperation</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;    &#125;    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, MathOperation mathOperation)</span></span>&#123;        <span class="hljs-keyword">return</span> mathOperation.operation(a, b);    &#125;&#125;</code></pre><p><a href="../images/993e3dfb4be036a039bd87b9b8ed9399_4204371964.jpg" class="gallery-item"><img src="../images/993e3dfb4be036a039bd87b9b8ed9399_4204371964.jpg" alt=""></a></p><blockquote><p>总结</p></blockquote><ul><li>Lambda 表达式优先用于定义功能接口在行内的实现，即单个方法只有一个接口。</li><li>Lambda 表达式让匿名类不再需要，这为 Java 增添了简洁但实用的函数式编程能力</li></ul><h2 id="Lambda-的作用域"><a href="#Lambda-的作用域" class="headerlink" title="Lambda 的作用域"></a>Lambda 的作用域</h2><p>将以上代码更改为：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String salutation = <span class="hljs-string">&quot;Hello &quot;</span>;     <span class="hljs-comment">// 正确，不可再次赋值</span><br>    <span class="hljs-comment">// static String salutation = &quot;Hello &quot;;        // 正确，可再次赋值</span><br>    <span class="hljs-comment">// String salutation = &quot;Hello &quot;;               // 报错</span><br>    <span class="hljs-comment">// final String salutation = &quot;Hello &quot;;         // 报错</span></p><pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt;&lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-comment&quot;&gt;// final String salutation = &amp;quot;Hello &amp;quot;;     // 正确，不可再次赋值&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// String salutation = &amp;quot;Hello &amp;quot;;           // 正确，隐性为 final，不可再次赋值&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// salution = &amp;quot;welcome to &amp;quot;&lt;/span&gt;    GreetingService greetService1 = message -&amp;gt;    System.out.println(salutation + message);    greetService1.sayMessage(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Shiyanlou&amp;quot;&lt;/span&gt;);&amp;#125;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GreetingService&lt;/span&gt;&lt;/span&gt;&amp;#123;   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sayMessage&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String message)&lt;/span&gt;&lt;/span&gt;;&amp;#125;</code></pre><p>&#125;</code></pre>:hexoPostRenderEscape–&gt;<br><a href="../images/2a857631f38cae293da106483771136a_1768532042.jpg" class="gallery-item"><img src="../images/2a857631f38cae293da106483771136a_1768532042.jpg" alt=""></a></p><p>根据以上代码可以得出结论：</p><ul><li>可访问 static 修饰的成员变量，如果是 final static 修饰，不可再次赋值，只有 static 修饰可再次赋值。</li><li>可访问表达式外层的 final 局部变量（不用声明为 final，隐性具有 final 语义），不可再次赋值。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><blockquote><p>方法也是一种对象，可以通过名字来引用。不过方法引用的唯一用途是支持 Lambda 的简写，使用方法名称来表示 Lambda。不能通过方法引用来获得诸如方法签名的相关信息。</p></blockquote><p>方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。</p><p>方法引用可以通过方法的名字来引用其本身。方法引用是通过双冒号 :: 来描述的。</p><p>它可以用来引用下列类型的方法：</p><ul><li><strong>构造器引用</strong>。语法是 <code>Class::new</code>，或者更一般的 Class&lt; T &gt;::new，要求构造器方法是没有参数。</li><li><strong>静态方法引用</strong>。语法是 <code>Class::static_method</code>，要求接受一个 Class 类型的参数。</li><li><strong>特定类的任意对象方法引用</strong>。它的语法是 <code>Class::method</code>，要求方法是没有参数的。</li><li><strong>特定对象的方法引用</strong>，它的语法是<code>instance::method</code>。要求方法接受一个参数，与 3 不同的地方在于，3 是在列表元素上分别调用方法，而 4 是在某个对象上调用方法，将列表元素作为参数传入。</li></ul><p>更多对于方法引用的介绍，可以参考这一篇博文—— java8 - 方法引用(method referrance)</p><p>下面是一个简单的方法引用的例子:<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;</p><p><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;</p><pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt;&lt;/span&gt;&amp;#123;    List&amp;lt;String&amp;gt; names = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();    names.add(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Peter&amp;quot;&lt;/span&gt;);    names.add(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Linda&amp;quot;&lt;/span&gt;);    names.add(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Smith&amp;quot;&lt;/span&gt;);    names.add(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Zack&amp;quot;&lt;/span&gt;);    names.add(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;);    &lt;span class=&quot;hljs-comment&quot;&gt;// 通过 System.out::println 引用了输出的方法&lt;/span&gt;    names.forEach(System.out::println);&amp;#125;</code></pre><p>&#125;</code></pre>:hexoPostRenderEscape–&gt;<br><a href="../images/ccc3c6284413355adaf8030f8737d94e_3808493287.jpg" class="gallery-item"><img src="../images/ccc3c6284413355adaf8030f8737d94e_3808493287.jpg" alt=""></a></p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口通过一个单一的功能来表现。例如，带有单个 compareTo 方法的比较接口，被用于比较的场合。Java 8 开始定义了大量的函数式接口来广泛地用于 Lambda 表达式。</p><blockquote><p>Java 8 引入的一个核心概念是函数式接口（Functional Interfaces）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。同时，引入了一个新的注解：<code>@FunctionalInterface</code>。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 <code>@FunctionalInterface</code> 进行声明。在接口中添加了 <code>@FunctionalInterface</code> 的接口，只允许有一个抽象方法，否则编译器也会报错。</p></blockquote><h2 id="函数式相关的接口及描述"><a href="#函数式相关的接口及描述" class="headerlink" title="函数式相关的接口及描述"></a>函数式相关的接口及描述</h2><table><thead><tr><th>接 口</th><th>描 述</th></tr></thead><tbody><tr><td>BitConsumer&lt;T,U&gt;</td><td>该接口代表了接收两个输入参数 T、U，并且没有返回的操作</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>该接口代表提供接收两个参数 T、U，并且产生一个结果 R 的方法</td></tr><tr><td>BinaryOperator</td><td>代表了基于两个相同类型的操作数，产生仍然是相同类型结果的操作</td></tr><tr><td>BiPredicate&lt;T,U&gt;</td><td>代表了对两个参数的断言操作（基于 Boolean 值的方法）</td></tr><tr><td>BooleanSupplier</td><td>代表了一个给出 Boolean 值结果的方法</td></tr><tr><td>Consumer</td><td>代表了接受单一输入参数并且没有返回值的操作</td></tr><tr><td>DoubleBinaryOperator</td><td>代表了基于两个 Double 类型操作数的操作，并且返回一个 Double 类型的返回值</td></tr><tr><td>DoubleConsumer</td><td>代表了一个接受单个 Double 类型的参数并且没有返回的操作</td></tr><tr><td>DoubleFunction</td><td>代表了一个接受 Double 类型参数并且返回结果的方法</td></tr><tr><td>DoublePredicate</td><td>代表了对一个 Double 类型的参数的断言操作</td></tr><tr><td>DoubleSupplier</td><td>代表了一个给出 Double 类型值的方法</td></tr><tr><td>DoubleToIntFunction</td><td>代表了接受单个 Double 类型参数但返回 Int 类型结果的方法</td></tr><tr><td>DoubleToLongFunction</td><td>代表了接受单个 Double 类型参数但返回 Long 类型结果的方法</td></tr><tr><td>DoubleUnaryOperator</td><td>代表了基于单个 Double 类型操作数且产生 Double 类型结果的操作</td></tr><tr><td>Function&lt;T,R&gt;</td><td>代表了接受一个参数并且产生一个结果的方法</td></tr><tr><td>IntBinaryOperator</td><td>代表了对两个 Int 类型操作数的操作，并且产生一个 Int 类型的结果</td></tr><tr><td>IntConsumer</td><td>代表了接受单个 Int 类型参数的操作，没有返回结果</td></tr><tr><td>IntFunction</td><td>代表了接受 Int 类型参数并且给出返回值的方法</td></tr><tr><td>IntPredicate</td><td>代表了对单个 Int 类型参数的断言操作</td></tr></tbody></table><p>更多的接口可以参考 Java 官方 API 手册：[java.lang.Annotation Type FunctionalInterface][4]。在实际使用过程中，加有 @FunctionalInterface 注解的方法均是此类接口，位于 [java.util.Funtion][5] 包中。</p><h2 id="一个函数式编程的例子"><a href="#一个函数式编程的例子" class="headerlink" title="一个函数式编程的例子"></a>一个函数式编程的例子</h2><p>下面我们通过一个例子学习如何使用这些函数式编程的接口。</p><p>新建一个类 <code>NewFeaturesTester.java</code>，以下是 <code>NewFeaturesTester.java</code> 类中应当输入的代码：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.function.Predicate;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);      System.out.println(<span class="hljs-string">&quot;All of the numbers:&quot;</span>);      eval(list, n-&gt;<span class="hljs-keyword">true</span>);      System.out.println(<span class="hljs-string">&quot;Even numbers:&quot;</span>);      eval(list, n-&gt; n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> );      System.out.println(<span class="hljs-string">&quot;Numbers that greater than  5:&quot;</span>);      eval(list, n -&gt; n &gt; <span class="hljs-number">5</span> );   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span></span>&#123;      <span class="hljs-keyword">for</span>(Integer n: list)&#123;         <span class="hljs-keyword">if</span>(predicate.test(n))&#123;            System.out.println(n);         &#125;      &#125;   &#125;&#125;</code></pre><p><a href="../images/93129ac18cc800cae5bcbfec8dc39125_3436648429.jpg" class="gallery-item"><img src="../images/93129ac18cc800cae5bcbfec8dc39125_3436648429.jpg" alt=""></a></p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>Java 8 在接口方面引入了一个关于默认方法实现的新概念。它也是作为一种向后兼容能力而出现，旧的接口也能用到 Lambda 表达式中。例如，List 或 Collection 接口是没有 forEach 方法的声明的。但是，通过这些默认方法能够就能轻易地打破集合框架实现的限制。Java 8 引入默认方式使得 List 和 Collection 接口能够拥有 forEach 方法的默认实现。实现了这些接口的类也不必再实现相同的功能了。</p><p>语法如下所示：<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">boy</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;      System.out.println(<span class="hljs-string">&quot;I am a boy.&quot;</span>);   &#125;&#125;</code></pre></p><h3 id="多个默认值"><a href="#多个默认值" class="headerlink" title="多个默认值"></a>多个默认值</h3><p>接口中有了默认方法之后，在同一个类里面实现两个带有相同默认方法的接口就可行了。</p><p>下面的代码演示了如何解决这种含糊不清的情况。首先是同一个类里面的两个接口。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">younger</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;I am a younger.&quot;</span>);<br>   &#125;<br>&#125;</p><p><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">learner</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;I am a learner.&quot;</span>);<br>   &#125;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;<br>第一个解决办法就是创建一个自有的方法，来重写默认的实现。就像这样：<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">younger</span>, <span class="hljs-title">learner</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;      System.out.println(<span class="hljs-string">&quot;I am a younger and a learner, so I am  a student.&quot;</span>);   &#125;&#125;</code></pre><br>另外一个解决办法是使用超类 super 来调用特定接口的默认方法。<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">younger</span>, <span class="hljs-title">learner</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;      learner.<span class="hljs-keyword">super</span>.print();   &#125;&#125;</code></pre></p><h3 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h3><p>你也可以为这个接口增加静态的辅助方法（helper），就像下面这样：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Younger</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;I am a younger.&quot;</span>);<br>   &#125;</p><p>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Young is the capital.&quot;</span>);<br>   &#125;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;</p><h3 id="一个默认方法的例子"><a href="#一个默认方法的例子" class="headerlink" title="一个默认方法的例子"></a>一个默认方法的例子</h3><p>下面我们通过一个例子来掌握如何使用默认方法，请将代码修改为下面的内容，对应知识点已在注释中写明。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>        Younger younger = <span class="hljs-keyword">new</span> Student();<br>        younger.print();<br>    &#125;<br>&#125;</p><p><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Younger</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a younger.&quot;</span>);<br>    &#125;</p><pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Young is the capital.&amp;quot;&lt;/span&gt;);&amp;#125;</code></pre><p>&#125;</p><p><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Learner</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a learner.&quot;</span>);<br>    &#125;<br>&#125;</p><p><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Younger</span>, <span class="hljs-title">Learner</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        Younger.<span class="hljs-keyword">super</span>.print();<br>        Learner.<span class="hljs-keyword">super</span>.print();<br>        Younger.sayHi();<br>        System.out.println(<span class="hljs-string">&quot;I am a student!&quot;</span>);<br>    &#125;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;<br>运行结果如下所示：</p><p><a href="../images/b37467d1fbbbf2e08149a2b36c08859a_1550726729.png" class="gallery-item"><img src="../images/b37467d1fbbbf2e08149a2b36c08859a_1550726729.png" alt=""></a></p><h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p><code>Optional</code> 是一个容器对象，用于容纳非空对象。Optional 对象通过缺失值表示 null。这个类有许多实用的方法来促使代码能够处理一些像可用或者不可用的值，而不是检查那些空值（null）。Java 8 中引入的这个特性有点像 Google Guava 里的 Optional（Guava 是一个 Google 的基于 Java 6 的类库集合的扩展项目）。</p><p>在 Java 官方文档的解释中，它是一个可以为 null 的容器对象。如果值存在则 <code>isPresent()</code> 方法会返回 true，调用 <code>get()</code>方法会返回该对象。</p><h3 id="类的声明及方法"><a href="#类的声明及方法" class="headerlink" title="类的声明及方法"></a>类的声明及方法</h3><p>下面是 <code>java.util.Optional&lt;T&gt;</code> 类的声明：<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Optional</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span></span></code></pre><br>这个类继承了 <code>java.lang.Object</code> 类大多数方法。主要有：<br>|接口    |描述|<br>|——-|—-|<br>|static Optional empty()    |该方法返回一个空的 Optional 实例|<br>|boolean equals(Object obj)    |该方法可以指示某个对象是否与当前 Optional 对象相等|<br>|Optional filter(Predicate&lt;? super predicate)    |如果一个值存在并且这个值满足某个给定的断言，那么该方法将返回一个描述该值的 Optional 对象；否则，将返回一个空的 Optional 对象<br>|Optional flatMap(Function&lt;? super T,Optional&gt; mapper)    |如果一个值存在，该方法会把一个 map 方法应用于它，并且返回结果；否则，将返回空的 Optional 对象|<br>|T get()    |如果一个值存在于当前 Optional 中，则返回这个值；否则将抛出一个 NoSuchElementException 异常|<br>|int hashCode()    |返回当前值的 hash 编码值。若这个值不存在，则返回 0|<br>|void ifPresent(Consumer&lt;? super T&gt; consumer)    |如果一个值存在，该方法会通过该值调用指定的 consumer。如果不存在，则不调用|<br>|boolean isPresent()    |返回一个值是否存在|<br>|Optional map(Function&lt;? super T,? extends U&gt; mapper    |如果一个值存在，则将某个 map 方法应用于它。如果这个值是非空的，则返回一个描述结果的 Optional 对象|<br>|static Optional of(T value)    |返回某个存在的非空值的 Optional 对象|</p><h3 id="一个-Optional-类的例子"><a href="#一个-Optional-类的例子" class="headerlink" title="一个 Optional 类的例子"></a>一个 Optional 类的例子</h3><p>下面我们通过一个实例来学习如何将 Optional 类应用到我们的编程中。</p><p>请将 WEB IDE 中的代码修改为下面的内容：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Optional;</p><p><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;</p><pre><code>NewFeaturesTester tester = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; NewFeaturesTester();Integer value1 = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;Integer value2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;// ofNullable 允许传参时给出 null&lt;/span&gt;Optional&amp;lt;Integer&amp;gt; a = Optional.ofNullable(value1);&lt;span class=&quot;hljs-comment&quot;&gt;// 如果传递的参数为null，那么 of 将抛出空指针异常（NullPointerException）&lt;/span&gt;Optional&amp;lt;Integer&amp;gt; b = Optional.of(value2);System.out.println(tester.sum(a,b));</code></pre><p>   &#125;</p><p>   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">sum</span><span class="hljs-params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span></span>&#123;</p><pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// isPresent 用于检查值是否存在&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;First parameter is present: &amp;quot;&lt;/span&gt; + a.isPresent());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Second parameter is present: &amp;quot;&lt;/span&gt; + b.isPresent());&lt;span class=&quot;hljs-comment&quot;&gt;// 如果当前返回的是传入的默认值，orElse 将返回它&lt;/span&gt;Integer value1 = a.orElse(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));&lt;span class=&quot;hljs-comment&quot;&gt;// get 用于获得值，条件是这个值必须存在&lt;/span&gt;Integer value2 = b.get();&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value1 + value2;</code></pre><p>   &#125;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;<br>编辑完成后，编译运行一下：</p><p><a href="../images/1b8d608966090998c579420740ad650e_384844522.png" class="gallery-item"><img src="../images/1b8d608966090998c579420740ad650e_384844522.png" alt=""></a></p><h1 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h1><h2 id="Stream（流）简介"><a href="#Stream（流）简介" class="headerlink" title="Stream（流）简介"></a>Stream（流）简介</h2><p>Stream 是 Java 8 中的一个新的抽象层。通过使用 Stream，你能以类似于 SQL 语句的声明式方式处理数据。</p><p>例如一个典型的 SQL 语句能够自动地返回某些信息，而不用在开发者这一端做任何的计算工作。同样，通过使用 Java 的集合框架，开发者能够利用循环做重复的检查。另外一个关注点是效率，就像多核处理器能够提升效率一样，开发者也可以通过并行化编程来改进工作流程，但是这样很容易出错。</p><p>因此，Stream 的引入是为了解决上述痛点。开发者可以通行声明式数据处理，以及简单地利用多核处理体系而不用写特定的代码。</p><p>说了这么久，Stream 究竟是什么呢？Stream 代表了来自某个源的对象的序列，这些序列支持聚集操作。下面是 Stream 的一些特性：</p><ul><li><strong>元素序列</strong>：Stream 以序列的形式提供了特定类型的元素的集合。根据需求，它可以获得和计算元素，但不会储存任何元素。<br>源：Stream 可以将集合、数组和 I/O 资源作为输入源。</li><li><strong>聚集操作</strong>：Stream 支持诸如 filter、map、limit、reduce 等的聚集操作。</li><li><strong>流水技术</strong>：许多 Stream 操作返回了流本身，故它们的返回值可以以流水的行式存在。这些操作称之为中间操作，并且它们的功能就是负责输入、处理和向目标输出。collect() 方法是一个终结操作，通常存在于流水线操作的末端，来标记流的结束。</li><li><strong>自动迭代</strong>：Stream 的操作可以基于已提供的源元素进行内部的迭代，而集合则需要显式的迭代。</li></ul><h2 id="产生流"><a href="#产生流" class="headerlink" title="产生流"></a>产生流</h2><p>集合的接口有两个方法来产生流：</p><ul><li><code>stream()</code>：该方法返回一个将集合视为源的连续流。</li><li><code>parallelStream()</code>：该方法返回一个将集合视为源的并行流。</li></ul><p>相关的方法介绍</p><ul><li><code>forEach</code>：该方法用于对 Stream 中的每个元素进行迭代操作。下面的代码段演示了如何使用 forEach 方法输出 10 个随机数。</li></ul><pre><code class="hljs java">Random random = <span class="hljs-keyword">new</span> Random();random.ints().limit(<span class="hljs-number">10</span>).forEach(System.out::println);</code></pre><ul><li><p><code>map</code>：该方法用于将每个元素映射到对应的结果上。下面的代码段演示了怎样用 map 方法输出唯一的某个数的平方。</p><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>);<span class="hljs-comment">// get list of unique squares</span>List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</code></pre></li><li><p><code>filter</code>：该方法用于过滤满足条件的元素。下面的代码段演示了怎样输出使用了过滤方法的空字符串数量。</p><pre><code class="hljs java">List&lt;String&gt;strings = Arrays.asList(<span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;ghij&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lmn&quot;</span>);<span class="hljs-comment">//get count of empty string</span><span class="hljs-keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</code></pre></li><li><p><code>limit</code>：该方法用于减少 Stream 的大小。下面的代码段演示了怎样有限制地输出 10 个随机数。</p><pre><code class="hljs java">Random random = <span class="hljs-keyword">new</span> Random();random.ints().limit(<span class="hljs-number">10</span>).forEach(System.out::println);</code></pre></li><li><p><code>sorted</code>：该方法用于对 Stream 排序。下面的代码段演示了怎样以有序的形式输出 10 个随机数。</p><pre><code class="hljs java">Random random = <span class="hljs-keyword">new</span> Random();random.ints().limit(<span class="hljs-number">10</span>).sorted().forEach(System.out::println);</code></pre></li></ul><h3 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h3><p><code>ParallelStream</code> 是 Stream 用于并行处理的一种替代方案。下面的代码段演示了如何使用它来输出空字符串的数量。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java">List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;ghij&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lmn&quot;</span>);</p><p><span class="hljs-comment">// 获得空字符串的计数</span><br><span class="hljs-keyword">long</span> count = strings.parallelStream().filter(String::isEmpty).count();</code></pre>:hexoPostRenderEscape–&gt;<br>当然，在连续的 Stream 与并行的 Stream 之间切换是很容易的。</p><h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><p>Collector 用于合并 Stream 的元素处理结果。它可以用于返回一个字符串列表。</p><p>Collector 是专门用来作为 Stream 的 collect 方法的参数的，而 Collectors 是作为生产具体 Collector 的工具类。</p><p>下面的代码段演示了如何使用它。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java">List&lt;String&gt;strings = Arrays.asList(<span class="hljs-string">&quot;efg&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>, <span class="hljs-string">&quot;ghij&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;lmn&quot;</span>);<br>List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</p><p>System.out.println(<span class="hljs-string">&quot;Filtered List: &quot;</span> + filtered);<br>String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="hljs-string">&quot;, &quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;Merged String: &quot;</span> + mergedString);</code></pre>:hexoPostRenderEscape–&gt;</p><h3 id="统计工具"><a href="#统计工具" class="headerlink" title="统计工具"></a>统计工具</h3><p>Java 8 引入了用于统计的 Collector 来计算 Stream 处理完成后的所有统计数据。</p><p>下面的代码段演示了如何使用它。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>);</p><p>IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</p><p>System.out.println(<span class="hljs-string">&quot;Highest number in List : &quot;</span> + stats.getMax());<br>System.out.println(<span class="hljs-string">&quot;Lowest number in List : &quot;</span> + stats.getMin());<br>System.out.println(<span class="hljs-string">&quot;Sum of all numbers : &quot;</span> + stats.getSum());<br>System.out.println(<span class="hljs-string">&quot;Average of all numbers : &quot;</span> + stats.getAverage());</code></pre>:hexoPostRenderEscape–&gt;</p><h2 id="一个-Stream-的例子"><a href="#一个-Stream-的例子" class="headerlink" title="一个 Stream 的例子"></a>一个 Stream 的例子</h2><p>下面我们通过一个例子来综合应用上面提到的各个技巧。</p><p>新建一个类 <code>NewFeaturesTester.java</code>，以下是 <code>NewFeaturesTester.java</code> 类中应当输入的代码：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.IntSummaryStatistics;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><span class="hljs-keyword">import</span> java.util.Map;</p><p><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewFeaturesTester</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Using Java 7: &quot;</span>);</p><pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// 统计空字符串的数量&lt;/span&gt;List&amp;lt;String&amp;gt; strings = Arrays.asList(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;efg&amp;quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;bc&amp;quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;ghij&amp;quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;lmn&amp;quot;&lt;/span&gt;);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;List: &amp;quot;&lt;/span&gt; +strings);&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; count = getCountEmptyStringUsingJava7(strings);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Empty Strings: &amp;quot;&lt;/span&gt; + count);count = getCountLength3UsingJava7(strings);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Strings of length 3: &amp;quot;&lt;/span&gt; + count);&lt;span class=&quot;hljs-comment&quot;&gt;// 消除空字符串&lt;/span&gt;List&amp;lt;String&amp;gt; filtered = deleteEmptyStringsUsingJava7(strings);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Filtered List: &amp;quot;&lt;/span&gt; + filtered);&lt;span class=&quot;hljs-comment&quot;&gt;// 消除空字符串，同时使用逗号来连接&lt;/span&gt;String mergedString = getMergedStringUsingJava7(strings,&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;, &amp;quot;&lt;/span&gt;);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Merged String: &amp;quot;&lt;/span&gt; + mergedString);List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;// 获得不同数字的平方的列表&lt;/span&gt;List&amp;lt;Integer&amp;gt; squaresList = getSquares(numbers);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Squares List: &amp;quot;&lt;/span&gt; + squaresList);List&amp;lt;Integer&amp;gt; integers = Arrays.asList(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;List: &amp;quot;&lt;/span&gt; +integers);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Highest number in List : &amp;quot;&lt;/span&gt; + getMax(integers));System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Lowest number in List : &amp;quot;&lt;/span&gt; + getMin(integers));System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Sum of all numbers : &amp;quot;&lt;/span&gt; + getSum(integers));System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Average of all numbers : &amp;quot;&lt;/span&gt; + getAverage(integers));&lt;span class=&quot;hljs-comment&quot;&gt;// 输出 10 个随机数&lt;/span&gt; System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Random Numbers: &amp;quot;&lt;/span&gt;);Random random = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Random();&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i++)&amp;#123;   System.out.println(random.nextInt());&amp;#125;&lt;span class=&quot;hljs-comment&quot;&gt;// 使用 Java 8 的新特性&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Using Java 8: &amp;quot;&lt;/span&gt;);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;List: &amp;quot;&lt;/span&gt; +strings);count = strings.stream().filter(string-&amp;gt;string.isEmpty()).count();System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Empty Strings: &amp;quot;&lt;/span&gt; + count);count = strings.stream().filter(string -&amp;gt; string.length() == &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;).count();System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Strings of length 3: &amp;quot;&lt;/span&gt; + count);filtered = strings.stream().filter(string -&amp;gt;!string.isEmpty()).collect(Collectors.toList());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Filtered List: &amp;quot;&lt;/span&gt; + filtered);mergedString = strings.stream().filter(string -&amp;gt;!string.isEmpty()).collect(Collectors.joining(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;, &amp;quot;&lt;/span&gt;));System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Merged String: &amp;quot;&lt;/span&gt; + mergedString);squaresList = numbers.stream().map( i -&amp;gt;i*i).distinct().collect(Collectors.toList());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Squares List: &amp;quot;&lt;/span&gt; + squaresList);System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;List: &amp;quot;&lt;/span&gt; +integers);IntSummaryStatistics stats = integers.stream().mapToInt((x) -&amp;gt;x).summaryStatistics();&lt;span class=&quot;hljs-comment&quot;&gt;// 输出结果&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Highest number in List : &amp;quot;&lt;/span&gt; + stats.getMax());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Lowest number in List : &amp;quot;&lt;/span&gt; + stats.getMin());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Sum of all numbers : &amp;quot;&lt;/span&gt; + stats.getSum());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Average of all numbers : &amp;quot;&lt;/span&gt; + stats.getAverage());System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Random Numbers: &amp;quot;&lt;/span&gt;);random.ints().limit(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;).sorted().forEach(System.out::println);&lt;span class=&quot;hljs-comment&quot;&gt;// 并行处理&lt;/span&gt;count = strings.parallelStream().filter(string -&amp;gt; string.isEmpty()).count();System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Empty Strings: &amp;quot;&lt;/span&gt; + count);</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 使用 Java 7 版本就提供的 API 来计算空串数量</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCountEmptyStringUsingJava7</span><span class="hljs-params">(List&lt;String&gt; strings)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(String string: strings)&amp;#123;   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(string.isEmpty())&amp;#123;      count++;   &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; count;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 使用 Java 7 版本就提供的 API 来计算长度为 3 字符的字符串数量</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCountLength3UsingJava7</span><span class="hljs-params">(List&lt;String&gt; strings)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(String string: strings)&amp;#123;   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(string.length() == &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)&amp;#123;      count++;   &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; count;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 使用 Java 7 版本就提供的 API 来删除空串</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">deleteEmptyStringsUsingJava7</span><span class="hljs-params">(List&lt;String&gt; strings)</span></span>&#123;<br>      List&lt;String&gt; filteredList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(String string: strings)&amp;#123;   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!string.isEmpty())&amp;#123;       filteredList.add(string);   &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; filteredList;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 使用 Java 7 版本就提供的 API 来获取合并后的字符串</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getMergedStringUsingJava7</span><span class="hljs-params">(List&lt;String&gt; strings, String separator)</span></span>&#123;<br>      StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(String string: strings)&amp;#123;   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!string.isEmpty())&amp;#123;      stringBuilder.append(string);      stringBuilder.append(separator);   &amp;#125;&amp;#125;String mergedString = stringBuilder.toString();&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mergedString.substring(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, mergedString.length()-&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 自定义的用于计算数字的平方的方法</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">getSquares</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span></span>&#123;<br>      List&lt;Integer&gt; squaresList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(Integer number: numbers)&amp;#123;   Integer square = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Integer(number.intValue() * number.intValue());   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!squaresList.contains(square))&amp;#123;      squaresList.add(square);   &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; squaresList;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 自定义的用于获得 List 中最大值的方法</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> max = numbers.get(<span class="hljs-number">0</span>);</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i &amp;lt; numbers.size();i++)&amp;#123;   Integer number = numbers.get(i);   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(number.intValue() &amp;gt; max)&amp;#123;      max = number.intValue();   &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; max;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 自定义的用于获得 List 中最小值的方法</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> min = numbers.get(<span class="hljs-number">0</span>);</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i &amp;lt; numbers.size();i++)&amp;#123;   Integer number = numbers.get(i);   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(number.intValue() &amp;lt; min)&amp;#123;      min = number.intValue();   &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; min;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 自定义的用于获得 List 中各个数字的和的方法</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span></span>&#123;<br>      <span class="hljs-keyword">int</span> sum = (<span class="hljs-keyword">int</span>)(numbers.get(<span class="hljs-number">0</span>));</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i &amp;lt; numbers.size();i++)&amp;#123;   sum += (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)numbers.get(i);&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; sum;</code></pre><p>   &#125;</p><p>   <span class="hljs-comment">// 自定义的用于获得 List 中各个数字的平均值的方法</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> getSum(numbers) / numbers.size();<br>   &#125;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;<br>编辑完成后，编译运行,可以在控制台看到如下图的输出，则说明相关的 API 使用是正确的：</p><p><a href="../images/a05a341aff8781735c372a5b181c9bf5_1555136329.png" class="gallery-item"><img src="../images/a05a341aff8781735c372a5b181c9bf5_1555136329.png" alt=""></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenCV的GUI特性</title>
    <link href="https://baibainote.pro/2020/03/15/OpenCV%E7%9A%84GUI%E7%89%B9%E6%80%A7/"/>
    <id>https://baibainote.pro/2020/03/15/OpenCV的GUI特性/</id>
    <published>2020-03-15T07:35:06.058Z</published>
    <updated>2020-03-15T07:35:06.062Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="读入和显示图像"><a href="#读入和显示图像" class="headerlink" title="读入和显示图像"></a>读入和显示图像</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>,<span class="hljs-number">0</span>)  <span class="hljs-comment"># OpenCV3中使用imread()读入图像</span>cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)         <span class="hljs-comment"># 使用imshow()显示图片</span>cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p>&emsp;&emsp;<code>cv2.waitKey()</code>是一个键盘绑定函数，它表示在特定的几毫秒之内，如果按下任意键，这个函数会返回按键的ASCII码值，程序将会继续运行。如果没有键盘输入，返回值为-1，如果我们设置这个函数的参数为0，那它将会无限期的等待键盘输入。它也可以被用来检测特定键是否被按下，例如按键a是否被按下。<br><br>&emsp;&emsp;<code>cv2.destroyAllWindows()</code>可以轻易删除任何我们建立的窗口。如果<br>你想删除特定的窗口可以使用cv2.destroyWindow()，在括号内输入你想删除的窗口名即可。</p><p><a href="WEBRESOURCE9abadf62e509d0b9e91aa3c6f7d17373" title="image.png" class="gallery-item"><img src="WEBRESOURCE9abadf62e509d0b9e91aa3c6f7d17373" alt="image.png"></a></p><p>&emsp;&emsp;另外，还有一种方法也可以显示图像，就是先创建一个窗口， 之后<br>再加载图像。这种情况下，你可以决定窗口是否可以调整大小。要使用到的函数是<code>cv2.namedWindow()</code>。<br><br>&emsp;&emsp;<code>cv2.namedWindow()</code>的窗口可调节参数默认是cv2.WINDOW_AUTOSIZE。但是如果你把标签改成cv2.WINDOW_NORMAL，就可以调整窗口大小了。当图像维度太大，或者要添加轨迹条控制参数时，调整窗口大小将会很有用。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>, <span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">&#x27;image&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE7240417996b30eb8577efab7666d1acc" title="image.png" class="gallery-item"><img src="WEBRESOURCE7240417996b30eb8577efab7666d1acc" alt="image.png"></a></p><h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><p>将图像写入某个文件中，要使用<code>imwrite()</code>函数<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br>cv2.namedWindow(<span class="hljs-string">&#x27;image&#x27;</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.imwrite(<span class="hljs-string">&#x27;new.jpg&#x27;</span>,img)  <span class="hljs-comment"># 写入图像</span><br>cv2.destroyAllWindows()</code></pre>:hexoPostRenderEscape–&gt;</p><h2 id="使用waitKey-获取键盘输入"><a href="#使用waitKey-获取键盘输入" class="headerlink" title="使用waitKey()获取键盘输入"></a>使用waitKey()获取键盘输入</h2><p>前面提到过，可以使用waitKey()得到键盘输入，从而进行一些操作。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br>cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)<br>k = cv2.waitKey(<span class="hljs-number">0</span>)     <span class="hljs-comment"># 从屏幕读入键盘输入，返回该键对应的ASCII码</span><br><span class="hljs-keyword">if</span> k == <span class="hljs-number">27</span>:            <span class="hljs-comment"># &#x27;ESC&#x27;键的ASCII码为27</span><br>    cv2.destroyAllWindows()<br><span class="hljs-keyword">elif</span> k == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;s&#x27;</span>):    <span class="hljs-comment"># 如果输入的是&#x27;s&#x27;键</span><br>    cv2.imwrite(<span class="hljs-string">&#x27;messigray.png&#x27;</span>,img)<br>    cv2.destroyAllWindows()</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCEd91ddfe7b3f329d9d90935c333861911" title="image.png" class="gallery-item"><img src="WEBRESOURCEd91ddfe7b3f329d9d90935c333861911" alt="image.png"></a></p><h2 id="使用matplotlib"><a href="#使用matplotlib" class="headerlink" title="使用matplotlib"></a>使用matplotlib</h2><p>opencv-python还可以同matplotlib一起协同使用：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br>plt.imshow(img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>, interpolation = <span class="hljs-string">&#x27;bicubic&#x27;</span>) <span class="hljs-comment"># 设置颜色映射为灰度图，插值方式为双三次插值</span><br>plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 不给x和Y轴指定刻度值(不显示刻度)</span><br>plt.show()</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCEdd40c10b3226f5a17742b45d46ec59e3" title="image.png" class="gallery-item"><img src="WEBRESOURCEdd40c10b3226f5a17742b45d46ec59e3" alt="image.png"></a></p><div style="border: 1px solid #ddd;padding: 5px;"><br><div style="background-color:#906060;padding:4px;border-radius:5px;color:white;text-align:center">注意</div><br>&emsp;&emsp;彩色图像使用OpenCV 加载时是BGR 模式。但是Matplotib 是RGB模式。所以彩色图像如果已经被OpenCV 读取，那它将不会被Matplotib 正确显示。<br></div><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="用摄像头捕获视频"><a href="#用摄像头捕获视频" class="headerlink" title="用摄像头捕获视频"></a>用摄像头捕获视频</h2><p>&emsp;&emsp;为了获取视频，需要创建一个VideoCapture 对象。它的参数可以是设备的索引号，或者是一个视频文件。<br><br>&emsp;&emsp;设备索引号就是指定要使用的摄像头。一般的笔记本电脑都有内置摄像头，所以参数就是0。你可以通过设置成1 或者其他的来选择别的摄像头。之后，你就可以一帧一帧的捕获视频了。但是最<br>后，别忘了停止捕获视频。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2</p><p>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)     <span class="hljs-comment"># 使用电脑默认的摄像头生成VideoCapture对象</span></p><p><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 一帧一帧的捕获图像</span><br>    ret, frame = cap.read()    <span class="hljs-comment"># 调用cv2.VideoCapture对象的read()方法来逐帧读取图像</span></p><pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;# 对每一帧图像都施加[GRB =&amp;gt; GRAY]也就是彩色图转换为灰度图&lt;/span&gt;gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)&lt;span class=&quot;hljs-comment&quot;&gt;# 显示每一帧图像&lt;/span&gt;cv2.imshow(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;frame&amp;#x27;&lt;/span&gt;,gray)&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; cv2.waitKey(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;0xFF&lt;/span&gt; == &lt;span class=&quot;hljs-built_in&quot;&gt;ord&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;q&amp;#x27;&lt;/span&gt;):    &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;</code></pre><p><span class="hljs-comment"># 捕获完毕后，释放摄像头</span><br>cap.release()<br>cv2.destroyAllWindows()</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE02466fed456f9f063a94a71c88c06be4" title="image.png" class="gallery-item"><img src="WEBRESOURCE02466fed456f9f063a94a71c88c06be4" alt="image.png"></a></p><p>&emsp;&emsp;cap.read() 返回一个布尔值（True/False）。如果要读取的帧存在，<br>就是True。因此最后你可以通过检查他的返回值来查看视频文件是否已经到<br>了结尾。<br><br>&emsp;&emsp;有时候cap可能不能成功的初始化摄像头设备，这种情况下上述代码会报错。这时可以使用cap.isOpened()来检查是否初始化成功，如果返回值是True，就表明没有问题。否则就要使用函数cap.open()。</p><p>&emsp;&emsp;另外，也可以使用函数cap.get(propId) 来获得视频的一些参数信息。这里的propId可以是0到18 之间的任何整数。每一个数代表视频的一个属性，数字所代表的摄像头属性见<br>下表:<br><a href="WEBRESOURCE63333b52cabc20bd977fee5562547154" title="image.png" class="gallery-item"><img src="WEBRESOURCE63333b52cabc20bd977fee5562547154" alt="image.png"></a></p><p>&emsp;&emsp;其中一些值可以通过cap.set(propId,value) 来修改。例如，我可以使用cap.get(3) 和cap.get(4) 来查看每一帧的宽和高。<br>默认情况下得到的值是640X480。但是我可以使用ret=cap.set(3,320)<br>和ret=cap.set(4,240) 来把宽和高改成320X240。</p><h2 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h2><p>&emsp;&emsp;从文件中播放视频与从摄像头中捕获一样，你只需要把设备索引号改成视频文件的名字即可。在播放每一帧时，使用cv2.waiKey()设置适当的持续时间。如果设置的太低视频就会播放的非常快，如果设置的太高就会播放的很慢（可以使用这种方法控制视频的播放速度）。通常情况下25 毫秒就可以了。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2cap = cv2.VideoCapture(<span class="hljs-number">0</span>)    <span class="hljs-comment"># 从文件中播放视频也要初始化VideoCapture对象</span><span class="hljs-comment"># 设置编/解码器</span>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">&#x27;XVID&#x27;</span>)    <span class="hljs-comment"># 在windows平台下使用DIVX编码模式</span><span class="hljs-comment"># 创建VideoWriter对象将图像信息写入视频文件</span>out = cv2.VideoWriter(<span class="hljs-string">&#x27;output.avi&#x27;</span>,fourcc, <span class="hljs-number">20.0</span>, (<span class="hljs-number">640</span>,<span class="hljs-number">480</span>))  <span class="hljs-comment"># 播放频率为20.0，每一帧大小应为640*480</span><span class="hljs-comment"># Video(filename, codec_format, play_frequency, frame_size, isColor)，isColor标签如果是True则每一帧是彩色图，否则是灰度图</span><span class="hljs-keyword">while</span>(cap.isOpened()):       <span class="hljs-comment"># 如果设备初始化成功</span>    ret, frame = cap.read()<span class="hljs-keyword">if</span> ret==<span class="hljs-literal">True</span>:    frame = cv2.flip(frame, <span class="hljs-number">0</span>) <span class="hljs-comment"># 图像翻转</span><span class="hljs-comment"># 将帧写入文件中</span>out.write(frame)cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>,frame)<span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):    <span class="hljs-keyword">break</span><span class="hljs-keyword">else</span>:    <span class="hljs-keyword">break</span><span class="hljs-comment"># 释放VideoCapture和VideoWriter对象</span>cap.release()out.release()cv2.destroyAllWindows()</code></pre><p>&emsp;&emsp;FourCC 就是一个4 字节码，用来确定视频的编码格式。可用的编码列表<br>可以从 fourcc.org 查到。</p><h1 id="OpenCV中的绘图函数"><a href="#OpenCV中的绘图函数" class="headerlink" title="OpenCV中的绘图函数"></a>OpenCV中的绘图函数</h1><p>&emsp;&emsp;OpenCV中的绘图函数，常用的有：cv2.line()，cv2.circle()，cv2.rectangle()，<br>cv2.ellipse()，cv2.putText()等。这些函数都需要设置下面这些参数：</p><ul><li><strong>img</strong>：你想要绘制图形的那幅图像的文件句柄。</li><li><strong>color</strong>：形状的颜色。以RGB为例，需要传入一个元组，例如：（255,0,0）代表蓝色。对于灰度图则只需要传入灰度值。</li><li><strong>thickness</strong>：线条的粗细。如果给一个闭合图形设置为-1，那么这个图形就会被填充。默认值是1。</li><li><strong>linetype</strong>：线条的样式，端点连接方式，是否抗锯齿等。默认情况是连接方式。cv2.LINE_AA为抗锯齿，这样看起来会非常平滑。</li></ul><h2 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 通过指定像素点创建一张黑色的图作为背景</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<span class="hljs-comment"># 画5px粗的蓝色斜线line(img, start, end, color, thickness)</span>cv2.line(img,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">511</span>,<span class="hljs-number">511</span>),(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>,img)  <span class="hljs-comment"># 写入图像</span></code></pre><p><a href="WEBRESOURCE3850ac3b21f0def1ba33027464e68400" title="image.png" class="gallery-item"><img src="WEBRESOURCE3850ac3b21f0def1ba33027464e68400" alt="image.png"></a></p><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 通过指定像素点创建一张黑色的图作为背景</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<span class="hljs-comment"># (img, lefttop_coord，rightbittom_coord，color， thickness)</span>cv2.rectangle(img,(<span class="hljs-number">384</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">510</span>,<span class="hljs-number">128</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">3</span>)cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>,img)  <span class="hljs-comment"># 写入图像</span></code></pre><p><a href="WEBRESOURCEa8b7285eba1daca6d15e7fddb2820258" title="image.png" class="gallery-item"><img src="WEBRESOURCEa8b7285eba1daca6d15e7fddb2820258" alt="image.png"></a></p><h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 通过指定像素点创建一张黑色的图作为背景</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<span class="hljs-comment"># (img, center，r，color，thickness)</span>cv2.circle(img,(<span class="hljs-number">447</span>,<span class="hljs-number">63</span>), <span class="hljs-number">63</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)    <span class="hljs-comment"># 闭合图形的粗细为-1表示填充</span>cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>,img)</code></pre><p><a href="WEBRESOURCEea78c6179f36cde0141c9e7975263e68" title="image.png" class="gallery-item"><img src="WEBRESOURCEea78c6179f36cde0141c9e7975263e68" alt="image.png"></a></p><h2 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 通过指定像素点创建一张黑色的图作为背景</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<span class="hljs-comment"># (img, (cx, cy), (rx, ry), rotate, (startAngle, endAnge), color[BGR], thickness)</span>cv2.ellipse(img,(<span class="hljs-number">256</span>,<span class="hljs-number">256</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>),<span class="hljs-number">180</span>,<span class="hljs-number">0</span>,<span class="hljs-number">180</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">22</span>),<span class="hljs-number">-1</span>)cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>,img)</code></pre><p><a href="WEBRESOURCE3049e4b4652c525f131868d7a800ac94" title="image.png" class="gallery-item"><img src="WEBRESOURCE3049e4b4652c525f131868d7a800ac94" alt="image.png"></a></p><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 通过指定像素点创建一张黑色的图作为背景</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<span class="hljs-comment"># 指定画多边形所需要的关键点</span>points=np.array([[<span class="hljs-number">10</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>],[<span class="hljs-number">70</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">50</span>,<span class="hljs-number">10</span>]], np.int32)points=pts.reshape((<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<span class="hljs-comment"># (img, [point_lst], isClosepath, color, thickness)</span>cv2.polylines(img,[points],<span class="hljs-literal">True</span>,(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<span class="hljs-number">33</span>)cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>,img)</code></pre><p><a href="WEBRESOURCE6116dfb069ff50371f6dd8d74890af5c" title="image.png" class="gallery-item"><img src="WEBRESOURCE6116dfb069ff50371f6dd8d74890af5c" alt="image.png"></a></p><h2 id="在图片上添加文字"><a href="#在图片上添加文字" class="headerlink" title="在图片上添加文字"></a>在图片上添加文字</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 通过指定像素点创建一张黑色的图作为背景</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<span class="hljs-comment"># (img, text, position, fontFamily, fontsize color, thickness)</span>font=cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img, <span class="hljs-string">&#x27;studyOpenCV&#x27;</span>, (<span class="hljs-number">20</span>,<span class="hljs-number">250</span>), font, <span class="hljs-number">2</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>), <span class="hljs-number">2</span>)cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>,img)</code></pre><p><a href="WEBRESOURCE1337de1f5bc1a55b1150a59155d8dfa9" title="image.png" class="gallery-item"><img src="WEBRESOURCE1337de1f5bc1a55b1150a59155d8dfa9" alt="image.png"></a></p><h1 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h1><p>查看OpenCV中支持的鼠标事件：<br><pre><code class="hljs matlab">import cv2<span class="hljs-keyword">events</span>=[<span class="hljs-built_in">i</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> in dir(cv2) <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;EVENT&#x27;</span>in <span class="hljs-built_in">i</span>]print(<span class="hljs-keyword">events</span>)</code></pre><br><a href="WEBRESOURCE0c1d35319dd3e94d7fd7ea4f924e4a84" title="image.png" class="gallery-item"><img src="WEBRESOURCE0c1d35319dd3e94d7fd7ea4f924e4a84" alt="image.png"></a></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 用鼠标做画笔(这个有点类似processing中的鼠标画笔)</span><span class="hljs-comment"># 与鼠标事件绑定后，特定鼠标事件被激发后，相应的信息如event对象，鼠标坐标x,y等都会作为参数传给这个鼠标事件的回调函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_circle</span>(<span class="hljs-params">event,x,y,flags=<span class="hljs-number">0</span>,param=&#123;&#125;</span>):</span>    <span class="hljs-keyword">if</span> event==cv2.EVENT_LBUTTONDBLCLK:   <span class="hljs-comment"># 鼠标左键单击</span>        cv2.circle(img,(x,y),<span class="hljs-number">100</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">-1</span>)<span class="hljs-comment"># 创建背景图像与窗口，并将窗口与回调函数绑定</span>img=np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>),np.uint8)cv2.namedWindow(<span class="hljs-string">&#x27;image&#x27;</span>)cv2.setMouseCallback(<span class="hljs-string">&#x27;image&#x27;</span>,draw_circle)    <span class="hljs-comment"># 绑定鼠标回调函数</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):    cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">20</span>) == <span class="hljs-number">27</span>:    <span class="hljs-comment"># 按下&#x27;ESC&#x27;时关闭</span>        <span class="hljs-keyword">break</span>cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEf2ee1a507645f9d59276ebe13e3a1335" title="image" class="gallery-item"><img src="WEBRESOURCEf2ee1a507645f9d59276ebe13e3a1335" alt="image"></a></p><h1 id="使用滑动条"><a href="#使用滑动条" class="headerlink" title="使用滑动条"></a>使用滑动条</h1><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span>(<span class="hljs-params">x</span>):</span>    <span class="hljs-keyword">pass</span><span class="hljs-comment"># 创建一副黑色图像作为背景</span>img=np.zeros((<span class="hljs-number">200</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>),np.uint8)cv2.namedWindow(<span class="hljs-string">&#x27;image&#x27;</span>)cv2.createTrackbar(<span class="hljs-string">&#x27;R&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,nothing)    <span class="hljs-comment"># 创建滑动条，滑动条标识符&#x27;R&#x27;，值的变化区间在[0-255]，滑动条的值每次改变都会调用函数nothing()</span>cv2.createTrackbar(<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,nothing)cv2.createTrackbar(<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,nothing)switch=<span class="hljs-string">&#x27;0:OFF\n1:ON&#x27;</span>cv2.createTrackbar(switch,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,nothing)   <span class="hljs-comment"># 创建图像开关滑动条，只有0，1两个选项</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):   <span class="hljs-comment"># 时刻检查滑动条的值来更新图像的RGB值</span>    cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)    <span class="hljs-comment"># 显示图像</span>    k=cv2.waitKey(<span class="hljs-number">1</span>)    <span class="hljs-keyword">if</span> k == <span class="hljs-number">27</span>:        <span class="hljs-keyword">break</span>    r=cv2.getTrackbarPos(<span class="hljs-string">&#x27;R&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>)   <span class="hljs-comment"># 从标识符为&#x27;R&#x27;的滑动条中取得值</span>    g=cv2.getTrackbarPos(<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>)    b=cv2.getTrackbarPos(<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>)    s=cv2.getTrackbarPos(switch,<span class="hljs-string">&#x27;image&#x27;</span>)    <span class="hljs-keyword">if</span> s==<span class="hljs-number">0</span>:        img[:]=<span class="hljs-number">0</span>    <span class="hljs-keyword">else</span>:        img[:]=[b,g,r]    <span class="hljs-comment"># 图像的RGB像素更新为各滑动条中的值</span>cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE84519f19ad5b7eeaf43bc0defa67882e" title="image" class="gallery-item"><img src="WEBRESOURCE84519f19ad5b7eeaf43bc0defa67882e" alt="image"></a></p><p>使用滑动条和鼠标事件来实现一个更复杂的效果：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">pass</span></p><p><span class="hljs-comment"># 当鼠标按下时变为True</span><br>drawing=<span class="hljs-literal">False</span></p><p><span class="hljs-comment"># 如果mode 为true 就绘制矩形。按下&#x27;m&#x27;则变成绘制曲线。</span><br>mode=<span class="hljs-literal">True</span><br>ix,iy=<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>        <span class="hljs-comment"># 要绘制的矩形左上角的坐标</span></p><p><span class="hljs-comment"># 创建回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_circle</span>(<span class="hljs-params">event,x,y,flags,param</span>):</span><br>    r=cv2.getTrackbarPos(<span class="hljs-string">&#x27;R&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>)   <span class="hljs-comment"># 获取滑动条的值</span><br>    g=cv2.getTrackbarPos(<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>)<br>    b=cv2.getTrackbarPos(<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>)<br>    color=(b,g,r)</p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; ix,iy,drawing,mode    &lt;span class=&quot;hljs-comment&quot;&gt;# 在该函数内允许使用全局变量ix,iy,drawing,mode(这种语法有点类似PHP中的全局变量语法)&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; event==cv2.EVENT_LBUTTONDOWN:    &lt;span class=&quot;hljs-comment&quot;&gt;# 当按下左键时返回起始位置坐标&lt;/span&gt;    drawing=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;    ix,iy=x,y&lt;span class=&quot;hljs-comment&quot;&gt;# 当鼠标左键按下并移动时绘制图形。由event参数可得是否移动，由flag可得鼠标是否按下&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; event==cv2.EVENT_MOUSEMOVE &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; flags==cv2.EVENT_FLAG_LBUTTON:    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; drawing==&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; mode==&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:            cv2.rectangle(img,(ix,iy),(x,y),color,&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:            &lt;span class=&quot;hljs-comment&quot;&gt;# 绘制圆圈，小圆点连在一起成了线，3 代表了笔画的粗细&lt;/span&gt;            cv2.circle(img,(x,y),&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,color,&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)     &lt;span class=&quot;hljs-comment&quot;&gt;# 当鼠标松开停止绘画&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; event==cv2.EVENT_LBUTTONUP:    drawing==&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; mode==&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;:      cv2.rectangle(img,(ix,iy),(x,y),(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;),&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:      cv2.circle(img,(x,y),&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;255&lt;/span&gt;),&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)</code></pre><p><span class="hljs-comment"># img是一个由全[0,0,0]组成的三维数组，在这里表示每一像素点的颜色值</span><br>img=np.zeros((<span class="hljs-number">200</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">&#x27;image&#x27;</span>)<br>cv2.createTrackbar(<span class="hljs-string">&#x27;R&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,nothing)<br>cv2.createTrackbar(<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,nothing)<br>cv2.createTrackbar(<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;image&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,nothing)<br>cv2.setMouseCallback(<span class="hljs-string">&#x27;image&#x27;</span>,draw_circle)    <span class="hljs-comment"># 绑定鼠标回调事件</span></p><p><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>    cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,img)<br>    k=cv2.waitKey(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> k==<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;m&#x27;</span>):<br>        mode=<span class="hljs-keyword">not</span> mode    <span class="hljs-comment"># 取反</span><br>    <span class="hljs-keyword">elif</span> k==<span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span></code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE29b2a1435f34fed5a5344f08b5c35a71" title="image" class="gallery-item"><img src="WEBRESOURCE29b2a1435f34fed5a5344f08b5c35a71" alt="image"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="Python" scheme="https://baibainote.pro/categories/Python/"/>
    
    
      <category term="opencv-python" scheme="https://baibainote.pro/tags/opencv-python/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV核心操作</title>
    <link href="https://baibainote.pro/2020/03/15/OpenCV%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C/"/>
    <id>https://baibainote.pro/2020/03/15/OpenCV核心操作/</id>
    <published>2020-03-15T07:35:06.057Z</published>
    <updated>2020-03-15T07:35:06.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<ul><li><a href="#图像的基本操作">图像的基本操作</a><ul><li><a href="#获取并修改像素值">获取并修改像素值</a></li><li><a href="#获取的图像的属性">获取的图像的属性</a></li><li><a href="#图像ROI">图像ROI</a></li><li><a href="#拆分和合并图像通道">拆分和合并图像通道</a></li><li><a href="#为图像括边">为图像括边</a></li></ul></li><li><a href="#图像上的算术运算">图像上的算术运算</a><ul><li><a href="#图像加法">图像加法</a></li><li><a href="#图像混合">图像混合</a></li><li><a href="#按位计算">按位计算</a></li></ul></li><li><a href="#程序性能检测及优化">程序性能检测及优化</a><ul><li><a href="#使用OpenCV检测程序效率">使用OpenCV检测程序效率</a></li><li><a href="#OpenCV中的默认优化">OpenCV 中的默认优化</a></li></ul></li></ul><h1 id="图像的基本操作"><a href="#图像的基本操作" class="headerlink" title="图像的基本操作"></a>图像的基本操作</h1><h2 id="获取并修改像素值"><a href="#获取并修改像素值" class="headerlink" title="获取并修改像素值"></a>获取并修改像素值</h2><p>&emsp;&emsp;可以根据像素的行与列的坐标来获取它的像素值。对BGR图像而言，返回值为B，G，R 的值。对灰度图像而言，会返回它的灰度值。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)px = img[<span class="hljs-number">100</span>, <span class="hljs-number">100</span>]         <span class="hljs-comment"># 某一像素点的颜色BGR表示</span>print(px)blue = img[<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]    <span class="hljs-comment"># 某一像素点的Blue颜色分量</span>print(blue)</code></pre><p><a href="WEBRESOURCE6d7baca158d17692c83b8fa28ac74cb1" title="image.png" class="gallery-item"><img src="WEBRESOURCE6d7baca158d17692c83b8fa28ac74cb1" alt="image.png"></a></p><p>当然了，也可以用这种方法更改某一点的像素值：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)</p><p>img[<span class="hljs-number">100</span>,<span class="hljs-number">100</span>]=[<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>]<br>print(img[<span class="hljs-number">100</span>,<span class="hljs-number">100</span>])</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCEbaafbcf85a3bbcb1c07459ba5591d965" title="image.png" class="gallery-item"><img src="WEBRESOURCEbaafbcf85a3bbcb1c07459ba5591d965" alt="image.png"></a></p><p>&emsp;&emsp;上面用于更改某一点的像素值的方法被用来选取矩阵的一个区域，比如说前5行的后3<br>列。对于获取每一个像素值，可以使用Numpy 的array.item() 和array.<br>itemset() 来进行遍历操作。但这两个函数的返回值都是标量。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)print(img.item(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>))    <span class="hljs-comment"># 输出(10,10,2)处像素点的值</span>img.itemset((<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<span class="hljs-number">100</span>)    <span class="hljs-comment"># 将(10,10,2)处的值设为100</span>print(img.item(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>))</code></pre><p><a href="WEBRESOURCE78c77e4e2caa830fd7888551f703ba49" title="image.png" class="gallery-item"><img src="WEBRESOURCE78c77e4e2caa830fd7888551f703ba49" alt="image.png"></a></p><h2 id="获取的图像的属性"><a href="#获取的图像的属性" class="headerlink" title="获取的图像的属性"></a>获取的图像的属性</h2><p>图像的属性包括：行，列，通道，图像数据类型，像素数目等。</p><p>img.shape 可以获取图像的形状。他的返回值是一个包含行数，列数，颜色通道数的元组。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)</p><p>print(img.shape)</code></pre>:hexoPostRenderEscape–&gt;<br>&emsp;&emsp;如果图像是灰度图，img.shape的返回值就只有行数和列数。所以通过检查这个返回值就可以知道加载的是灰度图还是彩色图。</p><p><a href="WEBRESOURCE6c2a10b16b1cf512f3fcd3bc0e6909d3" title="image.png" class="gallery-item"><img src="WEBRESOURCE6c2a10b16b1cf512f3fcd3bc0e6909d3" alt="image.png"></a></p><p>img.size 可以返回图像的像素数目。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)print(img.size)</code></pre><p><a href="WEBRESOURCE35eeffd487e7f99b153f677db84f2320" title="image.png" class="gallery-item"><img src="WEBRESOURCE35eeffd487e7f99b153f677db84f2320" alt="image.png"></a></p><p>img.dtype 返回的是图像的数据类型。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)</p><p>print(img.dtype)</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCEb9ceeb8d12d33a23e61749d42411bdea" title="image.png" class="gallery-item"><img src="WEBRESOURCEb9ceeb8d12d33a23e61749d42411bdea" alt="image.png"></a></p><h2 id="图像ROI"><a href="#图像ROI" class="headerlink" title="图像ROI"></a>图像ROI</h2><p>&emsp;&emsp;有时我们需要对一幅图像的特定区域进行操作。例如我们要检测一副图像中眼睛的位置，我们首先应该在图像中找到脸，再在脸的区域中找眼睛，而不是直接在一幅图像中搜索眼睛。灵活的使用ROI操作会提高程序的准确性和性能。ROI 是使用Numpy 索引来获得的。</p><div style="border: 1px solid #ddd;padding:2px;"><br><div style="background-color:#906060;color:white;text-align:center;padding:5px;border-radius:5px;">注意</div><p>&emsp;&emsp;图像不存在或内容为空时不能用[ ]取出其中的像素点，会报<code>&#39;NoneType&#39; object is not subscriptable</code>这样的错误。<br></div><br></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>)ball=img[<span class="hljs-number">280</span>:<span class="hljs-number">340</span>,<span class="hljs-number">330</span>:<span class="hljs-number">390</span>]   <span class="hljs-comment"># 框定一个矩形取出选中的像素区域</span>img[<span class="hljs-number">273</span>:<span class="hljs-number">333</span>,<span class="hljs-number">100</span>:<span class="hljs-number">160</span>]=ball   <span class="hljs-comment"># 将拷贝得到的子图复制到图像中的另一块区域</span></code></pre><h2 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h2><p>&emsp;&emsp;有时我们需要对BGR 三个通道分别进行操作，这时就需要把BGR拆分成单个通道进行处理，可以使用<code>cv2.split()</code>。<br>也可以使用<code>cv2.merge()</code>把独立通道的图片合并成一个BGR 图像。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)b,g,r = cv2.split(img)  <span class="hljs-comment"># 将BGR图像拆分成三个通道</span>img=cv2.merge(b,g)    <span class="hljs-comment"># 合并两个通道</span>b=img[:,:,<span class="hljs-number">0</span>]</code></pre><p>cv2.split() 是一个比较耗时的操作，只有真正需要时才用它，平时尽量使用numpy索引取像素点。</p><p><a href="WEBRESOURCEfb351b487c60d81664b9153ef11dec3a" title="image.png" class="gallery-item"><img src="WEBRESOURCEfb351b487c60d81664b9153ef11dec3a" alt="image.png"></a></p><p>&emsp;&emsp;事实上，如果我们想让图像所有像素点的红色通道值都为0的话，不用拆分通道后再对其进行操作，可以直接使用numpy索引实现。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)<br>img[:,:,<span class="hljs-number">2</span>]=<span class="hljs-number">0</span><br>cv2.imwrite(<span class="hljs-string">&#x27;paint.jpg&#x27;</span>, img)</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE309363e875f4341774a11a6845e568f4" title="image.png" class="gallery-item"><img src="WEBRESOURCE309363e875f4341774a11a6845e568f4" alt="image.png"></a></p><h2 id="为图像括边"><a href="#为图像括边" class="headerlink" title="为图像括边"></a>为图像括边</h2><p>&emsp;&emsp;如果你想在图像周围创建一个边，就像相框一样，你可以使用<code>cv2.copyMakeBorder()</code>函数。这经常在卷积运算或0 填充时被用到。</p><p>这个函数所需的参数如下：<br><a href="WEBRESOURCEb24e8b77cffe46404d302ded6bce0ccb" title="image.png" class="gallery-item"><img src="WEBRESOURCEb24e8b77cffe46404d302ded6bce0ccb" alt="image.png"></a></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltBLUE=[<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]img1=cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>)<span class="hljs-comment"># 设置不同的括边方式</span>replicate = cv2.copyMakeBorder(img1,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,cv2.BORDER_REPLICATE)   <span class="hljs-comment"># 复制源图像img1的像素值并为其进行括边</span>reflect = cv2.copyMakeBorder(img1,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,cv2.BORDER_REFLECT)reflect101 = cv2.copyMakeBorder(img1,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,cv2.BORDER_REFLECT_101)wrap = cv2.copyMakeBorder(img1,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,cv2.BORDER_WRAP)constant= cv2.copyMakeBorder(img1,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,cv2.BORDER_CONSTANT,value=BLUE)<span class="hljs-comment"># 添加几个子图并显示</span>plt.subplot(<span class="hljs-number">231</span>), plt.imshow(img1,<span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;ORIGINAL&#x27;</span>)plt.subplot(<span class="hljs-number">232</span>), plt.imshow(replicate,<span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REPLICATE&#x27;</span>)plt.subplot(<span class="hljs-number">233</span>), plt.imshow(reflect,<span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REFLECT&#x27;</span>)plt.subplot(<span class="hljs-number">234</span>), plt.imshow(reflect101,<span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REFLECT_101&#x27;</span>)plt.subplot(<span class="hljs-number">235</span>), plt.imshow(wrap,<span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;WRAP&#x27;</span>)plt.subplot(<span class="hljs-number">236</span>), plt.imshow(constant,<span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;CONSTANT&#x27;</span>)plt.show()</code></pre><p><a href="WEBRESOURCEaf17a5ad85522974fabcf07d95c96139" title="image.png" class="gallery-item"><img src="WEBRESOURCEaf17a5ad85522974fabcf07d95c96139" alt="image.png"></a></p><h1 id="图像上的算术运算"><a href="#图像上的算术运算" class="headerlink" title="图像上的算术运算"></a>图像上的算术运算</h1><h2 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h2><p>&emsp;&emsp;可以使用函数<code>cv2.add()</code>对两幅图像进行加法运算，当然也可以直接使用numpy，即<code>res=img1+img</code>。<font color=#609090>两幅图像的大小，类型必须一致</font>，或者第二个图像是一个简单的标量值。</p><div style="border: 1px solid #ddd;padding:2px;"><br><div style="background-color:#906060;color:white;text-align:center;padding:5px;border-radius:5px;">注意</div><p>&emsp;&emsp;OpenCV 中的加法与Numpy 的加法是有所不同的。OpenCV 的加法是一种饱和操作，而Numpy 的加法是一种模操作。<br></div><br></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2x = np.uint8([<span class="hljs-number">250</span>])y = np.uint8([<span class="hljs-number">10</span>])print(cv2.add(x, y)) <span class="hljs-comment"># OpenCV图像加法，250+10 = 260 =&gt; 255</span>print(x+y)           <span class="hljs-comment"># numpy取模加法，250+10 = 260 % 256 = 4</span></code></pre><p><a href="WEBRESOURCEae11fe265ff70931f6e24ae6cf0f583c" title="image.png" class="gallery-item"><img src="WEBRESOURCEae11fe265ff70931f6e24ae6cf0f583c" alt="image.png"></a></p><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>&emsp;&emsp;图像混合其实也是一种图像加法，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合的计算公式如下：<br><pre><code class="hljs math">g(x) &#x3D; (1-\alpha)f_0(x) + \alpha f_1(x)</code></pre><br>通过改变<code>$\alpha$</code>的值可以实现图像的平滑效果。</p><p>&emsp;&emsp;下面我们把两幅图混合在一起。第一幅图的权重是0.7，第二幅图的权重是0.3。函数<code>cv2.addWeighted()</code>可以按下面的公式对图片进行混合操作:<br><pre><code class="hljs math">dst &#x3D; \alpha.img1 + \beta.img2 + \gamma</code></pre></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg1=cv2.imread(<span class="hljs-string">&#x27;ml.png&#x27;</span>)img2=cv2.imread(<span class="hljs-string">&#x27;opencv-logo.png&#x27;</span>)dst=cv2.addWeighted(img1,<span class="hljs-number">0.7</span>,img2,<span class="hljs-number">0.3</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment"># 第一幅图的权重是0.7，第二幅图的权重是0.3</span>cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>,dst)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindow()</code></pre><p><a href="WEBRESOURCE82ac39e0bfebcc238e7fd2d46f3877bb" title="image.png" class="gallery-item"><img src="WEBRESOURCE82ac39e0bfebcc238e7fd2d46f3877bb" alt="image.png"></a></p><h2 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h2><p>&emsp;&emsp;这里包括的按位操作有：AND，OR，NOT，XOR 等。当我们提取图像的一部分，选择非矩形ROI 时这些操作会很有用</p><p>&emsp;&emsp;现在我想把OpenCV 的标志放到另一幅图像上。如果使用加法，颜色会改变，如果使用混合，会得到透明效果，但是我不想要透明。如果它是矩形那么我可以使用ROI。但事实上它不是矩形。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 加载图像</span>img1 = cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>)img2 = cv2.imread(<span class="hljs-string">&#x27;opencv-logo.png&#x27;</span>)<span class="hljs-comment"># 想把logo放在img1的左上角，所以这里先创建一个ROI区域</span>rows,cols,channels = img2.shape    <span class="hljs-comment"># 根据img2的Logo尺寸在img1上开一个ROI区域</span>roi = img1[<span class="hljs-number">0</span>:rows, <span class="hljs-number">0</span>:cols ]img2gray = cv2.cvtColor(img2,cv2.COLOR_BGR2GRAY)    <span class="hljs-comment"># 先将彩色图转换为灰度图(图像阈值化处理的前一步骤)</span><span class="hljs-comment"># 图像阈值化处理</span><span class="hljs-comment"># 创建一个图像的掩膜和它翻转后的图像的掩膜(制作掩膜的目的是保护被掩膜覆盖的区域，之后的操作将只影响掩膜之外的区域)</span><span class="hljs-comment"># 使用cv2.threshold()将img2gray中大于175像素的值设为0(黑色)，小于175像素的设为255(白色)，cv2.THRESH_BINARY表示采用的是二进制阈值化模式</span>ret, mask = cv2.threshold(img2gray, <span class="hljs-number">175</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)mask_inv = cv2.bitwise_not(mask)    <span class="hljs-comment"># 对掩膜进行&#x27;按位非&#x27;操作，黑色=&gt;白色</span><span class="hljs-comment"># 剔除logo图片中ROI区域之外的像素，取roi 中与mask 中不为零的值对应的像素的值，其他值为0</span><span class="hljs-comment"># 注意这里必须有mask=mask 或者mask=mask_inv, 这里的mask= 参数不能缺省</span>img1_bg = cv2.bitwise_and(roi,roi,mask = mask)<span class="hljs-comment"># 取roi 中与mask_inv 中不为零的值对应的像素的值，其他值为0。</span>img2_fg = cv2.bitwise_and(img2,img2,mask = mask_inv)    <span class="hljs-comment"># 从logo图片img2中取出掩膜mask_inv覆盖的区域作为前景</span>dst = cv2.add(img1_bg,img2_fg)     <span class="hljs-comment"># 将img1_bg背景和img2_fg前景进行图像拼接操作，生成最终将要嵌入到源图像中的图像dst</span>img1[<span class="hljs-number">0</span>:rows, <span class="hljs-number">0</span>:cols] = dst         <span class="hljs-comment"># 改变源图像中设置了ROI的区域</span>cv2.namedWindow(<span class="hljs-string">&#x27;res&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;mask&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;mask_inv&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;img1_bg&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;img2_fg&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;res&#x27;</span>,img1)cv2.imshow(<span class="hljs-string">&#x27;mask&#x27;</span>,mask)cv2.imshow(<span class="hljs-string">&#x27;mask_inv&#x27;</span>,mask_inv)cv2.imshow(<span class="hljs-string">&#x27;img1_bg&#x27;</span>,img1_bg)cv2.imshow(<span class="hljs-string">&#x27;img2_fg&#x27;</span>,img2_fg)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE2b2c5076bdfeee89393610f180f302e2" title="image.png" class="gallery-item"><img src="WEBRESOURCE2b2c5076bdfeee89393610f180f302e2" alt="image.png"></a></p><h1 id="程序性能检测及优化"><a href="#程序性能检测及优化" class="headerlink" title="程序性能检测及优化"></a>程序性能检测及优化</h1><p>&emsp;&emsp;在图像处理中每秒钟都要做大量的运算，所以给出的程序不仅要能得到正确的处理结果，同时还必须要快。</p><h2 id="使用OpenCV检测程序效率"><a href="#使用OpenCV检测程序效率" class="headerlink" title="使用OpenCV检测程序效率"></a>使用OpenCV检测程序效率</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npe1 = cv2.getTickCount()<span class="hljs-comment"># func()   函数执行代码段</span>e2 = cv2.getTickCount()    <span class="hljs-comment"># 返回从参考点到这个函数被执行的时钟数</span><span class="hljs-comment"># (e2 - e1)得到两次调用getTickFrequency()之间的时间间隔</span>time = (e2 - e1)/ cv2.getTickFrequency()   <span class="hljs-comment"># cv2.getTickFrequency() 是时钟频率，即每秒钟的时钟数</span></code></pre><p>看一个例子：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img1 = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)<br>e1 = cv2.getTickCount()</p><p><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">if</span> i!=<span class="hljs-number">0</span>:<br>        img1 = cv2.medianBlur(img1,<span class="hljs-number">1</span>)</p><p>e2 = cv2.getTickCount()</p><p>t = (e2 - e1)/cv2.getTickFrequency()<br>print(t)</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCEf44e566b70abd030966e3abf0fa293c4" title="image.png" class="gallery-item"><img src="WEBRESOURCEf44e566b70abd030966e3abf0fa293c4" alt="image.png"></a></p><h2 id="OpenCV-中的默认优化"><a href="#OpenCV-中的默认优化" class="headerlink" title="OpenCV 中的默认优化"></a>OpenCV 中的默认优化</h2><p>&emsp;&emsp;事实上，OpenCV 中的很多函数都被优化过（SSE2，AVX 等），当然也包含一些没有被优化的代码。如果我们的系统支持优化的话那自然要充分利用这一点。在编译时优化是默认开启的，因此OpenCV运行的就是优化后的代码。你可以使用函数cv2.useOptimized()来查看优化是否被开启了，如果没有开启，使用函数cv2.setUseOptimized()来开启优化。</p><pre><code class="hljs pyhton">import cv2import numpy as npimg &#x3D; cv2.imread(&#39;miss.jpg&#39;, 0)cv2.useOptimized()    # 查看是否开启了优化(默认开启)# 观察同一段程序运行的时间，直观感受优化后的效率提升%timeit res &#x3D; cv2.medianBlur(img,49)    # 图像中值滤波cv2.setUseOptimized(False)    # 关闭优化cv2.useOptimized()%timeit res &#x3D; cv2.medianBlur(img,49)    # 很明显这段语句相比上面开启了优化后的语句执行时间变长了</code></pre><p><a href="WEBRESOURCE4526221ecbe96ddd16e16de8efcc7f8e" title="image.png" class="gallery-item"><img src="WEBRESOURCE4526221ecbe96ddd16e16de8efcc7f8e" alt="image.png"></a></p><p>&emsp;&emsp;再来比较一下cv2.countNonZero()和np.count_nonzero()这两个函数的运行效率，可见，opencv中的函数较numpy做了更多的优化。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>,<span class="hljs-number">0</span>)%timeit z = cv2.countNonZero(img)<span class="hljs-comment"># 4.7 µs ± 5.65 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span>%timeit z = np.count_nonzero(img)<span class="hljs-comment"># 640 ns ± 2.29 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span></code></pre><p><a href="WEBRESOURCEe0703bcdc37ff4bf97300df029fb9023" title="image.png" class="gallery-item"><img src="WEBRESOURCEe0703bcdc37ff4bf97300df029fb9023" alt="image.png"></a></p><p>程序优化注意事项：<br><a href="WEBRESOURCE0ef307208c25fd58446882e407b9d7a5" title="image.png" class="gallery-item"><img src="WEBRESOURCE0ef307208c25fd58446882e407b9d7a5" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="Python" scheme="https://baibainote.pro/categories/Python/"/>
    
    
      <category term="opencv-python" scheme="https://baibainote.pro/tags/opencv-python/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中的图像处理</title>
    <link href="https://baibainote.pro/2020/03/15/OpenCV%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>https://baibainote.pro/2020/03/15/OpenCV中的图像处理/</id>
    <published>2020-03-15T07:35:06.055Z</published>
    <updated>2020-03-15T07:35:06.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h1 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h1><h2 id="转换颜色空间"><a href="#转换颜色空间" class="headerlink" title="转换颜色空间"></a>转换颜色空间</h2><p>&emsp;&emsp;OpenCV提供了超过150 种进行颜色空间转换的方法，但是以后经常用到的其实也就两种：BGR&rarr;Gray 和BGR&rarr;HSV。进行颜色空间转换的函数是：<code>cv2.cvtColor(input_image，flag)</code>，其中flag就是要转换到的类型。</p><p>&emsp;&emsp;对于BGR&rarr;Gray 的转换，我们要使用的flag 就是cv2.COLOR_ BGR2GRAY。而对于BGR&rarr;HSV 的转换，我们用的flag 就是cv2.COLOR_BGR2HSV。</p><p>可以使用下面的程序输出opencv中支持的所有用于颜色空间转换的flag：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2</p><p>flags=[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">dir</span>(cv2) <span class="hljs-keyword">if</span> i.startswith(<span class="hljs-string">&#x27;COLOR_&#x27;</span>)]<br>print(flags)</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE0e328e78ef5da029363c35b38d0fc051" title="image.png" class="gallery-item"><img src="WEBRESOURCE0e328e78ef5da029363c35b38d0fc051" alt="image.png"></a></p><div style="border: 1px solid #ddd;padding:2px;"><br><div style="background-color:#609090;color:white;text-align:center;padding:5px;border-radius:5px;">注意</div><p>&emsp;&emsp;在OpenCV 的HSV 格式中，H（色彩/色度）的取值范围是[0，179]，S（饱和度）的取值范围[0，255]，V（亮度）的取值范围[0，255]。但是不同软件使用的值可能不同，所以当你需要拿OpenCV 的HSV 值与其他软<br>件的HSV 值进行对比时，一定要记得归一化处理。<br></div><br></p><h2 id="物体跟踪"><a href="#物体跟踪" class="headerlink" title="物体跟踪"></a>物体跟踪</h2><p>&emsp;&emsp;我们已经知道怎样将一幅图像从BGR颜色空间转换到HSV了，这样一来，我们就可以利用这一点来提取带有某个特定颜色的物体。在HSV颜色空间中要比在BGR空间中更容易表示一个特定颜色。</p><p>在接下来的例子中我们要提取一个蓝色的物体，做下面几步操作：</p><ul><li>从视频中获取每一帧图像；</li><li>将图像转换到HSV 空间；</li><li>设置HSV 阈值到蓝色范围。</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npcap=cv2.VideoCapture(<span class="hljs-number">0</span>)<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):    <span class="hljs-comment"># 获取捕获到的每一帧</span>    ret,frame=cap.read()    <span class="hljs-comment"># 转换到HSV颜色空间</span>    hsv_img=cv2.cvtColor(frame,cv2.COLOR_BGR2HSV)    <span class="hljs-comment"># 设定蓝色的阈值(颜色值达到什么样才判断为蓝色)</span>    lower_blue=np.array([<span class="hljs-number">110</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>])    upper_blue=np.array([<span class="hljs-number">130</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>])    <span class="hljs-comment"># 根据阈值构建掩模(低于lower_blue为黑色，高于upper_blue的为白色)</span>    mask=cv2.inRange(hsv_img,lower_blue,upper_blue)    <span class="hljs-comment"># 对原图像和掩模进行按位与运算</span>    res=cv2.bitwise_and(frame,frame,mask=mask)    <span class="hljs-comment"># 显示图像</span>    cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>,frame)    cv2.imshow(<span class="hljs-string">&#x27;mask&#x27;</span>,mask)    cv2.imshow(<span class="hljs-string">&#x27;res&#x27;</span>,res)    k=cv2.waitKey(<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> k==<span class="hljs-number">27</span>:        <span class="hljs-keyword">break</span><span class="hljs-comment"># 关闭窗口</span>cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE90bdfb92a45299da1b8d8eeae88459d6" title="image.png" class="gallery-item"><img src="WEBRESOURCE90bdfb92a45299da1b8d8eeae88459d6" alt="image.png"></a></p><p>上图掩膜中一些白色的点就是图像处理中的噪点。</p><h2 id="找到跟踪对象的HSV-值"><a href="#找到跟踪对象的HSV-值" class="headerlink" title="找到跟踪对象的HSV 值"></a>找到跟踪对象的HSV 值</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 不能用[0,255,0]，而要用[[[0,255,0]]]</span><span class="hljs-comment"># 这里的三层括号应该分别对应于cvArray，cvMat，IplImage</span>green=np.uint8([[[<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>]]])hsv_green=cv2.cvtColor(green,cv2.COLOR_BGR2HSV)    <span class="hljs-comment"># 绿色的HSV值</span>print(hsv_green)</code></pre><p><a href="WEBRESOURCEf817a41fc9fb30078ced4506854a3886" title="image.png" class="gallery-item"><img src="WEBRESOURCEf817a41fc9fb30078ced4506854a3886" alt="image.png"></a></p><p>可见，BGR颜色空间中的绿色对应HSV的[60,255,255]。</p><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p>&emsp;&emsp;OpenCV 提供了两个变换函数，<code>cv2.warpAffine</code>和<code>cv2.warpPerspective</code>，使用这两个函数你可以实现所有类型的变换。cv2.warpAffine 接收的参数是2 <em> 3的变换矩阵，而cv2.warpPerspective 接收的参数是3 </em> 3 的变换矩阵。</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>&emsp;&emsp;扩展缩放只是改变图像的尺寸大小。OpenCV提供的函数<code>cv2,resize(src, dst, interpolation=CV_INTER_LINEAR)</code>可以实现这个功能，图像的尺寸可以自己手动设置，也可以指定缩放因子。我们可以选择使用不同的插值方法，在缩放时我们推荐使用cv2.INTER_ AREA，在扩展时我们推荐使用v2.INTER_ CUBIC（慢)和v2.INTER_ LINEAR。默认情况下所有改变图像尺寸大小的操作使用的插值方法都是cv2.INTER_LINEAR。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg=cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)<span class="hljs-comment"># 下面的None所占的参数位置本应该是输出图像的尺寸，但是因为后边我们设置了缩放因子(fx,fy),因此这里直接写None就好</span>res=cv2.resize(img,<span class="hljs-literal">None</span>,fx=<span class="hljs-number">2</span>,fy=<span class="hljs-number">2</span>,interpolation=cv2.INTER_CUBIC)<span class="hljs-comment"># 这里呢，我们直接设置输出图像的尺寸，所以不用设置缩放因子</span>height,width=img.shape[:<span class="hljs-number">2</span>]    <span class="hljs-comment"># 得到原图像的宽高</span>res=cv2.resize(img,(<span class="hljs-number">2</span>*width,<span class="hljs-number">2</span>*height),interpolation=cv2.INTER_CUBIC)    <span class="hljs-comment"># 对原图像放大两倍</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):    cv2.imshow(<span class="hljs-string">&#x27;res&#x27;</span>,res)    cv2.imshow(<span class="hljs-string">&#x27;img&#x27;</span>,img)    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:        <span class="hljs-keyword">break</span>cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE8f91d7ece88ed49729f06b3eddda03af" title="image.png" class="gallery-item"><img src="WEBRESOURCE8f91d7ece88ed49729f06b3eddda03af" alt="image.png"></a></p><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>&emsp;&emsp;如果要使图像要沿（x，y）方向移动，移动的距离是（tx，ty），你可以以下面的方式构建移动矩阵：<br><pre><code class="hljs math">M&#x3D;\left[\begin&#123;matrix&#125;1 &amp; 0 &amp; t_x \\[8pt]0 &amp; 1 &amp; t_y\end&#123;matrix&#125;\right]</code></pre><br>可以使用Numpy 数组构建这个矩阵（数据类型是np.float32），然后把它传给函数cv2.warpAffine()即可完成平移。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>对一个图像绕图片左下角原点旋转θ角, 需要使用到下面形式的旋转矩阵:<br><pre><code class="hljs math">M&#x3D;\left[\begin&#123;matrix&#125;\cos\theta &amp; -\sin\theta \\[8pt]\sin\theta &amp; \cos\theta\end&#123;matrix&#125;\right]</code></pre><br>OpenCV支持绕任意点进行旋转的矩阵：<br><pre><code class="hljs math">M&#x3D;\left[\begin&#123;matrix&#125;\alpha &amp; \beta &amp; (1-\alpha)\cdot center\cdot x-\beta\cdot center\cdot y \\[8pt]-\beta &amp; \alpha &amp; \beta\cdot center\cdot x+(1-\alpha)\cdot center\cdot x\end&#123;matrix&#125;\right]</code></pre><br>其中，<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs math">\alpha &#x3D; scale\cdot \cos\theta</p><p>\beta &#x3D; scale\cdot \sin\theta</code></pre>:hexoPostRenderEscape–&gt;</p><p>为了构建这个旋转矩阵，OpenCV 提供了函数：<code>cv2.getRotationMatrix2D()</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg=cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>,<span class="hljs-number">0</span>)rows,cols=img.shape    <span class="hljs-comment"># 得到图像的宽高</span><span class="hljs-comment"># (旋转中心，旋转角度，旋转后的缩放因子)</span>M=cv2.getRotationMatrix2D((cols/<span class="hljs-number">2</span>,rows/<span class="hljs-number">2</span>),<span class="hljs-number">45</span>,<span class="hljs-number">0.6</span>)    <span class="hljs-comment"># 旋转45度</span><span class="hljs-comment"># 对图像img施加仿射变换M，第三个参数是输出图像的尺寸中心</span>dst=cv2.warpAffine(img,M,(<span class="hljs-number">2</span>*cols,<span class="hljs-number">2</span>*rows))cv2.namedWindow(<span class="hljs-string">&#x27;image&#x27;</span>, cv2.WINDOW_NORMAL)<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):    cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>,dst)    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>)==<span class="hljs-number">27</span>:        <span class="hljs-keyword">break</span>cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEccd2f19140eb7c0cc5758e9c8127789d" title="image.png" class="gallery-item"><img src="WEBRESOURCEccd2f19140eb7c0cc5758e9c8127789d" alt="image.png"></a></p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>&emsp;&emsp;在仿射变换中，原图中所有的平行线在结果图像中同样平行(这是一种线性变换)。为了创建这个矩阵，我们需要从原图像中找到三个点以及他们在输出图像中的位置，然后利用<code>cv2.getAffineTransform()</code>创建一个2x3 的矩阵，最后这个矩阵会被传给函数<code>cv2.warpAffine()</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg=cv2.imread(<span class="hljs-string">&#x27;miss.jpg&#x27;</span>)rows,cols,channel=img.shape<span class="hljs-comment"># 选中原图像上的三个点</span>before_points=np.float32([[<span class="hljs-number">50</span>,<span class="hljs-number">50</span>],[<span class="hljs-number">200</span>,<span class="hljs-number">50</span>],[<span class="hljs-number">50</span>,<span class="hljs-number">200</span>]])<span class="hljs-comment"># 定义原图上那三个点在最终目标图片上的位置</span>after_points=np.float32([[<span class="hljs-number">10</span>,<span class="hljs-number">100</span>],[<span class="hljs-number">200</span>,<span class="hljs-number">50</span>],[<span class="hljs-number">100</span>,<span class="hljs-number">250</span>]])<span class="hljs-comment"># 基于before_points和after_points生成仿射变换矩阵</span>M=cv2.getAffineTransform(before_points,after_points)dst=cv2.warpAffine(img,M,(cols,rows))    <span class="hljs-comment"># 对图像img施加定义好了的仿射变换</span>cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEd03a91969a3a028c2d1e4b6b1784e6ac" title="image.png" class="gallery-item"><img src="WEBRESOURCEd03a91969a3a028c2d1e4b6b1784e6ac" alt="image.png"></a></p><p><a href="WEBRESOURCE618f5289a7f26d3e61233f3ec9f58b3d" title="image.png" class="gallery-item"><img src="WEBRESOURCE618f5289a7f26d3e61233f3ec9f58b3d" alt="image.png"></a></p><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>&emsp;&emsp;对于透视变换，我们需要一个 3x3 的变换矩阵。变换前后直线还是直线。<br><br>&emsp;&emsp;要构建这个变换矩阵，你需要在输入图像上找4个点，并指定它们在输出图像上对应的位置。这四个点中的任意三个都不能共线。这个变换矩阵可以用函数<code>cv2.getPerspectiveTransform()</code>构建。然后把这个矩阵传给函数<code>cv2.warpPerspective()</code>来对源图像进行透视变换。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg=cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>)rows,cols,ch=img.shapebefore_points = np.float32([[<span class="hljs-number">56</span>,<span class="hljs-number">65</span>],[<span class="hljs-number">368</span>,<span class="hljs-number">52</span>],[<span class="hljs-number">28</span>,<span class="hljs-number">387</span>],[<span class="hljs-number">389</span>,<span class="hljs-number">390</span>]])after_points = np.float32([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">300</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">300</span>],[<span class="hljs-number">300</span>,<span class="hljs-number">300</span>]])M=cv2.getPerspectiveTransform(before_points,after_points)dst=cv2.warpPerspective(img,M,(<span class="hljs-number">300</span>,<span class="hljs-number">300</span>))cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE961f93fa82ae6dc52577d56ed0217d0d" title="image.png" class="gallery-item"><img src="WEBRESOURCE961f93fa82ae6dc52577d56ed0217d0d" alt="image.png"></a></p><h1 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h1><h2 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h2><p>&emsp;&emsp;使用<code>cv2.threshhold()</code>进行简单阈值处理，像素值高于阈值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。因为这个函数接受的是灰度图，所以像素值其实就是图像的亮度。<br><br>&emsp;&emsp;这个函数的第一个参数就是原图像，<font color=#906060>原图像应该是灰度图(不是灰度图则转换为灰度图)</font>；第二个参数就是用来对像素值进行分类的阈值；第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值。</p><p>OpenCV提供了多种不同的阈值方法，这是由第四个参数来决定的。这些方法包括：</p><ul><li>cv2.THRESH_BINARY</li><li>cv2.THRESH_BINARY_INV</li><li>cv2.THRESH_TRUNC</li><li>cv2.THRESH_TOZERO</li><li>cv2.THRESH_TOZERO_INV</li></ul><p><a href="WEBRESOURCEc6d9383d0a0ca8cfcd1c04b02c6f83ff" title="image.png" class="gallery-item"><img src="WEBRESOURCEc6d9383d0a0ca8cfcd1c04b02c6f83ff" alt="image.png"></a></p><p><code>cv2.threshhold()</code>有两个返回值，第一个为retVal，第二个就是阈值化处理之后的结果图像。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg=cv2.imread(<span class="hljs-string">&#x27;gradient.png&#x27;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment"># 对源图像进行各种类型的阈值化处理</span>ret,thresh1=cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY)    <span class="hljs-comment"># 高于127时赋值为255(白色)，低于127时赋值为0(黑色)</span>ret,thresh2=cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY_INV)ret,thresh3=cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_TRUNC)ret,thresh4=cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_TOZERO)ret,thresh5=cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_TOZERO_INV)titles = [<span class="hljs-string">&#x27;Original Image&#x27;</span>,<span class="hljs-string">&#x27;BINARY&#x27;</span>,<span class="hljs-string">&#x27;BINARY_INV&#x27;</span>,<span class="hljs-string">&#x27;TRUNC&#x27;</span>,<span class="hljs-string">&#x27;TOZERO&#x27;</span>,<span class="hljs-string">&#x27;TOZERO_INV&#x27;</span>]images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):    plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,i+<span class="hljs-number">1</span>),plt.imshow(images[i],<span class="hljs-string">&#x27;gray&#x27;</span>)    plt.title(titles[i])    plt.xticks([]),plt.yticks([])    <span class="hljs-comment"># 隐藏子图的刻度</span>plt.show()</code></pre><p><a href="WEBRESOURCEacd847f77772f568707c528caf2ee05d" title="image.png" class="gallery-item"><img src="WEBRESOURCEacd847f77772f568707c528caf2ee05d" alt="image.png"></a></p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>&emsp;&emsp;前面所说的简单阈值其实是全局阈值，即整幅图像采用同一个数作为阈值。但这种方法显然并不适合于所有情况，尤其是当同一幅图像上的不同部分具有不同亮度时。这种情况下我们就需要采用自适应阈值。<br><br>&emsp;&emsp;此时的阈值是根据图像上的每一个小区域计算与其对应的阈值。因此在同一幅图像上的不同区域采用的实际上是不同的阈值，从而使我们能在图像各部分亮度差异很大的情况下得到更好的结果。</p><p>下面的程序展示了简单阈值和自适应阈值的区别：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt</p><p>img = cv2.imread(<span class="hljs-string">&#x27;dave.png&#x27;</span>,<span class="hljs-number">0</span>)</p><p><span class="hljs-comment"># 中值滤波(除噪点)</span><br>img = cv2.medianBlur(img,<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 这里是简单阈值</span><br>ret,th1 = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY)</p><p><span class="hljs-comment"># 使用cv2.adaptiveThreshold()开启自适应阈值，分别使用两种计算阈值的方法：</span><br><span class="hljs-comment"># ADAPTIVE_THRESH_MEAN_C阈值取自相邻区域的平均值 和 </span><br><span class="hljs-comment"># ADAPTIVE_THRESH_GAUSSIAN_C阈值取值相邻区域的加权和，权重为一个高斯窗口</span><br>th2 = cv2.adaptiveThreshold(img,<span class="hljs-number">255</span>,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>)<br>th3 = cv2.adaptiveThreshold(img,<span class="hljs-number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 11 为邻域大小Block size(用来计算阈值的区域大小), 2 为C 值(一个常数，阈值就等于的平均值或者加权平均值减去这个常数)</span></p><p>titles = [<span class="hljs-string">&#x27;Original Image&#x27;</span>, <span class="hljs-string">&#x27;Global Thresholding (v = 127)&#x27;</span>, <span class="hljs-string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="hljs-string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]<br>images = [img, th1, th2, th3]</p><p><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,i+<span class="hljs-number">1</span>),plt.imshow(images[i],<span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i])<br>    plt.xticks([]),plt.yticks([])<br>plt.show()</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE6f6d04f3d8979190b2cb172fb60e9a6c" title="image.png" class="gallery-item"><img src="WEBRESOURCE6f6d04f3d8979190b2cb172fb60e9a6c" alt="image.png"></a></p><h2 id="Otsu’s-二值化"><a href="#Otsu’s-二值化" class="headerlink" title="Otsu’s 二值化"></a>Otsu’s 二值化</h2><p>&emsp;&emsp;前面提到的<code>cv2.threshold()</code>的第一个返回值retVal，当我们使用 Otsu’s 二值化时就会用到它。</p><p>&emsp;&emsp;在使用全局(简单)阈值时，我们就是随便给了一个数来做阈值，那我们怎么知道我们选取的这个数的好坏呢？答案就是不停的尝试。如果是一副双峰图像（双峰图像是指图像直方图中存在两个峰）呢？我们岂不是应该在两个峰之间的峰谷选一个值作为阈值？这就是Otsu’s二值化要做的。简单来说就是对一副双峰图像自动根据其直方图计算出一个阈值。（对于非双峰图像，这种方法得到的结果可能会不理想）。</p><p>&emsp;&emsp;进行Otsu’s 二值化处理用到的函数还是<code>cv2.threshold()</code>，但是需要多传入一个参数(flag) cv2.THRESH_OTSU。这时要把阈值设为0。然后算法会自动找到最优阈值，这个最优阈值就是返回值retVal。如果不使用Otsu’s二值化即不传入后面的那个参数，<code>cv2.threshold()</code>返回的retVal值与设定的阈值相等。</p><p>&emsp;&emsp;下面的例子中，输入图像是一副带有噪声的图像。我们将使用几种方法来对其进行阈值处理，第一种方法，我们设127为全局阈值。第二种方法，直接使用Otsu二值化。第三种方法，我们首先使用一个5x5 的高斯过滤除去噪音，然后再使用Otsu二值化。这里可以看看噪音去除后对结果的影响有多大。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;fingerprint.jpg&#x27;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment"># 使用全局阈值</span>ret1,th1 = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY)<span class="hljs-comment"># 直接使用Otsu&#x27;s二值化</span>ret2,th2 = cv2.threshold(img,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)<span class="hljs-comment"># 高斯滤波之后再使用Otsu&#x27;s二值化,（5,5）为高斯核的大小，0 为标准差</span>blur = cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)ret3,th3 = cv2.threshold(blur,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)    <span class="hljs-comment"># 这里threshold()的阈值一定要设为0</span><span class="hljs-comment"># 下面画出这三种阈值处理后的目标图像和它们的直方图</span>images = [img, <span class="hljs-number">0</span>, th1,img, <span class="hljs-number">0</span>, th2,blur, <span class="hljs-number">0</span>, th3]titles = [<span class="hljs-string">&#x27;Original Noisy Image&#x27;</span>,<span class="hljs-string">&#x27;Histogram&#x27;</span>,<span class="hljs-string">&#x27;Global Thresholding (v=127)&#x27;</span>,<span class="hljs-string">&#x27;Original Noisy Image&#x27;</span>,<span class="hljs-string">&#x27;Histogram&#x27;</span>,<span class="hljs-string">&quot;Otsu&#x27;s Thresholding&quot;</span>,<span class="hljs-string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="hljs-string">&#x27;Histogram&#x27;</span>,<span class="hljs-string">&quot;Otsu&#x27;s Thresholding&quot;</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):    plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>),plt.imshow(images[i*<span class="hljs-number">3</span>],<span class="hljs-string">&#x27;gray&#x27;</span>)    plt.title(titles[i*<span class="hljs-number">3</span>]), plt.xticks([]), plt.yticks([])    plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>),plt.hist(images[i*<span class="hljs-number">3</span>].ravel(),<span class="hljs-number">256</span>)    <span class="hljs-comment"># 使用plt.hist(参数为一维数组)画直方图，使用array.ravel()将多维数组转换为一维</span>    plt.title(titles[i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>]), plt.xticks([]), plt.yticks([])    plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,i*<span class="hljs-number">3</span>+<span class="hljs-number">3</span>),plt.imshow(images[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>],<span class="hljs-string">&#x27;gray&#x27;</span>)    plt.title(titles[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>]), plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><a href="WEBRESOURCE55605a5458afbd85a2d688328a02f24e" title="image.png" class="gallery-item"><img src="WEBRESOURCE55605a5458afbd85a2d688328a02f24e" alt="image.png"></a></p><h2 id="Otsu’s-二值化的工作原理"><a href="#Otsu’s-二值化的工作原理" class="headerlink" title="Otsu’s 二值化的工作原理"></a>Otsu’s 二值化的工作原理</h2><p>&emsp;&emsp;因为是双峰图，Otsu 算法就是要找到一个阈值（t）, 使得同一类加权方<br>差最小，需要满足下列关系式：</p><pre><code class="hljs math">\sigma^2_w(t) &#x3D; q_1(t)\sigma^2_1(t) + q_2(t)\sigma^2_2(t)</code></pre><p>其中，<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs math">q_1(t) &#x3D; \sum_&#123;i&#x3D;1&#125;^t P(i)\hspace&#123;2em&#125;\&amp;\hspace&#123;2em&#125; q_1(t) &#x3D; \sum_&#123;i&#x3D;t+1&#125;^I P(i)</p><p>\mu_1(t) &#x3D; \sum_&#123;i&#x3D;1&#125;^t &#x3D; \frac&#123;i P(i)&#125;&#123;q_1(t)&#125;\hspace&#123;2em&#125; \&amp; \hspace&#123;2em&#125;\mu_2(t) &#x3D; \sum_&#123;i&#x3D;t+1&#125;^I \frac&#123;iP(i)&#125;&#123;q_2(t)&#125;</p><p>\sigma_1^2(t) &#x3D; \sum_&#123;i&#x3D;1&#125;^t\left[i-\mu_1(t)\right]^2 \frac&#123;P(i)&#125;&#123;q_1(t)&#125;\hspace&#123;2em&#125; \&amp; \hspace&#123;2em&#125;\sigma_2^2(t) &#x3D; \sum_&#123;i&#x3D;t+1&#125;^I\left[i-\mu_1(t)\right]^2 \frac&#123;iP(i)&#125;&#123;q_2(t)&#125;</code></pre>:hexoPostRenderEscape–&gt;<br>其实就是在两个峰之间找到一个阈值t，将这两个峰分开，并且使每一个峰内的方差最小。</p><h1 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h1><h2 id="2D卷积"><a href="#2D卷积" class="headerlink" title="2D卷积"></a>2D卷积</h2><p>&emsp;&emsp;与数字信号一样，我们也可以对2D图像实施加低通滤波（LPF），高通滤波（HPF）等。LPF 帮助我们去除噪音，模糊图像。HPF帮助我们找到图像的边缘。OpenCV提供的函数<code>cv.filter2D()</code>可以让我们对一幅图像进行卷积操作。</p><p>下面我们将对一幅图像使用平均滤波器，一个5x5 的平均滤波器核如下：<br><pre><code class="hljs math">K&#x3D;\frac1&#123;25&#125;\left[\begin&#123;matrix&#125;1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\end&#123;matrix&#125;\right]</code></pre></p><p>&emsp;&emsp;操作过程大致是这样的：将核放在图像的一个像素A 上，求与核对应的图像上25（5x5）个像素的和，再取平均数，用这个平均数替代像素A的值。重复以上操作直到将图像的每一个像素值都更新一边。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;opencv-logo.png&#x27;</span>)kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.float32)/<span class="hljs-number">25</span><span class="hljs-comment">#cv.Filter2D(src, dst, kernel, anchor=(-1, -1))</span><span class="hljs-comment">#ddepth =&gt; desired depth of the destination image，期望的目标图像的深度</span>dst = cv2.filter2D(img,<span class="hljs-number">-1</span>,kernel)    <span class="hljs-comment"># 当ddepth=-1时，则输出的目标图像与源图像有相同的深度</span>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img),plt.title(<span class="hljs-string">&#x27;Original&#x27;</span>)plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">122</span>),plt.imshow(dst),plt.title(<span class="hljs-string">&#x27;Averaging&#x27;</span>)plt.xticks([]), plt.yticks([])plt.show()</code></pre><p>以下src.depth()和ddepth的组合是可以使用的:</p><ul><li>src.depth() = CV_8U, ddepth = -1 | CV_16S | CV_32F | CV_64F</li><li>src.depth() = CV_16U | CV_16S, ddepth = -1 | CV_32F | CV_64F</li><li>src.depth() = CV_32F, ddepth = -1 | CV_32F | CV_64F</li><li>src.depth() = CV_64F, ddepth = -1 | CV_64F</li></ul><p><a href="WEBRESOURCEbe839a5dd3c13d2a0de23d2a6e03f88c" title="image.png" class="gallery-item"><img src="WEBRESOURCEbe839a5dd3c13d2a0de23d2a6e03f88c" alt="image.png"></a></p><h2 id="图像模糊"><a href="#图像模糊" class="headerlink" title="图像模糊"></a>图像模糊</h2><p>&emsp;&emsp;使用低通滤波器可以达到图像模糊的目的，这对于去除噪音很有帮助。这个处理其实就是去除图像中的高频成分（比如：噪音，边界），所以边界也会被模糊一点。。OpenCV提供了四种模糊技术。</p><h3 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h3><p>&emsp;&emsp;这是由一个归一化卷积框完成的，它通过用卷积框覆盖区域内所有像素的平均值来代替中心元素。可以使用函数<code>cv2.blur()</code>和<code>cv2.boxFilter()</code>来完这个任务。我们需要设定卷积框的宽和高。</p><p>下面是一个3x3 的归一化卷积框：<br><pre><code class="hljs math">K&#x3D;\frac1&#123;9&#125;\left[\begin&#123;matrix&#125;1 &amp; 1 &amp; 1 \\[6pt]1 &amp; 1 &amp; 1 \\[6pt]1 &amp; 1 &amp; 1\end&#123;matrix&#125;\right]</code></pre><br>下面这个例子只是在上面例子做了一下更改：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt</p><p>img = cv2.imread(<span class="hljs-string">&#x27;opencv-logo.png&#x27;</span>)<br><span class="hljs-comment"># 使用归一化卷积来模糊图像</span><br>blur = cv2.blur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))</p><p>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img),plt.title(<span class="hljs-string">&#x27;Original&#x27;</span>)<br>plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>),plt.imshow(blur),plt.title(<span class="hljs-string">&#x27;Blurred&#x27;</span>)<br>plt.xticks([]), plt.yticks([])<br>plt.show()</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE2716c0090e4386f150d10e2022219a8b" title="image.png" class="gallery-item"><img src="WEBRESOURCE2716c0090e4386f150d10e2022219a8b" alt="image.png"></a></p><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>&emsp;&emsp;现在把卷积核换成高斯核（简单来说就是，方框不变，原来每个方框的值是相等的，现在里面的值是符合高斯分布的，方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包。原来是求平均数现在变成求加权平均数）。<br><br>&emsp;&emsp;实现的函数是<code>cv2.GaussianBlur()</code>。我们需要指定高斯核的宽和高（必须是奇数）以及高斯函数沿X，Y 方向的标准差。如果我们只指定了X方向的的标准差，Y方向也会取相同值。如果两个标准差都是0，那么函数会根据核函数的大小自己计算。<br><br>&emsp;&emsp;高斯滤波可以有效的从图像中去除高斯噪音。如果需要的话，你也可以使用函数<code>cv2.getGaussianKernel()</code>自己构建一个高斯核。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;opencv-logo.png&#x27;</span>)<span class="hljs-comment"># 参数0 表示要根据窗口大小（5,5）来计算高斯函数标准差</span>blur = cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img),plt.title(<span class="hljs-string">&#x27;Original&#x27;</span>)plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">122</span>),plt.imshow(blur),plt.title(<span class="hljs-string">&#x27;Blurred&#x27;</span>)plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><a href="WEBRESOURCE1ac953b844d259ba7c2dcf2c004bbbea" title="image.png" class="gallery-item"><img src="WEBRESOURCE1ac953b844d259ba7c2dcf2c004bbbea" alt="image.png"></a></p><h3 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h3><p>&emsp;&emsp;所谓中值模糊，就是用与卷积框对应像素的中值来替代中心像素的值。这个滤波器经常用来去除椒盐噪声。前面的滤波器都是用计算得到的一个新值来取代中心像素的值，而中值滤波是用中心像素周围的值来取代它。它能有效的去除噪声。卷积核的大小也应该是一个奇数。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;opencv-logo.png&#x27;</span>)median = cv2.medianBlur(img,<span class="hljs-number">5</span>)plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img),plt.title(<span class="hljs-string">&#x27;Original&#x27;</span>)plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">122</span>),plt.imshow(blur),plt.title(<span class="hljs-string">&#x27;Blurred&#x27;</span>)plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><a href="WEBRESOURCEe17bb2a5a343fca2cc43a6391c9c080d" title="image.png" class="gallery-item"><img src="WEBRESOURCEe17bb2a5a343fca2cc43a6391c9c080d" alt="image.png"></a></p><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>&emsp;&emsp;函数<code>cv2.bilateralFilter()</code>能在保持边界清晰的情况下有效的去除噪音，但是这种操作与其他滤波器相比会比较慢。<br><br>&emsp;&emsp;我们已经知道高斯滤波器是求中心点邻近区域像素的高斯加权平均值，这种高斯滤波器只考虑了像素之间的空间关系(像素分布)，而没有考虑像素值之间的关系（像素的相似度），所以这种方法并不会考虑一个像素是否位于边界，因此边界也会被模糊掉，而这不是我们想要的。<br><br>&emsp;&emsp;双边滤波同时使用了空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以这种方法会确保边界不会被模糊掉，因为边界处的灰度值变化会比较大。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;wood.jpg&#x27;</span>)<span class="hljs-comment"># cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)</span><span class="hljs-comment">#d =&gt; 过滤过程中使用的每个像素邻域的直径。</span><span class="hljs-comment"># 参数9表示邻域直径，两个75 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差</span>blur = cv2.bilateralFilter(img,<span class="hljs-number">9</span>,<span class="hljs-number">75</span>,<span class="hljs-number">75</span>)plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img),plt.title(<span class="hljs-string">&#x27;Original&#x27;</span>)plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">122</span>),plt.imshow(blur),plt.title(<span class="hljs-string">&#x27;Blurred&#x27;</span>)plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><a href="WEBRESOURCE2ac226620840df1928d8149e7354d22a" title="image.png" class="gallery-item"><img src="WEBRESOURCE2ac226620840df1928d8149e7354d22a" alt="image.png"></a></p><p>可见，双边滤波不会模糊边界。</p><h1 id="形态学转换"><a href="#形态学转换" class="headerlink" title="形态学转换"></a>形态学转换</h1><p>&emsp;&emsp;形态学操作是指根据图像形状进行的简单操作。一般情况下，对二值化图像进行的操作需要输入两个参数，一个是原始图像，第二个被称为结构化元素或核，它是用来决定操作的性质的。两个基本的形态学操作是<strong>腐蚀</strong>和<strong>膨胀</strong>。他们的变体则构成了<strong>开运算</strong>，<strong>闭运算</strong>，<strong>梯度</strong>等。</p><h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><p>&emsp;&emsp;就像土壤侵蚀一样，这个操作会把前景物体的边界腐蚀掉（但是前景仍然是白色）。那这是怎么做到的呢？卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是1，那么中心元素就保持原来的像素值，否则就变为零。这会产生什么影响呢？根据卷积核的大小，靠近前景的所有像素都会被腐蚀掉（变为0），所以前景物体会变小，整幅图像的白色区域会减少。这对于去除白色噪声很有用，也可以用来断开两个连在一块的物体等。</p><p>这里我们有一个例子，使用一个5x5 的卷积核。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>,<span class="hljs-number">0</span>)cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)<span class="hljs-comment"># 构建5*5的卷积核</span>kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint8)<span class="hljs-comment"># 腐蚀操作</span>erosion = cv2.erode(img,kernel,iterations = <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, erosion)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEa777be42c754dd331e6d0581bbc70860" title="image.png" class="gallery-item"><img src="WEBRESOURCEa777be42c754dd331e6d0581bbc70860" alt="image.png"></a></p><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>&emsp;&emsp;与腐蚀相反，与卷积核对应的原图像的像素值中只要有一个是1，中心元素的像素值就是1。所以这个操作会增加图像中的白色区域（前景）。<br><br>&emsp;&emsp;一般在去噪声时先用腐蚀再用膨胀。因为腐蚀在去掉白噪声的同时，也会使前景对象变小。所以我们再对它进行膨胀。这时噪声已经被去除了，不会再回来了，但是前景还在增加。膨胀也可以用来连接两个分开的物体。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;j.png&#x27;</span>,<span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">&#x27;src&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)<span class="hljs-comment"># 构建5*5的卷积核</span>kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint8)<span class="hljs-comment"># 膨胀操作</span>dilation = cv2.dilate(img,kernel,iterations = <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, dilation)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEed0707358428dcc496e018959fa39ace" title="image.png" class="gallery-item"><img src="WEBRESOURCEed0707358428dcc496e018959fa39ace" alt="image.png"></a></p><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p>&emsp;&emsp;先进行腐蚀再进行膨胀就叫做开运算。，它被用来去除噪声。这里我们用到的函数是<code>cv2.morphologyEx()</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;j_noise.png&#x27;</span>,<span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">&#x27;src&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)<span class="hljs-comment"># 构建5*5的卷积核</span>kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint8)<span class="hljs-comment"># 开运算</span>opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, opening)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE762aa11b1c2d969d23defba15d5d8b31" title="image.png" class="gallery-item"><img src="WEBRESOURCE762aa11b1c2d969d23defba15d5d8b31" alt="image.png"></a></p><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p>闭运算其实就是先膨胀再腐蚀。它经常被用来填充前景物体中的小洞，或者前景物体上的小黑点。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;j_noise2.png&#x27;</span>,<span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">&#x27;src&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)<span class="hljs-comment"># 构建5*5的卷积核</span>kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint8)<span class="hljs-comment"># 闭运算</span>closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, closing)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEd9b007e8e78b5cb572a76841b76a08fe" title="image.png" class="gallery-item"><img src="WEBRESOURCEd9b007e8e78b5cb572a76841b76a08fe" alt="image.png"></a></p><h2 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h2><p>所谓形态学梯度，其实就是一幅图像膨胀之后与腐蚀之后的差别。结果看上去就像前景物体的轮廓。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;j.png&#x27;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment"># 构建5*5的卷积核</span>kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint8)<span class="hljs-comment"># 形态学梯度</span>gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, gradient)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEf602f3a3dc9c819e58138b36c1b4cbfa" title="image.png" class="gallery-item"><img src="WEBRESOURCEf602f3a3dc9c819e58138b36c1b4cbfa" alt="image.png"></a></p><h2 id="礼帽"><a href="#礼帽" class="headerlink" title="礼帽"></a>礼帽</h2><p>原始图像与进行开运算之后得到的图像的差。</p><p>下面的例子是用一个9x9 的核进行礼帽操作的结果：<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img = cv2.imread(<span class="hljs-string">&#x27;j.png&#x27;</span>,<span class="hljs-number">0</span>)</p><p>cv2.namedWindow(<span class="hljs-string">&#x27;src&#x27;</span>, cv2.WINDOW_NORMAL)<br>cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)</p><p>cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)</p><p><span class="hljs-comment"># 构建9*9的卷积核</span><br>kernel = np.ones((<span class="hljs-number">9</span>,<span class="hljs-number">9</span>),np.uint8)<br><span class="hljs-comment"># 礼帽操作</span><br>tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</p><p>cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, tophat)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE6b99891b1be3f86951761e825a72d774" title="image.png" class="gallery-item"><img src="WEBRESOURCE6b99891b1be3f86951761e825a72d774" alt="image.png"></a></p><h2 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h2><p>进行闭运算之后得到的图像与原始图像的差。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;j.png&#x27;</span>,<span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">&#x27;src&#x27;</span>, cv2.WINDOW_NORMAL)cv2.namedWindow(<span class="hljs-string">&#x27;dst&#x27;</span>, cv2.WINDOW_NORMAL)cv2.imshow(<span class="hljs-string">&#x27;src&#x27;</span>, img)<span class="hljs-comment"># 构建9*9的卷积核</span>kernel = np.ones((<span class="hljs-number">9</span>,<span class="hljs-number">9</span>),np.uint8)<span class="hljs-comment"># 黑帽操作</span>blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)cv2.imshow(<span class="hljs-string">&#x27;dst&#x27;</span>, blackhat)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCEdc9279e9e27cd4ab249d247a0b31864c" title="image.png" class="gallery-item"><img src="WEBRESOURCEdc9279e9e27cd4ab249d247a0b31864c" alt="image.png"></a></p><h2 id="形态学操作之间的关系"><a href="#形态学操作之间的关系" class="headerlink" title="形态学操作之间的关系"></a>形态学操作之间的关系</h2><p><a href="WEBRESOURCEe3adb9726a76595465e2f9e31cab6fd4" title="image.png" class="gallery-item"><img src="WEBRESOURCEe3adb9726a76595465e2f9e31cab6fd4" alt="image.png"></a></p><h2 id="更多种类的结构化元素"><a href="#更多种类的结构化元素" class="headerlink" title="更多种类的结构化元素"></a>更多种类的结构化元素</h2><p>&emsp;&emsp;在前面的例子中，我们使用的都是Numpy 构建的结构化元素(核(，它是正方形的，但<br>有时我们需要构建一个椭圆形/圆形的核。为了实现这种要求，OpenCV提供了函数<code>cv2.getStructuringElement()</code>。你只需要告诉他你需要的核的形状和大小它会自动帮你生成特定形状的核。</p><pre><code class="hljs lsl"># Rectangular Kernel，正方形核&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_RECT,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]], dtype=uint8)# Elliptical Kernel，椭圆形核&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], dtype=uint8)# Cross-shaped Kernel,十字形核&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_CROSS,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], dtype=uint8)</code></pre><p><a href="WEBRESOURCE65e3b15ad1b26e9f29d63db0adb2726a" title="image.png" class="gallery-item"><img src="WEBRESOURCE65e3b15ad1b26e9f29d63db0adb2726a" alt="image.png"></a></p><h1 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h1><p>&emsp;&emsp;所谓图像梯度，简单来说，就是求导。OpenCV提供了三种不同的梯度滤波器，或者说是高通滤波器：Sobel，Scharr 和Laplacian。<br><br>&emsp;&emsp;Sobel，Scharr 其实就是求一阶或二阶导数，Scharr 是对Sobel（使用小的卷积核求解梯度角度时）的优化。Laplacian 则是求二阶导数。</p><h2 id="Sobel-算子和Scharr-算子"><a href="#Sobel-算子和Scharr-算子" class="headerlink" title="Sobel 算子和Scharr 算子"></a>Sobel 算子和Scharr 算子</h2><p>&emsp;&emsp;Sobel 算子是高斯平滑与微分操作的结合体，所以它的抗噪声能力很好。你可以设定求导的方向（xorder 或yorder）。还可以设定使用的卷积核的大小（ksize）。如果ksize=-1，可以使用3x3 的Scharr 滤波器，它的的效果要比3x3 的Sobel 滤波器好（而且速度相同，所以在使用3x3 滤波器时应该尽量使用Scharr 滤波器）。</p><p>3x3 的Scharr 滤波器卷积核如下：</p><p><a href="WEBRESOURCEb5f3da01120ff85e176c0f1ecd1e0255" title="image.png" class="gallery-item"><img src="WEBRESOURCEb5f3da01120ff85e176c0f1ecd1e0255" alt="image.png"></a></p><h2 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a>Laplacian 算子</h2><p>&emsp;&emsp;拉普拉斯算子可以使用二阶导数的形式定义，可假设其离散实现类似于二阶Sobel 导数，事实上，OpenCV 在计算拉普拉斯算子时直接调用的Sobel 算子。</p><p>其计算公式如下：</p><pre><code class="hljs math">\Delta src &#x3D; \frac&#123;\partial^2 src&#125;&#123;\partial x^2&#125; + \frac&#123;\partial^2 src&#125;&#123;\partial y^2&#125;</code></pre><p>拉普拉斯滤波器使用的卷积核：<br><pre><code class="hljs math">kernel &#x3D; \left[\begin&#123;matrix&#125;0 &amp; 1 &amp; 0 \\[6pt]1 &amp; -4 &amp; 1 \\[6pt]0 &amp; 1 &amp; 0\end&#123;matrix&#125;\right]</code></pre><br><a href="WEBRESOURCE3e12c2e35fea1c1173036424265563e5" title="image.png" class="gallery-item"><img src="WEBRESOURCE3e12c2e35fea1c1173036424265563e5" alt="image.png"></a></p><p>&emsp;&emsp;上面反复提到过，我们可以通过设置输出类型为-1来让输出图像的深度（数据类型）与原图像保持一致，但可以看到，我们在代码中使用的并不是-1，而是cv2.CV_64F。这是为什么呢？<br><br>&emsp;&emsp;这里可以想象一下一个从黑到白的边界的导数是整数，而一个从白到黑的边界点导数却是负数。如果原图像的深度是np.int8，那么所有的负值都会被截断变成0，换句话说就是会把边界信息丢失掉。<br><br>&emsp;&emsp;所以如果这两种边界都想检测到，最好的的办法就是将输出的数据类型设置的更高，比如cv2.CV_16S，cv2.CV_64F 等，再取绝对值将它转回到cv2.CV_8U类型。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;boxs.png&#x27;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment"># 输出类型设为cv2.CV_8U</span>sobelx8u = cv2.Sobel(img,cv2.CV_8U,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,ksize=<span class="hljs-number">5</span>)<span class="hljs-comment"># 输出类型设为cv2.CV_64F，然后取其绝对值转换为cv2.CV_8U类型</span>sobelx64f = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,ksize=<span class="hljs-number">5</span>)abs_sobel64f = np.absolute(sobelx64f)sobel_8u = np.uint8(abs_sobel64f)plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>),plt.imshow(img,cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Original&#x27;</span>), plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),plt.imshow(sobelx8u,cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Sobel CV_8U&#x27;</span>), plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),plt.imshow(sobel_8u,cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Sobel abs(CV_64F)&#x27;</span>), plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><a href="WEBRESOURCE8723a5158f88e0a611d4ac68ee1b77cb" title="image.png" class="gallery-item"><img src="WEBRESOURCE8723a5158f88e0a611d4ac68ee1b77cb" alt="image.png"></a></p><h1 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h1><p>&emsp;&emsp;Canny 边缘检测是一种非常流行的边缘检测算法，是John F.Canny 在1986 年提出的，它是一个由很多步组成的算法。</p><h2 id="去噪"><a href="#去噪" class="headerlink" title="去噪"></a>去噪</h2><p>由于边缘检测很容易受到噪声影响，所以第一步是使用5x5 的高斯滤波器去除噪声。</p><h2 id="计算图像梯度"><a href="#计算图像梯度" class="headerlink" title="计算图像梯度"></a>计算图像梯度</h2><p>&emsp;&emsp;对平滑后的图像使用Sobel 算子计算水平方向和竖直方向的一阶导数（图像梯度，Gx 和Gy）。根据得到的这两幅梯度图（Gx 和Gy）找到边界的梯度和方向，公式如下：</p><pre><code class="hljs math">Edge\_Gradient(G) &#x3D; \sqrt&#123;G_x^2 + G_y^2&#125;Angle(\theta) &#x3D; tan^&#123;-1&#125;\left(\frac&#123;G_x&#125;&#123;G_y&#125;\right)</code></pre><p>梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线。</p><h2 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h2><p>&emsp;&emsp;在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</p><p>如下图所示:</p><p><a href="WEBRESOURCEe338c845d3af82ca5445866da8146d5c" title="image.png" class="gallery-item"><img src="WEBRESOURCEe338c845d3af82ca5445866da8146d5c" alt="image.png"></a></p><h2 id="滞后阈值"><a href="#滞后阈值" class="headerlink" title="滞后阈值"></a>滞后阈值</h2><p>&emsp;&emsp;现在要确定的是哪些边界才是真正的边界。这时我们需要设置两个阈值：minVal 和maxVal。当图像的灰度梯度高于maxVal 时被认为是真的边界，那些低于minVal 的开始被认为是边界的像素会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p><p>如下图：</p><p><a href="WEBRESOURCEce4c16d944af5656a97c6e9bc01397ad" title="image.png" class="gallery-item"><img src="WEBRESOURCEce4c16d944af5656a97c6e9bc01397ad" alt="image.png"></a></p><p>&emsp;&emsp;我们分析一下上图，A 高于阈值maxVal ，所以是真正的边界点，C 虽然低于maxVal 但高于minVal 并且与A 相连，所以也被认为是真正的边界点。而B 就会被抛弃，因为它不仅低于maxVal 而且不与真正的边界点相连。<br><br>&emsp;&emsp;可见，选择合适的maxVal和minVal对于能否得到好的结果非常重要。在这一步，一些小的噪声点也会被除去，因为我们假设边界都是一些长的线段。</p><h1 id="OpenCV-中的Canny-边界检测"><a href="#OpenCV-中的Canny-边界检测" class="headerlink" title="OpenCV 中的Canny 边界检测"></a>OpenCV 中的Canny 边界检测</h1><p>&emsp;&emsp;实际上，在OpenCV中使用Canny算法进行边缘检测没有我们想的那么复杂，OpenCV对这几步操作进行了封装，只需要使用一个函数：<code>cv2.Canny()</code>，就可以完成以上几步。<br><br>&emsp;&emsp;这个函数的第一个参数是输入图像。第二和第三个分别是minVal和maxVal。第四个参数设置用来计算图像梯度的Sobel卷积核的大小，默认值为3。最后一个参数是L2gradient，它可以用来设定求梯度大小的方程。如果设为True，就会使用我们上面提到过的方程，否则将使用<code>$Edge\_Gradient(G) = |G_x^2| + |G_y^2|$</code>作为代替，默认值为False。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment"># cv2.Canny(src, minVal, maxVal)</span>edges = cv2.Canny(img,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>)plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img,cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Original Image&#x27;</span>), plt.xticks([]), plt.yticks([])plt.subplot(<span class="hljs-number">122</span>),plt.imshow(edges,cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)plt.title(<span class="hljs-string">&#x27;Edge Image&#x27;</span>), plt.xticks([]), plt.yticks([])plt.show()</code></pre><p><a href="WEBRESOURCE50bc7b9133bc87e6fbc18cfcc74f4ac7" title="image.png" class="gallery-item"><img src="WEBRESOURCE50bc7b9133bc87e6fbc18cfcc74f4ac7" alt="image.png"></a></p><h1 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h1><p>&emsp;&emsp;一般情况下，我们要处理是一副具有固定分辨率的图像。但是有些情况下，我们需要对同一图像的不同分辨率的子图像进行处理。比如，我们要在一幅图像中查找某个目标，比如脸，我们不知道目标在图像中的尺寸大小。<br><br>&emsp;&emsp;这种情况下，我们需要创建一组图像，这些图像是具有不同分辨率的原始图像。我们把这组图像叫做图像金字塔（简单来说就是同一图像的不同分辨率的子图集合）。如果我们把最大的图像放在底部，最小的放在顶部，看起来像一座金字塔，图像金字塔因而得名。<br><br>&emsp;&emsp;有两类图像金字塔：<strong>高斯金字塔</strong>和<strong>拉普拉斯金字塔</strong>。高斯金字塔的顶部是通过将底部图像中的连续的行和列去除得到的。顶部图像中的每个像素值等于下一层图像中5 个像素的高斯加权平均值。这样，操作一次一个M <em> N 的图像就变成了一个M/2 </em> N/2的图像。所以这幅图像的面积就变为原来图像面积的四分之一。<br><br>&emsp;&emsp;连续进行这样的操作我们就会得到一个分辨率不断下降的图像金字塔。我们可以使用函数<code>cv2.pyrDown()</code>和<code>cv2.pyrUp()</code>来构建图像金字塔。</p><p>&emsp;&emsp;函数<code>cv2.pyrDown()</code>从一个高分辨率大尺寸的图像向上构建一个金子塔（尺寸变小，分辨率降低）。</p><p>&emsp;&emsp;函数<code>cv2.pyrUp()</code>则从一个低分辨率小尺寸的图像向下构建一个金子塔（尺寸变大，但分辨率不会增加）。</p><h1 id="OpenCV中的轮廓"><a href="#OpenCV中的轮廓" class="headerlink" title="OpenCV中的轮廓"></a>OpenCV中的轮廓</h1><h2 id="什么是轮廓"><a href="#什么是轮廓" class="headerlink" title="什么是轮廓"></a>什么是轮廓</h2><p>&emsp;&emsp;轮廓可以简单认为是将连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。</p><ul><li>为了更加准确，要使用二值化图像。在寻找轮廓之前，要进行阈值化处理或者Canny 边界检测。</li><li>查找轮廓的函数会修改原始图像。如果你在找到轮廓之后还想使用原始图像的话，你应该将原始图像存储到其他变量中。</li><li>在OpenCV 中，查找轮廓就像在黑色背景中超白色物体。你应该记住，要找的物体应该是白色而背景应该是黑色。</li></ul><p>让我们看看如何在OpenCV中使用<code>cv2.findContours()</code>在一个二值图像中查找轮廓：</p><p>&emsp;&emsp;该函数有三个参数，第一个是输入图像，第二个是轮廓检索模式，第三个是轮廓近似方法。返回值有三个，第一个是图像，第二个是轮廓，第三个是（轮廓的）层析结构。轮廓（第二个返回值）是一个Python列表，其中存储着图像中的所有轮廓。每一个轮廓都是一个Numpy 数组，包含对象边界点（x，y）的坐标。</p><h2 id="怎样绘制轮廓"><a href="#怎样绘制轮廓" class="headerlink" title="怎样绘制轮廓"></a>怎样绘制轮廓</h2><p>&emsp;&emsp;函数<code>cv2.drawContours()</code>可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。它的第一个参数是原始图像，第二个参数是轮廓，一个Python列表。第三个参数是轮廓的索引（在绘制独立轮廓是很有用，当设置为-1时表示绘制所有轮廓）。接下来的参数是轮廓的颜色和厚度等。</p><p>下面的例子在一幅图像上绘制所有的轮廓：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2im = cv2.imread(<span class="hljs-string">&#x27;test.jpg&#x27;</span>)imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)ret,thresh = cv2.threshold(imgray,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)image, contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</code></pre><p>使用以下代码可以绘制单个独立的轮廓：<br><pre><code class="hljs apache"><span class="hljs-attribute">img</span> = cv<span class="hljs-number">2</span>.drawContour(img, contours, -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>), <span class="hljs-number">3</span>)</code></pre></p><h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><p>图像的矩可以帮助我们计算图像的质心，面积等。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]M = cv2.moments(cnt)    <span class="hljs-comment"># 使用cv2.moments()取得轮廓的矩，返回值是字典类型</span>print(M)</code></pre><p><a href="WEBRESOURCEd288752d7ed729de88cd5eebfd3e5ac4" title="image.png" class="gallery-item"><img src="WEBRESOURCEd288752d7ed729de88cd5eebfd3e5ac4" alt="image.png"></a></p><p>根据这些矩的值，我们可以计算出对象的重心: <code>$C_x = \frac&#123;M_&#123;10&#125;&#125;&#123;M_&#123;100&#125;&#125;, C_y=\frac&#123;M_&#123;01&#125;&#125;&#123;M_&#123;100&#125;&#125;$</code>，亦即：<br><pre><code class="hljs ini"><span class="hljs-attr">cx</span> = int(M[<span class="hljs-string">&#x27;m10&#x27;</span>]/M[<span class="hljs-string">&#x27;m00&#x27;</span>])<span class="hljs-attr">cy</span> = int(M[<span class="hljs-string">&#x27;m01&#x27;</span>]/M[<span class="hljs-string">&#x27;m00&#x27;</span>])</code></pre></p><h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><p>&emsp;&emsp;轮廓的面积可以使用函数<code>cv2.contourArea()</code>计算得到，也可以使用矩（0 阶矩），即M[‘m00’]。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ml.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]perimeter = cv2.arcLength(cnt,<span class="hljs-literal">True</span>)print(perimeter)</code></pre><p><a href="WEBRESOURCE84773f1a7592cce78842eef3d9881a67" title="image.png" class="gallery-item"><img src="WEBRESOURCE84773f1a7592cce78842eef3d9881a67" alt="image.png"></a></p><h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><p>&emsp;&emsp;也被称为弧长。可以使用函数<code>cv2.arcLength()</code> 计算得到。这个函数的第二参数可以用来指定对象的形状是闭合的（True），还是打开的（一条曲线）。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ball.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)perimeter = cv2.arcLength(contours,<span class="hljs-literal">True</span>)print(perimeter)</code></pre><p><a href="WEBRESOURCE8325e6507dcdf068ad2fc1ca6efd0f9e" title="image.png" class="gallery-item"><img src="WEBRESOURCE8325e6507dcdf068ad2fc1ca6efd0f9e" alt="image.png"></a></p><h3 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h3><p>&emsp;&emsp;将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定。使用的是Douglas-Peucker算法。</p><p>&emsp;&emsp;为了帮助理解，假设我们要在一幅图像中查找一个矩形，但是由于图像的种种原因，我们不能得到一个完美的矩形，而是一个“坏形状”。现在你就可以使用这个函数来近似这个形状了。这个函数的第二个参数叫epsilon，它是从原始轮廓到近似轮廓的最大距离。它是一个准确度参数。选择一个好的epsilon 对于得到满意结果非常重要。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ml.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]epsilon = <span class="hljs-number">0.1</span>*cv2.arcLength(cnt,<span class="hljs-literal">True</span>)approx = cv2.approxPolyDP(cnt,epsilon,<span class="hljs-literal">True</span>)print(approx)</code></pre><p><a href="WEBRESOURCE329b0c9dc2a9587cb959bcadf6cf3a53" title="image.png" class="gallery-item"><img src="WEBRESOURCE329b0c9dc2a9587cb959bcadf6cf3a53" alt="image.png"></a></p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>&emsp;&emsp;凸包与轮廓相似，但它们是不同的两个特征，虽然有些情况下它们给出的结果是一样的。函数<code>cv2.convexHull()</code>可以用来检测一个曲线是否具有凸性缺陷，并能纠正缺陷。<br><br>&emsp;&emsp;一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去了就被叫做凸性缺陷。例如下图中的手。红色曲线显示了手的凸包，凸性缺陷被双箭头标出来了。</p><p><a href="WEBRESOURCE1d737d91ebf7db1e7db78bd9a1299564" title="image.png" class="gallery-item"><img src="WEBRESOURCE1d737d91ebf7db1e7db78bd9a1299564" alt="image.png"></a></p><p>计算轮廓的凸包需要使用cv2.covexHull()函数：<br><pre><code class="hljs reasonml">hull = cv2.convex<span class="hljs-constructor">Hull(<span class="hljs-params">points</span>[, <span class="hljs-params">hull</span>[, <span class="hljs-params">clockwise</span>[, <span class="hljs-params">returnPoints</span>]]</span></code></pre><br>它的各参数含义如下：</p><ul><li>points 我们要传入的轮廓</li><li>hull 输出的像素列表，通常不需要</li><li>clockwise 方向标志。如果设置为True，则输出的凸包是顺时针方向的，否则为逆时针方向。</li><li>returnPoints 默认值为True,它会返回凸包上点的坐标。如果设置为False，就会返回与凸包点对应的轮廓上的点。</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ml.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]hull = cv2.convexHull(cnt)    <span class="hljs-comment"># 计算凸包</span>print(hull)</code></pre><p><a href="WEBRESOURCE6a0aa9204bedf71d015d407e50f1fc63" title="image.png" class="gallery-item"><img src="WEBRESOURCE6a0aa9204bedf71d015d407e50f1fc63" alt="image.png"></a></p><h3 id="凸性检测"><a href="#凸性检测" class="headerlink" title="凸性检测"></a>凸性检测</h3><p>函数cv2.isContourConvex() 可以用来检测一个曲线是不是凸的，它只能返回True 或False。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;ml.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]k = cv2.isContourConvex(cnt)print(k)</code></pre><p><a href="WEBRESOURCEdc0872e13c35bda8af71a382c384e00a" title="image.png" class="gallery-item"><img src="WEBRESOURCEdc0872e13c35bda8af71a382c384e00a" alt="image.png"></a></p><h3 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h3><p>有两类边界矩形。</p><p><strong>直边界矩形</strong> 一个直矩形（就是没有旋转的矩形）是不会考虑对象是否旋转的，所以这个边界矩形的面积不是最小的。可以使用函数<code>cv2.boundingRect()</code>查找得到。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]<span class="hljs-comment"># (x,y)为矩形左上角的坐标，(w,h)为矩形的宽高</span>x,y,w,h = cv2.boundingRect(cnt)img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)   <span class="hljs-comment"># 画出边界矩形</span>cv2.imshow(<span class="hljs-string">&#x27;boundingRect&#x27;</span>, img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE969817ae30b63eecb6bd765fc2e8e4b1" title="image.png" class="gallery-item"><img src="WEBRESOURCE969817ae30b63eecb6bd765fc2e8e4b1" alt="image.png"></a></p><p><strong>旋转的边界矩形</strong> 这个边界矩形是面积最小的，因为它考虑了对象的旋转。用到的函数为<code>cv2.minAreaRect()</code>，返回的是一个Box2D结构，其中包含矩形左上角角点的坐标（x，y），矩形的宽和高（w，h），以及旋转角度。但是要绘制这个矩形需要矩形的4个角点，可以通过函数<code>cv2.boxPoints()</code> 获得。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]x,y,angle = cv2.minAreaRect(cnt)print(angle)</code></pre><p>下图中，红色的矩形为直边界矩形,绿色的矩形为旋转的边界矩形:</p><p><a href="WEBRESOURCE79e73b40da18617690e82bdd2cc902ad" title="image.png" class="gallery-item"><img src="WEBRESOURCE79e73b40da18617690e82bdd2cc902ad" alt="image.png"></a></p><h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>&emsp;&emsp;函数<code>cv2.minEnclosingCircle()</code> 可以帮我们找到一个对象的外切圆，它是所有能够包括对象的圆中面积最小的一个。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>](x,y),radius = cv2.minEnclosingCircle(cnt)center = (<span class="hljs-built_in">int</span>(x),<span class="hljs-built_in">int</span>(y))radius = <span class="hljs-built_in">int</span>(radius)img = cv2.circle(img,center,radius,(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)    <span class="hljs-comment"># 画出最小外接圆</span>cv2.imshow(<span class="hljs-string">&#x27;minEnclosingCircle&#x27;</span>, img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE47630db5070b24bec1018b64f1c2d018" title="image.png" class="gallery-item"><img src="WEBRESOURCE47630db5070b24bec1018b64f1c2d018" alt="image.png"></a></p><h3 id="椭圆拟合"><a href="#椭圆拟合" class="headerlink" title="椭圆拟合"></a>椭圆拟合</h3><p>使用的函数为cv2.ellipse()，返回值其实就是旋转边界矩形的内切圆。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]ellipse = cv2.fitEllipse(cnt)img = cv2.ellipse(img,ellipse,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)    <span class="hljs-comment"># 在原图上画出椭圆</span>cv2.imshow(<span class="hljs-string">&#x27;minEnclosingCircle&#x27;</span>, img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE580696ba1ecf43ffe94b697c58de41d7" title="image.png" class="gallery-item"><img src="WEBRESOURCE580696ba1ecf43ffe94b697c58de41d7" alt="image.png"></a></p><h3 id="直线拟合"><a href="#直线拟合" class="headerlink" title="直线拟合"></a>直线拟合</h3><p>我们可以根据一组点拟合出一条直线，同样我们也可以为图像中的白色点拟合出一条直线。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]rows,cols = img.shape[:<span class="hljs-number">2</span>][vx,vy,x,y] = cv2.fitLine(cnt, cv2.DIST_L2,<span class="hljs-number">0</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.01</span>)lefty = <span class="hljs-built_in">int</span>((-x*vy/vx) + y)righty = <span class="hljs-built_in">int</span>(((cols-x)*vy/vx)+y)img = cv2.line(img,(cols<span class="hljs-number">-1</span>,righty),(<span class="hljs-number">0</span>,lefty),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)cv2.imshow(<span class="hljs-string">&#x27;line&#x27;</span>, img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p><a href="WEBRESOURCE3d58de354780265626a38c2cc7664f32" title="image.png" class="gallery-item"><img src="WEBRESOURCE3d58de354780265626a38c2cc7664f32" alt="image.png"></a></p><h2 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h2><h3 id="长宽比"><a href="#长宽比" class="headerlink" title="长宽比"></a>长宽比</h3><p>边界矩形的宽高比。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]x,y,w,h = cv2.boundingRect(cnt)aspect_ratio = <span class="hljs-built_in">float</span>(w)/hprint(aspect_ratio)</code></pre><p><a href="WEBRESOURCEac045e4efdc7c14b437113a586b826de" title="image.png" class="gallery-item"><img src="WEBRESOURCEac045e4efdc7c14b437113a586b826de" alt="image.png"></a></p><h3 id="Extent"><a href="#Extent" class="headerlink" title="Extent"></a>Extent</h3><p>轮廓面积与边界矩形面积的比。</p><pre><code class="hljs math">Extent &#x3D; \frac&#123;Object Area&#125;&#123;Bounding Rectangle Area&#125;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]area = cv2.contourArea(cnt)x,y,w,h = cv2.boundingRect(cnt)rect_area = w*hextent = <span class="hljs-built_in">float</span>(area)/rect_areaprint(extent)</code></pre><p><a href="WEBRESOURCEa1043dc4b0db301d228b74f9aaad4267" title="image.png" class="gallery-item"><img src="WEBRESOURCEa1043dc4b0db301d228b74f9aaad4267" alt="image.png"></a></p><h3 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h3><p>轮廓面积与凸包面积的比。</p><pre><code class="hljs math">Solidity &#x3D; \frac&#123;Contour Area&#125;&#123;ConvexHull Area&#125;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]area = cv2.contourArea(cnt)hull = cv2.convexHull(cnt)hull_area = cv2.contourArea(hull)solidity = <span class="hljs-built_in">float</span>(area)/hull_areaprint(solidity)</code></pre><p><a href="WEBRESOURCE19632f2c170caea6527610b59acef7e9" title="image.png" class="gallery-item"><img src="WEBRESOURCE19632f2c170caea6527610b59acef7e9" alt="image.png"></a></p><h3 id="Equivalent-Diameter"><a href="#Equivalent-Diameter" class="headerlink" title="Equivalent Diameter"></a>Equivalent Diameter</h3><pre><code class="hljs math">Equivalent Diameter &#x3D; \frac&#123;\sqrt&#123;4\times Contour Area&#125;&#125;&#123;\pi&#125;</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>]area = cv2.contourArea(cnt)equi_diameter = np.sqrt(<span class="hljs-number">4</span>*area/np.pi)print(equi_diameter)</code></pre><p><a href="WEBRESOURCE93e75bd6330166f15a29c532bad84a81" title="image.png" class="gallery-item"><img src="WEBRESOURCE93e75bd6330166f15a29c532bad84a81" alt="image.png"></a></p><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>也就是对象的方向，下面的方法<code>cv2.fitEllipse()</code>还会返回长轴和短轴的长度:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)cnt = contours[<span class="hljs-number">0</span>](x,y),(MA,ma),angle = cv2.fitEllipse(cnt)print(<span class="hljs-built_in">str</span>(x) + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-built_in">str</span>(y) + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-built_in">str</span>(angle))print(<span class="hljs-built_in">str</span>(MA) + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-built_in">str</span>(ma))</code></pre><p><a href="WEBRESOURCE341e267661de5f836fe7cb9339eb1624" title="image.png" class="gallery-item"><img src="WEBRESOURCE341e267661de5f836fe7cb9339eb1624" alt="image.png"></a></p><h3 id="极点"><a href="#极点" class="headerlink" title="极点"></a>极点</h3><p>一个对象最上面，最下面，最左边，最右边的点。</p><p><a href="WEBRESOURCE739119999303a817f10c3b168626d3ef" title="image.png" class="gallery-item"><img src="WEBRESOURCE739119999303a817f10c3b168626d3ef" alt="image.png"></a><br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</p><p>img = cv2.imread(<span class="hljs-string">&#x27;lightning.png&#x27;</span>,<span class="hljs-number">0</span>)</p><p>ret,thresh = cv2.threshold(img,<span class="hljs-number">127</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)<br>contours,hierarchy = cv2.findContours(thresh, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>cnt = contours[<span class="hljs-number">0</span>]</p><p>leftmost = <span class="hljs-built_in">tuple</span>(cnt[cnt[:,:,<span class="hljs-number">0</span>].argmin()][<span class="hljs-number">0</span>])<br>rightmost = <span class="hljs-built_in">tuple</span>(cnt[cnt[:,:,<span class="hljs-number">0</span>].argmax()][<span class="hljs-number">0</span>])<br>topmost = <span class="hljs-built_in">tuple</span>(cnt[cnt[:,:,<span class="hljs-number">1</span>].argmin()][<span class="hljs-number">0</span>])<br>bottommost = <span class="hljs-built_in">tuple</span>(cnt[cnt[:,:,<span class="hljs-number">1</span>].argmax()][<span class="hljs-number">0</span>])</p><p>print(leftmost)<br>print(rightmost)<br>print(topmost)<br>print(bottommost)</code></pre>:hexoPostRenderEscape–&gt;<br><a href="WEBRESOURCE7823e8a650b8b22752b15854fa3ae0ce" title="image.png" class="gallery-item"><img src="WEBRESOURCE7823e8a650b8b22752b15854fa3ae0ce" alt="image.png"></a></p><h1 id="轮廓的层次结构"><a href="#轮廓的层次结构" class="headerlink" title="轮廓的层次结构"></a>轮廓的层次结构</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="Python" scheme="https://baibainote.pro/categories/Python/"/>
    
    
      <category term="opencv-python" scheme="https://baibainote.pro/tags/opencv-python/"/>
    
  </entry>
  
  <entry>
    <title>C++函数</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%87%BD%E6%95%B0/"/>
    <id>https://baibainote.pro/2018/12/07/C++函数/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><strong>值传递</strong><br><pre><code class="hljs angelscript"><span class="hljs-comment">/* 使用值传递，当实参值过大或过多时，赋值给形参这个过程会大大降低程序运行的效率 */</span><span class="hljs-built_in">void</span> swap(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<span class="hljs-comment">// 很明显，使用值传递是无法实现x, y交换的目的的</span>    <span class="hljs-built_in">int</span> temp = a;    a = b;    b = temp;&#125;x = <span class="hljs-number">10</span>;y = <span class="hljs-number">5</span>;swap1(x, y);<span class="hljs-comment">// x, y的值传给形参a, b</span></code></pre></p><p><strong>指针传递</strong><br><pre><code class="hljs sas">void swap2(int <span class="hljs-comment">*a, int *b) &#123;</span><span class="hljs-comment">// 通过x, y的指针直接改变x, y指向的数据，函数内的操作可以影响外部</span><span class="hljs-comment">    int temp = *a;</span>    <span class="hljs-comment">*a = *b;</span>    <span class="hljs-comment">*b = temp;</span>&#125;<span class="hljs-meta">x</span> = 10;y = 5;swap2(<span class="hljs-variable">&amp;x</span>, <span class="hljs-variable">&amp;y</span>);</code></pre><br><pre><code class="hljs angelscript"><span class="hljs-comment">// 对数组进行操作一般使用指针传递</span><span class="hljs-built_in">void</span> sortArr(<span class="hljs-built_in">int</span> arr[<span class="hljs-number">6</span>]) &#123;   <span class="hljs-comment">//这里的 6 只是一个期望值，实际上对形参并没有约束作用,即等价于int arr[]或int *arr</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span> - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">6</span> - i - <span class="hljs-number">1</span>; j++) &#123;            <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>]) &#123;                <span class="hljs-built_in">int</span> temp = a[j];                a[j] = a[j+<span class="hljs-number">1</span>];                a[j+<span class="hljs-number">1</span>] = temp;            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/* </span><span class="hljs-comment">    要想确定数组的大小，还是得显示指定</span><span class="hljs-comment">    数组尺寸 n,即sortArr(int a[], int n)</span><span class="hljs-comment">*/</span><span class="hljs-built_in">void</span> main() &#123;    <span class="hljs-built_in">int</span> b[] = &#123; <span class="hljs-number">21</span>, <span class="hljs-number">13</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span> &#125;;    sortArr(b);&#125;</code></pre><br><strong>引用传递</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>;    swap(x, y);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\ty = &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">/* 运行结果：</span><span class="hljs-comment">    x = 10    y = 5</span><span class="hljs-comment">*/</span><span class="hljs-comment">// 由于传给函数形参的本质上是实参的地址，故不能向函数传入常数</span><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;swap(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// error</span>swap(x, <span class="hljs-number">9</span>);  <span class="hljs-comment">// error</span>swap(<span class="hljs-number">6</span>, x);  <span class="hljs-comment">// error</span></code></pre><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> f = <span class="hljs-number">1.0</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 使用默认参数</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> f)</span> </span>&#123;    <span class="hljs-keyword">return</span> f * f;&#125;</code></pre><p><u><i>使用默认参数要注意以下三点：</i></u><br></p><p>&emsp;&emsp;①在指定某个函数的默认值时,如果它有函数原型,就只能在函数原型中指定对应数的默认值,不能在定义函数时再重复指定参数默认值。当然,若函数是直接定义的,没有函频原型,若要指定参数默认值,在定义时指定就行了。<br><br>&emsp;&emsp;②在具有多个参数的函数中指定默认值时,所有默认参数都必须出现在无默认值参数的右边。即,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> i1, <span class="hljs-built_in">int</span> i2, <span class="hljs-built_in">int</span> i3 = <span class="hljs-number">0</span>);<span class="hljs-built_in">int</span> g(<span class="hljs-built_in">int</span> i1, <span class="hljs-built_in">int</span> <span class="hljs-number">12</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> i3);    <span class="hljs-comment">// error,i3没有默认值</span><span class="hljs-built_in">int</span> h(<span class="hljs-built_in">int</span> i1=<span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> i2, <span class="hljs-built_in">int</span> i3=<span class="hljs-number">0</span>);    <span class="hljs-comment">// error,i1默认后,其右边的i2没有默认值</span></code></pre><br>&emsp;&emsp;③可以用表达式作为默认参数,只要表达式可以转换成形参所需的类型即可。但是,局部量不能作为默认参数值。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">// 定义全局变量</span><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;tom&quot;</span>;<span class="hljs-keyword">double</span> h = <span class="hljs-number">0.8</span>, len = <span class="hljs-number">1.1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dog</span><span class="hljs-params">(<span class="hljs-built_in">string</span> dogname = name, <span class="hljs-keyword">double</span> high = h, <span class="hljs-keyword">double</span> length = len)</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Dogname： &quot;</span> &lt;&lt; dogname &lt;&lt; <span class="hljs-string">&quot;\tHigh：&quot;</span> &lt;&lt; h &lt;&lt; <span class="hljs-string">&quot;\tLength：&quot;</span> &lt;&lt; len &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    name = <span class="hljs-string">&quot;Jake&quot;</span>;     <span class="hljs-comment">// 修改全局变量以改变参数name的默认值</span>    <span class="hljs-keyword">double</span> h = <span class="hljs-number">2.1</span>;    <span class="hljs-comment">// 重新定义一个局部变量h，与全局变量h无关，对参数high的默认值无影响</span>    dog();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 运行结果如下：</span><span class="hljs-comment">Dogname：Jake    High：0.8    Length：1.1</span><span class="hljs-comment">*/</span></code></pre><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>默认返回值和void的返回值</strong></p><p>&emsp;&emsp;每个函数最后都是通过return语句来结束调用的(返回值为void的函数没有return语句，但系统会在该函数的最后一条语句的后面隐式地执行return语句)<br><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-comment">// 在最新的C++11中的标准中，函数没有默认返回值了(在C语言和早期的C++中，函数的默认返回值为int)</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = a[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span> &lt; a[i])            <span class="hljs-built_in">max</span> = a[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;    <span class="hljs-keyword">if</span> (a = b)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> t = a;        a = b;        b = t;    &#125;&#125;</code></pre></p><p><strong>返回引用</strong><br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-keyword">int</span> temp;<br><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2)</span> </span>&#123;<br>    temp = i1 + i2;<br>    <span class="hljs-keyword">return</span> temp;   <span class="hljs-comment">// 返回 temp的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t = f(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>    f(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)++;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>    f(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">9</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-comment">/<em> 运行结果如下：</span><br><span class="hljs-comment">    4    11    9</span><br><span class="hljs-comment"></em>/</span></code></pre>:hexoPostRenderEscape–&gt;<br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2)</span> </span>&#123;    <span class="hljs-comment">// error</span><span class="hljs-comment">// 返回值为引用的函数应该return一个变量，而不能是表达式</span>    <span class="hljs-keyword">return</span> i1 + i2;&#125;</code></pre><br><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;<span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2)</span> </span>&#123;    <span class="hljs-keyword">return</span> i1 + i2;&#125;<span class="hljs-comment">// 函数返回值为常量引用值时可以return表达式</span><span class="hljs-comment">/* 函数返回表达式的隐式过程：</span><span class="hljs-comment">int temp = i1 + i2;</span><span class="hljs-comment">return temp;</span><span class="hljs-comment">一般情况下，函数返回temp的值后，temp就会被回收</span><span class="hljs-comment">但返回值为const type&amp;时，temp会被保留，将temp的地址作为返回值，直到使用函数返回值的那个变量的作用域结束后才被回收</span><span class="hljs-comment">*/</span></code></pre></p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><pre><code class="hljs cpp"><span class="hljs-comment">/* 重载函数必须具有不同的形参列表 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> ? x : -x; &#125;<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Abs</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> ? x : -x &#125;<span class="hljs-keyword">double</span> Abs(<span class="hljs-keyword">double</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> ? x : -x; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; Abs(<span class="hljs-number">-9</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; Abs(<span class="hljs-number">-9.9f</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; Abs(<span class="hljs-number">-9.8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><p><u><i>重载函数注意事项:</i></u></p><p>&emsp;&emsp;① 返回值不同并不能作为重载函数的依据。<br><pre><code class="hljs cpp"><span class="hljs-comment">// 重载函数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">char</span>)</span></span><span class="hljs-function"><span class="hljs-comment">// 只有返回类型不同，而函数名和参数表都完全相同的函数只能看作是同一函数的重复声明</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;</code></pre><br>&emsp;&emsp;② 在定义和调用重载函数时，要注意它的二义性。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; x)</span> </span>&#123;…&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;…&#125;</p><p><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>f(a);      <span class="hljs-comment">// error,产生二义性，无法确定调用的是f(int&amp; x)还是f(int x)</span></code></pre>:hexoPostRenderEscape–&gt;</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++命名空间</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://baibainote.pro/2018/12/07/C++命名空间/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p><strong>命名空间的概念</strong></p><p>&emsp;在程序设计时,要求同一程序在全局作用域中声明的每个变量,函数,类型,常量等都必须具有唯一的名称,如有重复,就会产生命名冲突。程序员不一定对系统的全部库函数名和全局变量符号都熟悉,容易定义与系统已有名称重复的变量名。另外,如果一个程序由许多程序员共同编写,彼此并不知道对方定义的标识符名称,回名在所难免,诸如此类原因还有很多,如在程序中引入另一个系统或第三方软件商提供的库文件,它们定义的全局名称(如全局变量,函数、类型等的名称)也容易与当前程序的已有名称相同,上述情况引发的名字冲突问题称为全局命名空间污染问题,处理起来并不容易,在大型程序中尤其困难,C标准引入命名空间来解决此问题。<br><br>&emsp;&emsp;命名空间就是每个程序员或每个不同的函数库各自独立地定义的一个名称,将自己设计的全部对象(包括变量,函数、类型、类等)都包含在此名称之下。这样,每个变量的全名就是“命名空间对象名称”,只要命名空间不同名,就能够有效地区分程序中的同名变量。</p><p><strong>命名空间定义</strong><br><pre><code class="hljs angelscript"><span class="hljs-comment">// 命名空间定义句法：</span><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">name</span> &#123;    members;&#125;</code></pre><br><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> ABC &#123;    <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">float</span>, house_price;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span>        <span class="hljs-keyword">char</span>* name;        <span class="hljs-keyword">int</span> age;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)a + b; &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ABC::min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &gt; b ? a : b; &#125;</code></pre><br><strong>命名空间的应用</strong><br><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> main() &#123;    ABC::count = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 访问ABC空间中的count</span>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">9</span>;     <span class="hljs-comment">// 这是main函数中的局部变量count，与ABC中的count无关</span>    ABC::student s;    <span class="hljs-comment">// 使用ABC中的结构体定义变量</span>    s.age = <span class="hljs-number">9</span>;    <span class="hljs-built_in">int</span> x = ABC::min(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">// 调用命名空间ABC中的函数min()</span>&#125;</code></pre><br>① 使用<code>using namespace_name::identifier</code>引用命名空间的单个成员。<br><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">using</span> ABC::count;    <span class="hljs-comment">// 引用命名空间ABC中的count，引用之后，就不用在count前面加上ABC::了</span>    count = <span class="hljs-number">2</span>;    <span class="hljs-comment">// int count = 9;</span>    count = count + <span class="hljs-number">2</span>;&#125;</code></pre><br>②使用<code>using namespace ABC</code>引用命名空间的全部成员。<br><pre><code class="hljs arduino"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ABC;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">9</span>;   <span class="hljs-comment">// 已引入了ABC中定义的count,这是重复定义</span>    student s;    count = <span class="hljs-number">5</span>;    s.age = <span class="hljs-built_in">min</span>(<span class="hljs-number">43</span>, <span class="hljs-number">32</span>);&#125;</code></pre></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++常量</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%B8%B8%E9%87%8F/"/>
    <id>https://baibainote.pro/2018/12/07/C++常量/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<iframe src="https://www.desmos.com/calculator/tskywapslo?embed" width="500px" height="500px" style="border: 1px solid #ccc" frameborder=0></iframe><p><strong>常量的定义</strong></p><p>在C++中，定义常量可以使用const或constexpr。<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;  <span class="hljs-comment">// 常量必须在定义时进行初始化</span><br><span class="hljs-keyword">int</span> i, j = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k = i + j + <span class="hljs-number">5</span>;   <span class="hljs-comment">// 表达式可以用来初始化常量</span></p><p><span class="hljs-comment">/<em> constexpr与const基本类似，</span><br><span class="hljs-comment">但constexpr常量必须在编译时就被初始化，</span><br><span class="hljs-comment">而const常量可以延迟到运行时被初始化</span><br><span class="hljs-comment"></em>/</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = f();<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> num = f();   <span class="hljs-comment">// error,编译时不知道f()的返回值</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> t = j + <span class="hljs-number">10</span>;  <span class="hljs-comment">// error,j是变量,编译时还不知道j的值</span></p><p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;</p><p><strong>const与指针</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">/* 指针实际上可以看作是两部分，对象的地址和所指向对象的值 */</span><span class="hljs-comment">/*</span><span class="hljs-comment">    =&gt; 底层const：</span><span class="hljs-comment">      const type *p1;   // *p1不可变(该内存处存储的变量不可变)，p1可变</span><span class="hljs-comment">    =&gt; 顶层const：</span><span class="hljs-comment">      type *const p2;   // p2不可变(始终指向同一块内存),*p2可变</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> p0;    <span class="hljs-comment">// error,p0未初始化</span>    <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> p1 = <span class="hljs-string">&quot;dukang&quot;</span>;    <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *p2;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p3 = <span class="hljs-string">&quot;dukang&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> p4 = <span class="hljs-string">&quot;dukang&quot;</span>;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> p5;   <span class="hljs-comment">// error,p5是常量，必须初始化</span>    p1 = <span class="hljs-string">&quot;wankang&quot;</span>;         <span class="hljs-comment">// error,p1是常量，不可变更</span>    p2 = <span class="hljs-string">&quot;wankang&quot;</span>;    p3 = <span class="hljs-string">&quot;wankang&quot;</span>;    p4 = <span class="hljs-string">&quot;wankang&quot;</span>;         <span class="hljs-comment">// error,p4是常量，不可变更</span>    p1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;w&#x27;</span>;    p2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;w&#x27;</span>;            <span class="hljs-comment">// error,*p2是常量</span>    p3[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;w&#x27;</span>;            <span class="hljs-comment">// error,*p3是常量</span>    p4[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;w&#x27;</span>;            <span class="hljs-comment">// error,*p4是常量</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>const与引用</strong></p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">9</span>;<span class="hljs-built_in">int</span> &amp;rr = i;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> &amp;ri = i;rr = <span class="hljs-number">8</span>;ri = <span class="hljs-number">7</span>;    <span class="hljs-comment">// error,ri是常量，不允许通过它来修改i的值</span></code></pre><p><code>`int i = 2;const double &amp;ff = 10.0;  // 常量引用可以用常量初始化// 等价于 double temp = 10.0;const double &amp;ff = tempconst int &amp;ri = i + 10;int &amp;ii = 3;   // error,非常量引用不能用常量初始化</code></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++引用</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%BC%95%E7%94%A8/"/>
    <id>https://baibainote.pro/2018/12/07/C++引用/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>;    <span class="hljs-keyword">int</span> &amp;ri = i;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;    &quot;</span> &lt;&lt; <span class="hljs-string">&quot;ri = &quot;</span> &lt;&lt; ri &lt;&lt; <span class="hljs-built_in">endl</span>;    ri = <span class="hljs-number">20</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;    &quot;</span> &lt;&lt; <span class="hljs-string">&quot;ri = &quot;</span> &lt;&lt; ri &lt;&lt; <span class="hljs-built_in">endl</span>;    i = <span class="hljs-number">12</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;    &quot;</span> &lt;&lt; <span class="hljs-string">&quot;ri = &quot;</span> &lt;&lt; ri &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;i 的地址是：&quot;</span> &lt;&lt; &amp;i &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ri 的地址是：&quot;</span> &lt;&lt; &amp;ri &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<span class="hljs-comment">/* 运行结果：</span><span class="hljs-comment">    i = 9    ri = 9</span><span class="hljs-comment">    i = 20    ri = 20</span><span class="hljs-comment">    i = 12    ri = 12</span><span class="hljs-comment">    i 的地址是： 0029FDB0</span><span class="hljs-comment">    ri 的地址是： 0029FDB0</span><span class="hljs-comment">*/</span></code></pre><p>可以看到，ri和i指的实际上是同一个变量(内存地址)，对ri的操作实际上就是对i的操作，ri可以看做是i的别名。<br><a href="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/ff61098393b04a6e0be38516cd6422dc/25835" class="gallery-item"><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/ff61098393b04a6e0be38516cd6422dc/25835" alt=""></a><br><i>使用引用时需要注意以下几个问题：</i><br><br>&emsp;&emsp;① 在定义引用时，&amp;在类型与引用名之间的位置是灵活的，故以下几种定义完全等价：<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>&amp; ri = i;    <span class="hljs-built_in">int</span> &amp; ri = i;    <span class="hljs-built_in">int</span> &amp;ri = i;</code></pre><br>&emsp;&emsp;② 在变量声明时出现的&amp;才是引用运算符(包括函数参数声明和函数返回类型的声明)，其它地方出现的&amp;则是地址操作符。<br><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i;<span class="hljs-keyword">int</span> &amp;r = i;     <span class="hljs-comment">// 引用</span><span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i1, <span class="hljs-keyword">int</span> &amp;)</span></span>;     <span class="hljs-comment">// 引用参数(声明参数变量)</span><span class="hljs-keyword">int</span> *p = &amp;i;    <span class="hljs-comment">// &amp;取i的地址</span><span class="hljs-built_in">cout</span> &lt;&lt; &amp;p;     <span class="hljs-comment">// &amp;取p的地址</span></code></pre><br>&emsp;&emsp;③ 引用必须在定义时初始化，不能在定义完成后再给它赋值<b>;</b>为引用提供的初始值可以是一个变量名，也可以是另一个引用名，也可以是另一个引用名<b>;</b>同一个变量可以定义多个引用。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">float</span> f;<span class="hljs-built_in">float</span> &amp;fr;   <span class="hljs-comment">// error,引用定义时未初始化</span><span class="hljs-built_in">float</span> &amp;r1 = f;   <span class="hljs-comment">// r1 &lt;=&gt; f</span><span class="hljs-built_in">float</span> &amp;r2 = f;   <span class="hljs-comment">// r2 &lt;=&gt; f</span><span class="hljs-built_in">float</span> &amp;r3 = r1;  <span class="hljs-comment">// r3 &lt;=&gt; r1 &lt;=&gt; f</span></code></pre></p><p>&emsp;&emsp;④引用对应着变量的左值，代表变量的内存区域，实际是一种隐式指针，但与指针存在区别。<br><br>&emsp;&emsp;引用与指针的区别。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> main() &#123;    <span class="hljs-built_in">int</span> i = <span class="hljs-number">9</span>;    <span class="hljs-built_in">int</span> *pi = &amp;i;   <span class="hljs-comment">// 取地址</span>    <span class="hljs-built_in">int</span> &amp;ri = i;    <span class="hljs-comment">// 定义引用</span>    *pi = <span class="hljs-number">2</span>;    ri = <span class="hljs-number">8</span>;         <span class="hljs-comment">// ri等价于*pi</span>&#125;</code></pre><br><a href="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/29a08d9b1efd597d0cd30813de70e334/25021" class="gallery-item"><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/29a08d9b1efd597d0cd30813de70e334/25021" alt=""></a></p><p>可以看到，引用本质上也是指针的一种隐式封装，即将*pi简化为ri。但它与指针至少存在两点区别：</p><ul><li>指针必须通过解引用运算符”*”才能访问它所指向的内存单元，而引用则与普通变量的访问方法差不多;</li><li>指针是一个变量，它有自己独立的内存区域，可以对它重新赋值，让它指向其他地址。但引用只是某个变量的别名，甚至没有自己独立的内存区域，必须在定义时进行初始化，并且一经定义就再也不能作为其他变量的引用了。</li></ul><p>&emsp;&emsp;⑤ 当用&amp;运算符获取一个引用的地址时，实际取出的是引用对应的变量的地址。例如：<br><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>;<span class="hljs-keyword">int</span> &amp;ri = i;<span class="hljs-keyword">int</span> *pi = &amp;ri;   <span class="hljs-comment">// pi的值实际上是i(ri是i的别名引用)的地址</span></code></pre></p><p>&emsp;&emsp;⑥ 建立引用时，引用应当类型匹配。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> d;<span class="hljs-built_in">int</span> &amp;rd = d;   <span class="hljs-comment">// 引用类型与它对应的变量类型不匹配</span></code></pre></p><p>&emsp;&emsp;⑦ 引用与数组。可以建立数组或数组元素的引用，但不能建立引用数组。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, a[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;, *b[<span class="hljs-number">10</span>];<span class="hljs-built_in">int</span> (&amp;ra)[<span class="hljs-number">10</span>] = a;   <span class="hljs-comment">// ra是具有10个元素的整型数组的引用</span><span class="hljs-built_in">int</span> &amp;aa = a[<span class="hljs-number">0</span>];      <span class="hljs-comment">// 数组元素的引用</span><span class="hljs-built_in">int</span> *(&amp;rpa)[<span class="hljs-number">10</span>] = b; <span class="hljs-comment">// rpa是具有10个整型指针的数组的引用</span><span class="hljs-built_in">int</span> &amp;ai[<span class="hljs-number">10</span>] = a;     <span class="hljs-comment">// error,ai是引用数组(每个数组元素都是引用)，这是不允定义的</span>ra[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 数组引用的用法</span>rpa[<span class="hljs-number">3</span>] = &amp;i;         <span class="hljs-comment">//</span></code></pre></p><p>&emsp;&emsp;⑧ 引用与指针。可以建立指针的引用，但不能创建指向引用的指针。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, a[<span class="hljs-number">10</span>];<span class="hljs-built_in">int</span> &amp;*ip = i;     <span class="hljs-comment">// error,ip是指向引用的指针</span><span class="hljs-built_in">int</span> *pi = &amp;i;<span class="hljs-built_in">int</span> *pr = pi;     <span class="hljs-comment">// pr是指针的引用</span></code></pre></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++z作用域与生命周期</title>
    <link href="https://baibainote.pro/2018/12/07/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F/"/>
    <id>https://baibainote.pro/2018/12/07/作用域和生命期/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>&emsp;&emsp;C++的作用域大致可以分为<font color=#609090><code>全局作用域</code></font>、<font color=#609090><code>局部作用域</code></font>和<font color=#609090><code>文件作用域</code></font>三种。还有一种更细的分法，按照作用域范围从大到小分为<font color=#609090><code>程序作用域</code></font>，<font color=#609090><code>文件作用域</code></font>，<font color=#609090><code>类作用域</code></font>，<font color=#609090><code>函数作用域</code></font>和<font color=#609090><code>块作用域</code></font>5种类型。</p><p><strong>①程序作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指一个标识符在整个程序范围内有效。若一个程序由多个文件组成,具有这种作用域的标识符可以在该程序的各文件中应用。具有程序作用域的标识符只能在某个文件中定义一次,在要使用它的文件中用 extern声明。例如,如果有10个文件都要用到某个变量,这个变量也只能在一个文件中定义,在其他9个文件中必须用extern声明后才能使用。<br></p></blockquote><p><strong>②文件作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指在一个文件中所有函数定义之外定义的名字(包括函数名),其有效范围为从定义它的语句位置开始,直到文件结束。具有文件作用域的名字只能在定义它的文件中使用,但不能在组成同一程序的其他文件中使用。<br></p></blockquote><p><strong>③函数作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指在函数范围内有效的标志符。<br></p></blockquote><p><strong>④块作用域:</strong><br></p><blockquote><p>&emsp;&emsp;写在{}内的一条或多条语句就构成了一个语句块,在其中定义的标识符就只能在这对“{}”中使用,而且只在定义(或声明)它的语句位置到离它最近的“}”之间有效,即只能在这段代码区域内引用它,这就是块作用域<br>在C++中,任何在“{}”中定义或声明的标识符都具有块作用域。局限在一个函数内部的标识符都具有块作用域,包括在函数内部定义的变量或对象、函数的形式参数等。<br></p></blockquote><p><strong>⑤作用域限定符:</strong><br></p><blockquote><p>&emsp;&emsp;在函数中,一旦在当前作用域中找到了需要的名字,编译器就会忽略外层作用域中的同名实体。也就是说,若局部变量和某个全局变量同名,局部变量名会隐藏全局变量名。在这种情况下,可用作用域限定符“:”存取全局变量的值。</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-comment">/* 最外层的i和函数f()具有文件作用域 */</span><span class="hljs-comment">/* f()内为块作用域 */</span><span class="hljs-built_in">int</span> i;<span class="hljs-built_in">int</span> f() &#123;    <span class="hljs-built_in">int</span> i;    i = <span class="hljs-number">1</span>;           <span class="hljs-comment">// 修改f()中定义的局部变量i</span>    ::i = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 修改全局变量i</span>    &#123;        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;        static <span class="hljs-built_in">int</span> k;        i = <span class="hljs-number">2</span>;       <span class="hljs-comment">// 修改f()中定义的局部变量i</span>        ::i = <span class="hljs-number">3</span>;     <span class="hljs-comment">// 修改全局变量i</span>    &#125;    j = <span class="hljs-number">2</span>;           <span class="hljs-comment">// error,k已被回收</span>    <span class="hljs-keyword">return</span> k;        <span class="hljs-comment">// k已失去作用域</span>&#125;<span class="hljs-comment">/* 由于局部变量在函数运行结束时它的那个内存地址会被回收以重新分配给其他数据，所以不要在函数内返回局部变量的地址和引用。 */</span></code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">/* if语句里的作用域 */</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span>) &#123;      <span class="hljs-comment">// i的作用域自此开始</span>    <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;       <span class="hljs-comment">// p的作用域自此开始</span>&#125;                    <span class="hljs-comment">// p的作用域到此结束</span><span class="hljs-keyword">else</span> &#123;    i = <span class="hljs-number">1</span>;    p = <span class="hljs-number">2</span>            <span class="hljs-comment">// error, p已无定义</span>&#125;                    <span class="hljs-comment">// i的作用域到此结束</span></code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">/* switch语句中的变量作用域 */</span><span class="hljs-built_in">void</span> f(<span class="hljs-built_in">int</span> i) &#123;    <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">int</span> j = i) &#123;    <span class="hljs-comment">// j的作用域自此开始</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: j = j + <span class="hljs-number">1</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: cout &lt;&lt; j;    &#125;                      <span class="hljs-comment">// j的作用域到此结束</span>    cout &lt;&lt; j &lt;&lt; endl;     <span class="hljs-comment">// error,j已无定义</span>&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">/* 循环语句中的作用域 */</span><span class="hljs-comment">// C++新标准中，for循环中允许初始化i变量</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> z)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; z; i++) &#123;    <span class="hljs-comment">// i的作用域开始</span>        <span class="hljs-keyword">int</span> j = i;        <span class="hljs-built_in">cout</span> &lt;&lt; i * j &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;                               <span class="hljs-comment">// i的作用域到此结束</span>    <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;              <span class="hljs-comment">// error, i已无定义</span>&#125;</code></pre><h4 id="变量类型与生命期"><a href="#变量类型与生命期" class="headerlink" title="变量类型与生命期"></a>变量类型与生命期</h4><table><tr><td><br>&emsp;&emsp;根据变量的作用域范围,变量可分为全局变量和局部变量两大类。在函数内部定义的变量就是局部变量(包括函数参数),它们只能在定义它的函数中使用;在函数之外且不在任何一对“{”内定义的变量(不属于任何函数)就是全局变量,其有效范围从其在文件中的定义位置开始到文件结束。<br><br>&emsp;&emsp;变量的生命期是指变量在内存中存在的时间,生命期与变量所在的内存区域有关。为了更清楚地理解这个问题,先看看运行程序对内存的应用情况。个程序在其运行期间,它的程序代码和数据会被分别存储在4个不同的内存区域中,如图所示。<br></td></tr></table><p><a href="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/a63faddcaaff39211668400680aa307c/25039" class="gallery-item"><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/a63faddcaaff39211668400680aa307c/25039" alt=""></a></p><ul><li><code>程序代码区</code>:程序代码(即程序的各函数代码)存放在此区域中。</li><li><code>全局数据区</code>:程序的全局数据(如全局变量)和静态数据( static)存放在此区域中。</li><li><code>栈区</code>:程序的局部数据(在函数中定义的数据)存放在此区域中。</li><li><code>堆区</code>:程序的动态数据(new、 malloc就在此区域中分配存储空间)存放在此区域中。<br></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br><br>&emsp;&emsp;全局数据区中的数据由C++编译器建立,对于定义时没有初始化的变量,系统会自动将其初始化为0.这个区域中的数据一直保存,直到程序结束时才由系统负责回收。<br><br>&emsp;&emsp;堆区的数据由程序员管理,程序员可用<code>new</code>或<code>malloc</code>分配其中的存储单元给指针变量,用完之后,由程序员用<code>delete</code>或<code>free</code>将其归还系统,以便其他程序使用。<br><br>&emsp;&emsp;在函数中定义的局部变量(除了static类型的局部变量外,static类型的变量在全局数据区中),只有当函数被调用时,系统才会为函数建立堆栈,并在栈区中为函数中定义的局部变量分配存储空间,且不会对分配的存储单元做初始化工作。一旦函数调用完成,系统就会回收这些变量在栈区中的存储单元。<br><br>&emsp;&emsp;全局变量和静态变量存储在全局数据区中,它们具有较长的生命期。非静态的局部变量存储在栈区中,其生命期很短,只在函数调用期间有效。<br><br>&emsp;&emsp;<u>静态变量可分为静态全局变量和静态局部变量</u>,前者的作用域是整个程序范围,后者的作用域局限于定义它的语句块。静态局部变量的作用域与普通局部变量的作用域是相同的,但它与全局变量有着同样长的生命期,即程序结束时它才会被释放。普通局部变量的生命期只有函数调用期向才存在,函数调用完成后就结束了。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> n;        <span class="hljs-comment">// n被初始化为0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">// i被初始化为0</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    i += <span class="hljs-number">2</span>;    j += <span class="hljs-number">2</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;j = &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n += <span class="hljs-number">5</span>;    f();             <span class="hljs-comment">// 输出i = 2, j = 2</span>    i = <span class="hljs-number">2</span>;           <span class="hljs-comment">// error,i作用域为f()内部</span>    f();             <span class="hljs-comment">// 输出i = 4, j = 2</span>&#125;                    <span class="hljs-comment">// i, n的生命期到此结束</span></code></pre><h4 id="初始化列表，变量初始化与赋值"><a href="#初始化列表，变量初始化与赋值" class="headerlink" title="初始化列表，变量初始化与赋值"></a>初始化列表，变量初始化与赋值</h4><p>&emsp;&emsp;变量在被创建时就获得一个指定的值，称为<font color=906060>初始化</font>。初始化值可以是任意复杂的表达式，当同时定义多个变量时，位于前面的变量马上就能够用于初始化另一个变量，即<code>int i = 10, j = i * 10</code>。<br><br>&emsp;&emsp;初始化的方式一般有以下几种:<br><pre><code class="hljs angelscript"><span class="hljs-comment">/* 这四种初始化方式是等价的 */</span><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> x(<span class="hljs-number">0</span>);<span class="hljs-comment">/* 后两种称为初始化列表方式 */</span><span class="hljs-built_in">int</span> x = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-built_in">int</span> x&#123;<span class="hljs-number">0</span>&#125;;</code></pre></p><font size=2 color=#609060>&emsp;&emsp;后两种方式是C++ 11新标准的一部分，”{}”除了用于变量初始化，还可用于赋值。而在此前的C++标准中，只有部分场合才允许使用这种初始化方式，如数组初始化。</font><p><u><i>初始化与赋值:</i></u><br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs abnf">int x = <span class="hljs-number">10</span><span class="hljs-comment">;</span></p><p>int x<span class="hljs-comment">;</span><br><span class="hljs-attribute">x</span> = <span class="hljs-number">10</span><span class="hljs-comment">;</span></code></pre>:hexoPostRenderEscape–&gt;<br>&emsp;&emsp;虽然x的最终值都是10，但<code>x = 10</code>是赋值语句，可以理解为:先除掉x对应内存单元中的值，再写入10，而<code>int x = 10</code>没有这个过程，它是在为x分配内存单元的同时就写入10。<br><br><u><i>全局变量，静态变量与局部变量的存储位置:</i></u></p><p> &emsp;&emsp;<font color=#906060>变量初始化的默认规则是</font>:如果定义变量时提供了初始值表达式,系统就用这个表达式的值作为变量的初值:如果定义变量时没有为它提供初值,则全局数据区中的变量将被系统自动初始化为0,栈和堆中的变量不被初始化。<br><br>&emsp;&emsp;全局变量、命名空间的变量、静态变量会被保存在全局数据区中,所以它们会被系统自动初始化为0;局部变量(也叫自动变量)被存储在栈区中;动态分配的变量(用malloc和new建立)被存储在堆区中,它们都不会被系统用默认值初始化。</p><pre><code class="hljs cpp"><span class="hljs-comment">/* 全局变量，静态变量，局部变量的初始化 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;                   <span class="hljs-comment">// 初始化为0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;        <span class="hljs-comment">// 初始化为0</span>    <span class="hljs-keyword">int</span> j;               <span class="hljs-comment">// 未初始化，j值不确定</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;j = &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">int</span> *p1;                <span class="hljs-comment">// p1被初始化为0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> *p2;            <span class="hljs-comment">// p2未被初始化，值未知</span>    <span class="hljs-keyword">int</span> m;              <span class="hljs-comment">// m未被初始化，值未知</span>    f();                <span class="hljs-comment">// 输出i = 0, j = ?, ?表示一个不确定的一个值</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 输出n = 0</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 输出m = ?,  ?表示一个不确定的一个值</span>    <span class="hljs-keyword">if</span> (p1)        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p1 = &quot;</span> &lt;&lt; p1 &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// p1 = 0, 无输出</span>    <span class="hljs-keyword">if</span> (p2)        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;p2 = &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 输出p2 = ?, ?表示不确定地址</span>&#125;</code></pre><p>&emsp;&emsp;综上所述，最好对变量初始化，以免局部变量的不确定值引起程序错误。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>文件的读写</title>
    <link href="https://baibainote.pro/2018/12/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://baibainote.pro/2018/12/07/文件输入与输出/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"<p>&emsp;&emsp;程序与文件的数据交换方法同它与标准输入/输出设配的数据交换方法相同。从文件读取数据与从键盘输入数据的方法相似，将数据写入文件与将数据输出到显示器的方法相似。但<code>iostream</code>中定义的数据类型和函数只能用于标准输入/输出设配的数据处理。C++将处理文件的数据类型放在了头文件<code>fstream</code>里，分为<code>ofstream</code>和<code>ifstream</code>。<br><br>文件流操作一般包括五个步骤:<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs c++"><span class="hljs-comment">/<em> &lt;1&gt; 包含头文件 </em>/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-comment">/<em> &lt;2&gt; 定义文件流句柄file_handler </em>/</span><br>ifstream inData;<br>ofstream outData;</p><p><span class="hljs-comment">/<em> &lt;3&gt; 将文件流句柄与磁盘文件filename关联起来 </em>/</span><br>file_handler.open(filename, mode)<br><span class="hljs-comment">/<em></span><br><span class="hljs-comment">    打开或建立文件的模式mode的可选值:</span><br><span class="hljs-comment">    ios::in            // 打开输入文件，ifstream类型变量的默认方式</span><br><span class="hljs-comment">    ios::out           // 建立输出文件，ofstream类型变量的默认方式</span><br><span class="hljs-comment">    ios::app           // 增加方式，若文件存在，将在文件尾增加数据，否则就建立文件</span><br><span class="hljs-comment">    ios::trunk         // 若文件存在，则文件中已有内容将被清除</span><br><span class="hljs-comment">    ios::nocreate      // 若文件不存在，则打开操作失败</span><br><span class="hljs-comment">    ios::noreplace     // 若文件存在，则打开操作失败</span><br><span class="hljs-comment"></em>/</span><br><span class="hljs-comment">/<em> 打开一个文件:</span><br><span class="hljs-comment">    ofstream outData;</span><br><span class="hljs-comment">    outData.open(&quot;abc.txt&quot;, ios:in);</span><br><span class="hljs-comment">或将&lt;2&gt;,&lt;3&gt;合为一步:</span><br><span class="hljs-comment">    ofstream outData(&quot;abc.txt&quot;, ios::in)</span><br><span class="hljs-comment"></em>/</span></p><p><span class="hljs-comment">/<em> &lt;4&gt; 用文件流(&lt;&lt;或&gt;&gt;)操作文件，读/写文件数据，将输入文件流与&gt;&gt;连接，就能够从文件中读入数据，与cin用法相同。将输出文件流与&lt;&lt;连接，就能够从文件中读入数据，与cout用法相同。 </em>/</span></p><p><span class="hljs-comment">/<em> &lt;5&gt; 关闭文件 </em>/</span><br>inData.close();<br>ourData.close();</code></pre>:hexoPostRenderEscape–&gt;<br><strong>示例</strong><br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ofstream <span class="hljs-title">outData</span><span class="hljs-params">(<span class="hljs-string">&quot;C:\data.txt&quot;</span>)</span></span>;    <span class="hljs-comment">// 前一个 / 用于转义</span><br>    ifstream inData;<br>    <span class="hljs-keyword">int</span> x, a[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        outData &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 将x的值写入文件流句柄outData指向的文件data.txt中</span><br>    &#125;<br>    outData.<span class="hljs-built_in">close</span>();<br>    inData.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;D:\data.txt&quot;</span>);<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!inData.eof())<br>        inData &gt;&gt; a[j++];   <span class="hljs-comment">// 将data.txt中的数据载入数组a[]中</span><br>    inData.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        s += a[i];<br>        <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;the sum is: &quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;</code></pre>:hexoPostRenderEscape–&gt;</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot; /&gt;&lt;div class=&quot;.article
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
</feed>
