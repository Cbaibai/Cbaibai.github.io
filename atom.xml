<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>摆摆笔记</title>
  
  <subtitle>书写，是对思维的缓存！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Cbaibai.com/"/>
  <updated>2018-12-07T11:37:21.421Z</updated>
  <id>http://Cbaibai.com/</id>
  
  <author>
    <name>Cbaibai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++命名空间</title>
    <link href="http://Cbaibai.com/2018/12/07/C++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>http://Cbaibai.com/2018/12/07/C++命名空间/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2018-12-07T11:37:21.421Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命名空间的概念</strong></p><p>&emsp;在程序设计时,要求同一程序在全局作用域中声明的每个变量,函数,类型,常量等都必须具有唯一的名称,如有重复,就会产生命名冲突。程序员不一定对系统的全部库函数名和全局变量符号都熟悉,容易定义与系统已有名称重复的变量名。另外,如果一个程序由许多程序员共同编写,彼此并不知道对方定义的标识符名称,回名在所难免,诸如此类原因还有很多,如在程序中引入另一个系统或第三方软件商提供的库文件,它们定义的全局名称(如全局变量,函数、类型等的名称)也容易与当前程序的已有名称相同,上述情况引发的名字冲突问题称为全局命名空间污染问题,处理起来并不容易,在大型程序中尤其困难,C标准引入命名空间来解决此问题。<br><br>&emsp;&emsp;命名空间就是每个程序员或每个不同的函数库各自独立地定义的一个名称,将自己设计的全部对象(包括变量,函数、类型、类等)都包含在此名称之下。这样,每个变量的全名就是“命名空间对象名称”,只要命名空间不同名,就能够有效地区分程序中的同名变量。</p><p><strong>命名空间定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命名空间定义句法：</span><br><span class="line">namespace name &#123;</span><br><span class="line">    members;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace ABC &#123;</span><br><span class="line">    int count;</span><br><span class="line">    typedef float, house_price;</span><br><span class="line">    struct student &#123;</span><br><span class="line">        char* name;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;;</span><br><span class="line">    double add(int a, int b) &#123; return (double)a + b; &#125;</span><br><span class="line">    inline int min(int a, int b);</span><br><span class="line">&#125;;</span><br><span class="line">int ABC::min(int a, int b) &#123; return a &gt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间的应用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    ABC::count = 1;    // 访问ABC空间中的count</span><br><span class="line">    int count = 9;     // 这是main函数中的局部变量count，与ABC中的count无关</span><br><span class="line">    ABC::student s;    // 使用ABC中的结构体定义变量</span><br><span class="line">    s.age = 9;</span><br><span class="line">    int x = ABC::min(4, 5);   // 调用命名空间ABC中的函数min()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>① 使用<code>using namespace_name::identifier</code>引用命名空间的单个成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ABC::count;</span><br><span class="line">    <span class="comment">// 引用命名空间ABC中的count，引用之后，就不用在count前面加上ABC::了</span></span><br><span class="line">    count = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// int count = 9;</span></span><br><span class="line">    count = count + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②使用<code>using namespace ABC</code>引用命名空间的全部成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using namespace ABC;</span><br><span class="line">void main() &#123;</span><br><span class="line">    int count = 9;   // 已引入了ABC中定义的count,这是重复定义</span><br><span class="line">    student s;</span><br><span class="line">    count = 5;</span><br><span class="line">    s.age = min(43, 32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;命名空间的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;在程序设计时,要求同一程序在全局作用域中声明的每个变量,函数,类型,常量等都必须具有唯一的名称,如有重复,就会产生命名冲突。程序员不一定对系统的全部库函数名和全局变量符号都熟悉,容易定义与系统已有名
      
    
    </summary>
    
      <category term="C++" scheme="http://Cbaibai.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://Cbaibai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数</title>
    <link href="http://Cbaibai.com/2018/12/07/C++%E5%87%BD%E6%95%B0/"/>
    <id>http://Cbaibai.com/2018/12/07/C++函数/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2018-12-07T11:35:51.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><strong>值传递</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 使用值传递，当实参值过大或过多时，赋值给形参这个过程会大大降低程序运行的效率 */</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">// 很明显，使用值传递是无法实现x, y交换的目的的</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">x = 10;</span><br><span class="line">y = 5;</span><br><span class="line">swap1(x, y);</span><br><span class="line">// x, y的值传给形参a, b</span><br></pre></td></tr></table></figure></p><p><strong>指针传递</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap2(int *a, int *b) &#123;</span><br><span class="line">// 通过x, y的指针直接改变x, y指向的数据，函数内的操作可以影响外部</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line">x = 10;</span><br><span class="line">y = 5;</span><br><span class="line">swap2(&amp;x, &amp;y);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 对数组进行操作一般使用指针传递</span><br><span class="line">void sortArr(int arr[6]) &#123;   //这里的 6 只是一个期望值，实际上对形参并没有约束作用,即等价于int arr[]或int *arr</span><br><span class="line">    for (int i = 0; i &lt; 6 - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 6 - i - 1; j++) &#123;</span><br><span class="line">            if (a[j] &gt; a[j+1]) &#123;</span><br><span class="line">                int temp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">    要想确定数组的大小，还是得显示指定</span><br><span class="line">    数组尺寸 n,即sortArr(int a[], int n)</span><br><span class="line">*/</span><br><span class="line">void main() &#123;</span><br><span class="line">    int b[] = &#123; 21, 13, 4, 1, 7, 5 &#125;;</span><br><span class="line">    sortArr(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用传递</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    int x = 5, y = 10;</span><br><span class="line">    swap(x, y);</span><br><span class="line">    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;\ty = &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果：</span><br><span class="line">    x = 10    y = 5</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 由于传给函数形参的本质上是实参的地址，故不能向函数传入常数</span><br><span class="line">int x = 5;</span><br><span class="line">swap(3, 4);  // error</span><br><span class="line">swap(x, 9);  // error</span><br><span class="line">swap(6, x);  // error</span><br></pre></td></tr></table></figure><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> f = <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 使用默认参数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><i>使用默认参数要注意以下三点：</i></u><br></p><p>&emsp;&emsp;①在指定某个函数的默认值时,如果它有函数原型,就只能在函数原型中指定对应数的默认值,不能在定义函数时再重复指定参数默认值。当然,若函数是直接定义的,没有函频原型,若要指定参数默认值,在定义时指定就行了。<br><br>&emsp;&emsp;②在具有多个参数的函数中指定默认值时,所有默认参数都必须出现在无默认值参数的右边。即,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f(int i1, int i2, int i3 = 0);</span><br><span class="line">int g(int i1, int 12 = 0, int i3);    // error,i3没有默认值</span><br><span class="line">int h(int i1=0, int i2, int i3=0);    // error,i1默认后,其右边的i2没有默认值</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;③可以用表达式作为默认参数,只要表达式可以转换成形参所需的类型即可。但是,局部量不能作为默认参数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 定义全局变量</span><br><span class="line">string name = &quot;tom&quot;;</span><br><span class="line">double h = 0.8, len = 1.1;</span><br><span class="line">void dog(string dogname = name, double high = h, double length = len) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Dogname： &quot; &lt;&lt; dogname &lt;&lt; &quot;\tHigh：&quot; &lt;&lt; h &lt;&lt; &quot;\tLength：&quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    name = &quot;Jake&quot;;     // 修改全局变量以改变参数name的默认值</span><br><span class="line">    double h = 2.1;    // 重新定义一个局部变量h，与全局变量h无关，对参数high的默认值无影响</span><br><span class="line">    dog();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果如下：</span><br><span class="line">Dogname：Jake    High：0.8    Length：1.1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>默认返回值和void的返回值</strong></p><p>&emsp;&emsp;每个函数最后都是通过return语句来结束调用的(返回值为void的函数没有return语句，但系统会在该函数的最后一条语句的后面隐式地执行return语句)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int maxArr(int a[], int n) &#123;</span><br><span class="line">// 在最新的C++11中的标准中，函数没有默认返回值了(在C语言和早期的C++中，函数的默认返回值为int)</span><br><span class="line">    int max = a[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (max &lt; a[i])</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">    if (a = b)</span><br><span class="line">        return;</span><br><span class="line">    else &#123;</span><br><span class="line">        int t = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>返回引用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int temp;</span><br><span class="line">int&amp; f(int i1, int i2) &#123;</span><br><span class="line">    temp = i1 + i2;</span><br><span class="line">    return temp;   // 返回 temp的引用</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    int t = f(1, 3);</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; &quot;  &quot;;</span><br><span class="line">    f(2, 8)++;</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; &quot;  &quot;;</span><br><span class="line">    f(2, 3) = 9;</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果如下：</span><br><span class="line">    4    11    9</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int &amp;g(int i1, int i2) &#123;    // error</span><br><span class="line">// 返回值为引用的函数应该return一个变量，而不能是表达式</span><br><span class="line">    return i1 + i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">g</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i1 + i2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数返回值为常量引用值时可以return表达式</span></span><br><span class="line"><span class="comment">/* 函数返回表达式的隐式过程：</span></span><br><span class="line"><span class="comment">int temp = i1 + i2;</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">一般情况下，函数返回temp的值后，temp就会被回收</span></span><br><span class="line"><span class="comment">但返回值为const type&amp;时，temp会被保留，将temp的地址作为返回值，直到使用函数返回值的那个变量的作用域结束后才被回收</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 重载函数必须具有不同的形参列表 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Abs(int x) &#123; return x &gt; 0 ? x : -x; &#125;</span><br><span class="line">float Abs(float x) &#123; return x &gt; 0 ? x : -x &#125;</span><br><span class="line">double Abs(double x) &#123; return x &gt; 0 ? x : -x; &#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cout &lt;&lt; Abs(-9) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Abs(-9.9f) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Abs(-9.8) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><i>重载函数注意事项:</i></u></p><p>&emsp;&emsp;① 返回值不同并不能作为重载函数的依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 重载函数</span><br><span class="line">int f(int, int)</span><br><span class="line">double f(int)</span><br><span class="line">int f(char)</span><br><span class="line">// 只有返回类型不同，而函数名和参数表都完全相同的函数只能看作是同一函数的重复声明</span><br><span class="line">int f(int);</span><br><span class="line">double f(int);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;② 在定义和调用重载函数时，要注意它的二义性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">f(a);      <span class="comment">// error,产生二义性，无法确定调用的是f(int&amp; x)还是f(int x)</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;参数传递&quot;&gt;&lt;a href=&quot;#参数传递&quot; class=&quot;headerlink&quot; title=&quot;参数传递&quot;&gt;&lt;/a&gt;参数传递&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;值传递&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="C++" scheme="http://Cbaibai.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://Cbaibai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++z作用域与生命周期</title>
    <link href="http://Cbaibai.com/2018/12/07/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F/"/>
    <id>http://Cbaibai.com/2018/12/07/作用域和生命期/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2018-12-07T11:38:51.546Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>&emsp;&emsp;C++的作用域大致可以分为<font color="#609090"><code>全局作用域</code></font>、<font color="#609090"><code>局部作用域</code></font>和<font color="#609090"><code>文件作用域</code></font>三种。还有一种更细的分法，按照作用域范围从大到小分为<font color="#609090"><code>程序作用域</code></font>，<font color="#609090"><code>文件作用域</code></font>，<font color="#609090"><code>类作用域</code></font>，<font color="#609090"><code>函数作用域</code></font>和<font color="#609090"><code>块作用域</code></font>5种类型。</p><p><strong>①程序作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指一个标识符在整个程序范围内有效。若一个程序由多个文件组成,具有这种作用域的标识符可以在该程序的各文件中应用。具有程序作用域的标识符只能在某个文件中定义一次,在要使用它的文件中用 extern声明。例如,如果有10个文件都要用到某个变量,这个变量也只能在一个文件中定义,在其他9个文件中必须用extern声明后才能使用。<br></p></blockquote><p><strong>②文件作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指在一个文件中所有函数定义之外定义的名字(包括函数名),其有效范围为从定义它的语句位置开始,直到文件结束。具有文件作用域的名字只能在定义它的文件中使用,但不能在组成同一程序的其他文件中使用。<br></p></blockquote><p><strong>③函数作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指在函数范围内有效的标志符。<br></p></blockquote><p><strong>④块作用域:</strong><br></p><blockquote><p>&emsp;&emsp;写在{}内的一条或多条语句就构成了一个语句块,在其中定义的标识符就只能在这对“{}”中使用,而且只在定义(或声明)它的语句位置到离它最近的“}”之间有效,即只能在这段代码区域内引用它,这就是块作用域<br>在C++中,任何在“{}”中定义或声明的标识符都具有块作用域。局限在一个函数内部的标识符都具有块作用域,包括在函数内部定义的变量或对象、函数的形式参数等。<br></p></blockquote><p><strong>⑤作用域限定符:</strong><br></p><blockquote><p>&emsp;&emsp;在函数中,一旦在当前作用域中找到了需要的名字,编译器就会忽略外层作用域中的同名实体。也就是说,若局部变量和某个全局变量同名,局部变量名会隐藏全局变量名。在这种情况下,可用作用域限定符“:”存取全局变量的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 最外层的i和函数f()具有文件作用域 */</span><br><span class="line">/* f()内为块作用域 */</span><br><span class="line">int i;</span><br><span class="line">int f() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    i = 1;           // 修改f()中定义的局部变量i</span><br><span class="line">    ::i = 0;         // 修改全局变量i</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        static int k;</span><br><span class="line">        i = 2;       // 修改f()中定义的局部变量i</span><br><span class="line">        ::i = 3;     // 修改全局变量i</span><br><span class="line">    &#125;</span><br><span class="line">    j = 2;           // error,k已被回收</span><br><span class="line">    return k;        // k已失去作用域</span><br><span class="line">&#125;</span><br><span class="line">/* 由于局部变量在函数运行结束时它的那个内存地址会被回收以重新分配给其他数据，所以不要在函数内返回局部变量的地址和引用。 */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* if语句里的作用域 */</span><br><span class="line">if(int i = 5) &#123;      // i的作用域自此开始</span><br><span class="line">    int p = 0;       // p的作用域自此开始</span><br><span class="line">&#125;                    // p的作用域到此结束</span><br><span class="line">else &#123;</span><br><span class="line">    i = 1;</span><br><span class="line">    p = 2            // error, p已无定义</span><br><span class="line">&#125;                    // i的作用域到此结束</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* switch语句中的变量作用域 */</span><br><span class="line">void f(int i) &#123;</span><br><span class="line">    switch(int j = i) &#123;    // j的作用域自此开始</span><br><span class="line">        case 1: j = j + 1;</span><br><span class="line">        case 2:</span><br><span class="line">        case 3: cout &lt;&lt; j;</span><br><span class="line">    &#125;                      // j的作用域到此结束</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl;     // error,j已无定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 循环语句中的作用域 */</span><br><span class="line">// C++新标准中，for循环中允许初始化i变量</span><br><span class="line">void f1(int z) &#123;</span><br><span class="line">    for(int i = 0; i &lt; z; i++) &#123;    // i的作用域开始</span><br><span class="line">        int j = i;</span><br><span class="line">        cout &lt;&lt; i * j &lt;&lt; endl;</span><br><span class="line">    &#125;                               // i的作用域到此结束</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;              // error, i已无定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量类型与生命期"><a href="#变量类型与生命期" class="headerlink" title="变量类型与生命期"></a>变量类型与生命期</h4><table><tr><td><br>&emsp;&emsp;根据变量的作用域范围,变量可分为全局变量和局部变量两大类。在函数内部定义的变量就是局部变量(包括函数参数),它们只能在定义它的函数中使用;在函数之外且不在任何一对“{”内定义的变量(不属于任何函数)就是全局变量,其有效范围从其在文件中的定义位置开始到文件结束。<br><br>&emsp;&emsp;变量的生命期是指变量在内存中存在的时间,生命期与变量所在的内存区域有关。为了更清楚地理解这个问题,先看看运行程序对内存的应用情况。个程序在其运行期间,它的程序代码和数据会被分别存储在4个不同的内存区域中,如图所示。<br></td></tr></table><p><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/a63faddcaaff39211668400680aa307c/25039" alt=""></p><ul><li><code>程序代码区</code>:程序代码(即程序的各函数代码)存放在此区域中。</li><li><code>全局数据区</code>:程序的全局数据(如全局变量)和静态数据( static)存放在此区域中。</li><li><code>栈区</code>:程序的局部数据(在函数中定义的数据)存放在此区域中。</li><li><code>堆区</code>:程序的动态数据(new、 malloc就在此区域中分配存储空间)存放在此区域中。<br></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br><br>&emsp;&emsp;全局数据区中的数据由C++编译器建立,对于定义时没有初始化的变量,系统会自动将其初始化为0.这个区域中的数据一直保存,直到程序结束时才由系统负责回收。<br><br>&emsp;&emsp;堆区的数据由程序员管理,程序员可用<code>new</code>或<code>malloc</code>分配其中的存储单元给指针变量,用完之后,由程序员用<code>delete</code>或<code>free</code>将其归还系统,以便其他程序使用。<br><br>&emsp;&emsp;在函数中定义的局部变量(除了static类型的局部变量外,static类型的变量在全局数据区中),只有当函数被调用时,系统才会为函数建立堆栈,并在栈区中为函数中定义的局部变量分配存储空间,且不会对分配的存储单元做初始化工作。一旦函数调用完成,系统就会回收这些变量在栈区中的存储单元。<br><br>&emsp;&emsp;全局变量和静态变量存储在全局数据区中,它们具有较长的生命期。非静态的局部变量存储在栈区中,其生命期很短,只在函数调用期间有效。<br><br>&emsp;&emsp;<u>静态变量可分为静态全局变量和静态局部变量</u>,前者的作用域是整个程序范围,后者的作用域局限于定义它的语句块。静态局部变量的作用域与普通局部变量的作用域是相同的,但它与全局变量有着同样长的生命期,即程序结束时它才会被释放。普通局部变量的生命期只有函数调用期向才存在,函数调用完成后就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static int n;        // n被初始化为0</span><br><span class="line">void f() &#123;</span><br><span class="line">    static int i;    // i被初始化为0</span><br><span class="line">    int j = 0;</span><br><span class="line">    i += 2;</span><br><span class="line">    j += 2;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; &quot;, &quot;;</span><br><span class="line">    cout &lt;&lt; &quot;j = &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    n += 5;</span><br><span class="line">    f();             // 输出i = 2, j = 2</span><br><span class="line">    i = 2;           // error,i作用域为f()内部</span><br><span class="line">    f();             // 输出i = 4, j = 2</span><br><span class="line">&#125;                    // i, n的生命期到此结束</span><br></pre></td></tr></table></figure><h4 id="初始化列表，变量初始化与赋值"><a href="#初始化列表，变量初始化与赋值" class="headerlink" title="初始化列表，变量初始化与赋值"></a>初始化列表，变量初始化与赋值</h4><p>&emsp;&emsp;变量在被创建时就获得一个指定的值，称为<font color="906060">初始化</font>。初始化值可以是任意复杂的表达式，当同时定义多个变量时，位于前面的变量马上就能够用于初始化另一个变量，即<code>int i = 10, j = i * 10</code>。<br><br>&emsp;&emsp;初始化的方式一般有以下几种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 这四种初始化方式是等价的 */</span><br><span class="line">int x = 0;</span><br><span class="line">int x(0);</span><br><span class="line">/* 后两种称为初始化列表方式 */</span><br><span class="line">int x = &#123;0&#125;;</span><br><span class="line">int x&#123;0&#125;;</span><br></pre></td></tr></table></figure></p><font size="2" color="#609060">&emsp;&emsp;后两种方式是C++ 11新标准的一部分，”{}”除了用于变量初始化，还可用于赋值。而在此前的C++标准中，只有部分场合才允许使用这种初始化方式，如数组初始化。</font><p><u><i>初始化与赋值:</i></u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line"></span><br><span class="line">int x;</span><br><span class="line">x = 10;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然x的最终值都是10，但<code>x = 10</code>是赋值语句，可以理解为:先除掉x对应内存单元中的值，再写入10，而<code>int x = 10</code>没有这个过程，它是在为x分配内存单元的同时就写入10。<br><br><u><i>全局变量，静态变量与局部变量的存储位置:</i></u></p><p> &emsp;&emsp;<font color="#906060">变量初始化的默认规则是</font>:如果定义变量时提供了初始值表达式,系统就用这个表达式的值作为变量的初值:如果定义变量时没有为它提供初值,则全局数据区中的变量将被系统自动初始化为0,栈和堆中的变量不被初始化。<br><br>&emsp;&emsp;全局变量、命名空间的变量、静态变量会被保存在全局数据区中,所以它们会被系统自动初始化为0;局部变量(也叫自动变量)被存储在栈区中;动态分配的变量(用malloc和new建立)被存储在堆区中,它们都不会被系统用默认值初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 全局变量，静态变量，局部变量的初始化 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;                   // 初始化为0</span><br><span class="line">void f() &#123;</span><br><span class="line">    static int i;        // 初始化为0</span><br><span class="line">    int j;               // 未初始化，j值不确定</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; &quot;, &quot;;</span><br><span class="line">    cout &lt;&lt; &quot;j = &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int *p1;                // p1被初始化为0</span><br><span class="line">void main() &#123;</span><br><span class="line">    int *p2;            // p2未被初始化，值未知</span><br><span class="line">    int m;              // m未被初始化，值未知</span><br><span class="line">    f();                // 输出i = 0, j = ?, ?表示一个不确定的一个值</span><br><span class="line">    cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;    // 输出n = 0</span><br><span class="line">    cout &lt;&lt; &quot;m = &quot; &lt;&lt; m &lt;&lt; endl;    // 输出m = ?,  ?表示一个不确定的一个值</span><br><span class="line">    if (p1)</span><br><span class="line">        cout &lt;&lt; &quot;p1 = &quot; &lt;&lt; p1 &lt;&lt; endl;    // p1 = 0, 无输出</span><br><span class="line">    if (p2)</span><br><span class="line">        cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2 &lt;&lt; endl;    // 输出p2 = ?, ?表示不确定地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;综上所述，最好对变量初始化，以免局部变量的不确定值引起程序错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;C++的作用域大致可以分为&lt;font color=&quot;#609090&quot;&gt;&lt;code&gt;全局作用域&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="C++" scheme="http://Cbaibai.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://Cbaibai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++常量</title>
    <link href="http://Cbaibai.com/2018/12/07/C++%E5%B8%B8%E9%87%8F/"/>
    <id>http://Cbaibai.com/2018/12/07/C++常量/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2018-12-07T11:35:04.452Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常量的定义</strong></p><p>在C++中，定义常量可以使用const或constexpr。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const char c = &apos;A&apos;;  // 常量必须在定义时进行初始化</span><br><span class="line">int i, j = 10;</span><br><span class="line">const int k = i + j + 5;   // 表达式可以用来初始化常量</span><br><span class="line"></span><br><span class="line">/* constexpr与const基本类似，</span><br><span class="line">但constexpr常量必须在编译时就被初始化，</span><br><span class="line">而const常量可以延迟到运行时被初始化</span><br><span class="line">*/</span><br><span class="line">const int n = f();</span><br><span class="line">constexpr int num = f();   // error,编译时不知道f()的返回值</span><br><span class="line">constexpr int t = j + 10;  // error,j是变量,编译时还不知道j的值</span><br><span class="line"></span><br><span class="line">int f() &#123;</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>const与指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 指针实际上可以看作是两部分，对象的地址和所指向对象的值 */</span><br><span class="line">/*</span><br><span class="line">    =&gt; 底层const：</span><br><span class="line">      const type *p1;   // *p1不可变(该内存处存储的变量不可变)，p1可变</span><br><span class="line">    =&gt; 顶层const：</span><br><span class="line">      type *const p2;   // p2不可变(始终指向同一块内存),*p2可变</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *const p0;    // error,p0未初始化</span><br><span class="line">    char *const p1 = &quot;dukang&quot;;</span><br><span class="line">    char const *p2;</span><br><span class="line">    const char *p3 = &quot;dukang&quot;;</span><br><span class="line">    const char *const p4 = &quot;dukang&quot;;</span><br><span class="line">    const char *const p5;   // error,p5是常量，必须初始化</span><br><span class="line">    p1 = &quot;wankang&quot;;         // error,p1是常量，不可变更</span><br><span class="line">    p2 = &quot;wankang&quot;;</span><br><span class="line">    p3 = &quot;wankang&quot;;</span><br><span class="line">    p4 = &quot;wankang&quot;;         // error,p4是常量，不可变更</span><br><span class="line">    p1[0] = &apos;w&apos;;</span><br><span class="line">    p2[0] = &apos;w&apos;;            // error,*p2是常量</span><br><span class="line">    p3[0] = &apos;w&apos;;            // error,*p3是常量</span><br><span class="line">    p4[0] = &apos;w&apos;;            // error,*p4是常量</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const与引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 9;</span><br><span class="line">int &amp;rr = i;</span><br><span class="line">const int &amp;ri = i;</span><br><span class="line">rr = 8;</span><br><span class="line">ri = 7;    // error,ri是常量，不允许通过它来修改i的值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">const double &amp;ff = 10.0;  // 常量引用可以用常量初始化</span><br><span class="line">// 等价于 double temp = 10.0;const double &amp;ff = temp</span><br><span class="line">const int &amp;ri = i + 10;</span><br><span class="line">int &amp;ii = 3;   // error,非常量引用不能用常量初始化</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;常量的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在C++中，定义常量可以使用const或constexpr。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="C++" scheme="http://Cbaibai.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://Cbaibai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>文件的读写</title>
    <link href="http://Cbaibai.com/2018/12/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>http://Cbaibai.com/2018/12/07/文件输入与输出/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2018-12-07T11:38:19.500Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;程序与文件的数据交换方法同它与标准输入/输出设配的数据交换方法相同。从文件读取数据与从键盘输入数据的方法相似，将数据写入文件与将数据输出到显示器的方法相似。但<code>iostream</code>中定义的数据类型和函数只能用于标准输入/输出设配的数据处理。C++将处理文件的数据类型放在了头文件<code>fstream</code>里，分为<code>ofstream</code>和<code>ifstream</code>。<br><br>文件流操作一般包括五个步骤:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;1&gt; 包含头文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;2&gt; 定义文件流句柄file_handler */</span></span><br><span class="line">ifstream inData;</span><br><span class="line">ofstream outData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;3&gt; 将文件流句柄与磁盘文件filename关联起来 */</span></span><br><span class="line">file_handler.open(filename, mode)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    打开或建立文件的模式mode的可选值:</span></span><br><span class="line"><span class="comment">    ios::in            // 打开输入文件，ifstream类型变量的默认方式</span></span><br><span class="line"><span class="comment">    ios::out           // 建立输出文件，ofstream类型变量的默认方式</span></span><br><span class="line"><span class="comment">    ios::app           // 增加方式，若文件存在，将在文件尾增加数据，否则就建立文件</span></span><br><span class="line"><span class="comment">    ios::trunk         // 若文件存在，则文件中已有内容将被清除</span></span><br><span class="line"><span class="comment">    ios::nocreate      // 若文件不存在，则打开操作失败</span></span><br><span class="line"><span class="comment">    ios::noreplace     // 若文件存在，则打开操作失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 打开一个文件:</span></span><br><span class="line"><span class="comment">    ofstream outData;</span></span><br><span class="line"><span class="comment">    outData.open("abc.txt", ios:in);</span></span><br><span class="line"><span class="comment">或将&lt;2&gt;,&lt;3&gt;合为一步:</span></span><br><span class="line"><span class="comment">    ofstream outData("abc.txt", ios::in)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;4&gt; 用文件流(&lt;&lt;或&gt;&gt;)操作文件，读/写文件数据，将输入文件流与&gt;&gt;连接，就能够从文件中读入数据，与cin用法相同。将输出文件流与&lt;&lt;连接，就能够从文件中读入数据，与cout用法相同。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;5&gt; 关闭文件 */</span></span><br><span class="line">inData.close();</span><br><span class="line">ourData.close();</span><br></pre></td></tr></table></figure></p><p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    ofstream outData(&quot;C:\\data.txt&quot;);    // 前一个 / 用于转义</span><br><span class="line">    ifstream inData;</span><br><span class="line">    int x, a[10];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        outData &lt;&lt; x &lt;&lt; &quot; &quot;;  // 将x的值写入文件流句柄outData指向的文件data.txt中</span><br><span class="line">    &#125;</span><br><span class="line">    outData.close();</span><br><span class="line">    inData.open(&quot;D:\\data.txt&quot;);</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(!inData.eof())</span><br><span class="line">        inData &gt;&gt; a[j++];   // 将data.txt中的数据载入数组a[]中</span><br><span class="line">    inData.close();</span><br><span class="line">    int s = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;the sum is: &quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;程序与文件的数据交换方法同它与标准输入/输出设配的数据交换方法相同。从文件读取数据与从键盘输入数据的方法相似，将数据写入文件与将数据输出到显示器的方法相似。但&lt;code&gt;iostream&lt;/code&gt;中定义的数据类型和函数只能用于标准输入/输出设配的
      
    
    </summary>
    
      <category term="C++" scheme="http://Cbaibai.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://Cbaibai.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++引用</title>
    <link href="http://Cbaibai.com/2018/12/07/C++%E5%BC%95%E7%94%A8/"/>
    <id>http://Cbaibai.com/2018/12/07/C++引用/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2018-12-07T11:37:44.554Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    int i = 9;</span><br><span class="line">    int &amp;ri = i;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">    ri = 20;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">    i = 12;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;i 的地址是：&quot; &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ri 的地址是：&quot; &lt;&lt; &amp;ri &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果：</span><br><span class="line">    i = 9    ri = 9</span><br><span class="line">    i = 20    ri = 20</span><br><span class="line">    i = 12    ri = 12</span><br><span class="line">    i 的地址是： 0029FDB0</span><br><span class="line">    ri 的地址是： 0029FDB0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>可以看到，ri和i指的实际上是同一个变量(内存地址)，对ri的操作实际上就是对i的操作，ri可以看做是i的别名。<br><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/ff61098393b04a6e0be38516cd6422dc/25835" alt=""><br><i>使用引用时需要注意以下几个问题：</i><br><br>&emsp;&emsp;① 在定义引用时，&amp;在类型与引用名之间的位置是灵活的，故以下几种定义完全等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp; ri = i;    int &amp; ri = i;    int &amp;ri = i;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;② 在变量声明时出现的&amp;才是引用运算符(包括函数参数声明和函数返回类型的声明)，其它地方出现的&amp;则是地址操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int &amp;r = i;     // 引用</span><br><span class="line">int&amp; f(int &amp;i1, int &amp;);     // 引用参数(声明参数变量)</span><br><span class="line">int *p = &amp;i;    // &amp;取i的地址</span><br><span class="line">cout &lt;&lt; &amp;p;     // &amp;取p的地址</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;③ 引用必须在定义时初始化，不能在定义完成后再给它赋值<b>;</b>为引用提供的初始值可以是一个变量名，也可以是另一个引用名，也可以是另一个引用名<b>;</b>同一个变量可以定义多个引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float f;</span><br><span class="line">float &amp;fr;   // error,引用定义时未初始化</span><br><span class="line">float &amp;r1 = f;   // r1 &lt;=&gt; f</span><br><span class="line">float &amp;r2 = f;   // r2 &lt;=&gt; f</span><br><span class="line">float &amp;r3 = r1;  // r3 &lt;=&gt; r1 &lt;=&gt; f</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;④引用对应着变量的左值，代表变量的内存区域，实际是一种隐式指针，但与指针存在区别。<br><br>&emsp;&emsp;引用与指针的区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    int i = 9;</span><br><span class="line">    int *pi = &amp;i;   // 取地址</span><br><span class="line">    int &amp;ri = i;    // 定义引用</span><br><span class="line">    *pi = 2;</span><br><span class="line">    ri = 8;         // ri等价于*pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/29a08d9b1efd597d0cd30813de70e334/25021" alt=""></p><p>可以看到，引用本质上也是指针的一种隐式封装，即将*pi简化为ri。但它与指针至少存在两点区别：</p><ul><li>指针必须通过解引用运算符”*”才能访问它所指向的内存单元，而引用则与普通变量的访问方法差不多;</li><li>指针是一个变量，它有自己独立的内存区域，可以对它重新赋值，让它指向其他地址。但引用只是某个变量的别名，甚至没有自己独立的内存区域，必须在定义时进行初始化，并且一经定义就再也不能作为其他变量的引用了。</li></ul><p>&emsp;&emsp;⑤ 当用&amp;运算符获取一个引用的地址时，实际取出的是引用对应的变量的地址。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ri = i;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ri;   <span class="comment">// pi的值实际上是i(ri是i的别名引用)的地址</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;⑥ 建立引用时，引用应当类型匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double d;</span><br><span class="line">int &amp;rd = d;   // 引用类型与它对应的变量类型不匹配</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;⑦ 引用与数组。可以建立数组或数组元素的引用，但不能建立引用数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;, *b[10];</span><br><span class="line">int (&amp;ra)[10] = a;   // ra是具有10个元素的整型数组的引用</span><br><span class="line">int &amp;aa = a[0];      // 数组元素的引用</span><br><span class="line">int *(&amp;rpa)[10] = b; // rpa是具有10个整型指针的数组的引用</span><br><span class="line">int &amp;ai[10] = a;     // error,ai是引用数组(每个数组元素都是引用)，这是不允定义的</span><br><span class="line">ra[3] = 0;           // 数组引用的用法</span><br><span class="line">rpa[3] = &amp;i;         //</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;⑧ 引用与指针。可以建立指针的引用，但不能创建指向引用的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, a[10];</span><br><span class="line">int &amp;*ip = i;     // error,ip是指向引用的指针</span><br><span class="line">int *pi = &amp;i;</span><br><span class="line">int *pr = pi;     // pr是指针的引用</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="C++" scheme="http://Cbaibai.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://Cbaibai.com/tags/C/"/>
    
  </entry>
  
</feed>
