<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>摆摆笔记</title>
  
  <subtitle>书写，是对思维的缓存！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://baibainote.pro/"/>
  <updated>2020-03-15T07:35:06.062Z</updated>
  <id>https://baibainote.pro/</id>
  
  <author>
    <name>Cbaibai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV的GUI特性</title>
    <link href="https://baibainote.pro/2020/03/15/OpenCV%E7%9A%84GUI%E7%89%B9%E6%80%A7/"/>
    <id>https://baibainote.pro/2020/03/15/OpenCV的GUI特性/</id>
    <published>2020-03-15T07:35:06.058Z</published>
    <updated>2020-03-15T07:35:06.062Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1="" id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片<h2 id="读入和显示图像"><a href="#读入和显示图像" class="headerlink" title="读入和显示图像"></a>读入和显示图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>,<span class="number">0</span>)  <span class="comment"># OpenCV3中使用imread()读入图像</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)         <span class="comment"># 使用imshow()显示图片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>cv2.waitKey()</code>是一个键盘绑定函数，它表示在特定的几毫秒之内，如果按下任意键，这个函数会返回按键的ASCII码值，程序将会继续运行。如果没有键盘输入，返回值为-1，如果我们设置这个函数的参数为0，那它将会无限期的等待键盘输入。它也可以被用来检测特定键是否被按下，例如按键a是否被按下。<br><br>&emsp;&emsp;<code>cv2.destroyAllWindows()</code>可以轻易删除任何我们建立的窗口。如果<br>你想删除特定的窗口可以使用cv2.destroyWindow()，在括号内输入你想删除的窗口名即可。</p><p><a href="WEBRESOURCE9abadf62e509d0b9e91aa3c6f7d17373" title="image.png" class="gallery-item"><img src="WEBRESOURCE9abadf62e509d0b9e91aa3c6f7d17373" alt="image.png"></a></p><p>&emsp;&emsp;另外，还有一种方法也可以显示图像，就是先创建一个窗口， 之后<br>再加载图像。这种情况下，你可以决定窗口是否可以调整大小。要使用到的函数是<code>cv2.namedWindow()</code>。<br><br>&emsp;&emsp;<code>cv2.namedWindow()</code>的窗口可调节参数默认是cv2.WINDOW_AUTOSIZE。但是如果你把标签改成cv2.WINDOW_NORMAL，就可以调整窗口大小了。当图像维度太大，或者要添加轨迹条控制参数时，调整窗口大小将会很有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE7240417996b30eb8577efab7666d1acc" title="image.png" class="gallery-item"><img src="WEBRESOURCE7240417996b30eb8577efab7666d1acc" alt="image.png"></a></p><h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><p>将图像写入某个文件中，要使用<code>imwrite()</code>函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'new.jpg'</span>,img)  <span class="comment"># 写入图像</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h2 id="使用waitKey-获取键盘输入"><a href="#使用waitKey-获取键盘输入" class="headerlink" title="使用waitKey()获取键盘输入"></a>使用waitKey()获取键盘输入</h2><p>前面提到过，可以使用waitKey()得到键盘输入，从而进行一些操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">k = cv2.waitKey(<span class="number">0</span>)     <span class="comment"># 从屏幕读入键盘输入，返回该键对应的ASCII码</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">27</span>:            <span class="comment"># 'ESC'键的ASCII码为27</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>):    <span class="comment"># 如果输入的是's'键</span></span><br><span class="line">    cv2.imwrite(<span class="string">'messigray.png'</span>,img)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCEd91ddfe7b3f329d9d90935c333861911" title="image.png" class="gallery-item"><img src="WEBRESOURCEd91ddfe7b3f329d9d90935c333861911" alt="image.png"></a></p><h2 id="使用matplotlib"><a href="#使用matplotlib" class="headerlink" title="使用matplotlib"></a>使用matplotlib</h2><p>opencv-python还可以同matplotlib一起协同使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">plt.imshow(img, cmap = <span class="string">'gray'</span>, interpolation = <span class="string">'bicubic'</span>) <span class="comment"># 设置颜色映射为灰度图，插值方式为双三次插值</span></span><br><span class="line">plt.xticks([]), plt.yticks([])  <span class="comment"># 不给x和Y轴指定刻度值(不显示刻度)</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCEdd40c10b3226f5a17742b45d46ec59e3" title="image.png" class="gallery-item"><img src="WEBRESOURCEdd40c10b3226f5a17742b45d46ec59e3" alt="image.png"></a></p><div style="border: 1px solid #ddd;padding: 5px;"><br><div style="background-color:#906060;padding:4px;border-radius:5px;color:white;text-align:center">注意</div><br>&emsp;&emsp;彩色图像使用OpenCV 加载时是BGR 模式。但是Matplotib 是RGB模式。所以彩色图像如果已经被OpenCV 读取，那它将不会被Matplotib 正确显示。<br></div><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="用摄像头捕获视频"><a href="#用摄像头捕获视频" class="headerlink" title="用摄像头捕获视频"></a>用摄像头捕获视频</h2><p>&emsp;&emsp;为了获取视频，需要创建一个VideoCapture 对象。它的参数可以是设备的索引号，或者是一个视频文件。<br><br>&emsp;&emsp;设备索引号就是指定要使用的摄像头。一般的笔记本电脑都有内置摄像头，所以参数就是0。你可以通过设置成1 或者其他的来选择别的摄像头。之后，你就可以一帧一帧的捕获视频了。但是最<br>后，别忘了停止捕获视频。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)     <span class="comment"># 使用电脑默认的摄像头生成VideoCapture对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</span><br><span class="line">    <span class="comment"># 一帧一帧的捕获图像</span></span><br><span class="line">    ret, frame = cap.read()    <span class="comment"># 调用cv2.VideoCapture对象的read()方法来逐帧读取图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每一帧图像都施加[GRB =&gt; GRAY]也就是彩色图转换为灰度图</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示每一帧图像</span></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,gray)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获完毕后，释放摄像头</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE02466fed456f9f063a94a71c88c06be4" title="image.png" class="gallery-item"><img src="WEBRESOURCE02466fed456f9f063a94a71c88c06be4" alt="image.png"></a></p><p>&emsp;&emsp;cap.read() 返回一个布尔值（True/False）。如果要读取的帧存在，<br>就是True。因此最后你可以通过检查他的返回值来查看视频文件是否已经到<br>了结尾。<br><br>&emsp;&emsp;有时候cap可能不能成功的初始化摄像头设备，这种情况下上述代码会报错。这时可以使用cap.isOpened()来检查是否初始化成功，如果返回值是True，就表明没有问题。否则就要使用函数cap.open()。</p><p>&emsp;&emsp;另外，也可以使用函数cap.get(propId) 来获得视频的一些参数信息。这里的propId可以是0到18 之间的任何整数。每一个数代表视频的一个属性，数字所代表的摄像头属性见<br>下表:<br><a href="WEBRESOURCE63333b52cabc20bd977fee5562547154" title="image.png" class="gallery-item"><img src="WEBRESOURCE63333b52cabc20bd977fee5562547154" alt="image.png"></a></p><p>&emsp;&emsp;其中一些值可以通过cap.set(propId,value) 来修改。例如，我可以使用cap.get(3) 和cap.get(4) 来查看每一帧的宽和高。<br>默认情况下得到的值是640X480。但是我可以使用ret=cap.set(3,320)<br>和ret=cap.set(4,240) 来把宽和高改成320X240。</p><h2 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h2><p>&emsp;&emsp;从文件中播放视频与从摄像头中捕获一样，你只需要把设备索引号改成视频文件的名字即可。在播放每一帧时，使用cv2.waiKey()设置适当的持续时间。如果设置的太低视频就会播放的非常快，如果设置的太高就会播放的很慢（可以使用这种方法控制视频的播放速度）。通常情况下25 毫秒就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)    <span class="comment"># 从文件中播放视频也要初始化VideoCapture对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编/解码器</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'XVID'</span>)    <span class="comment"># 在windows平台下使用DIVX编码模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建VideoWriter对象将图像信息写入视频文件</span></span><br><span class="line">out = cv2.VideoWriter(<span class="string">'output.avi'</span>,fourcc, <span class="number">20.0</span>, (<span class="number">640</span>,<span class="number">480</span>))  <span class="comment"># 播放频率为20.0，每一帧大小应为640*480</span></span><br><span class="line"><span class="comment"># Video(filename, codec_format, play_frequency, frame_size, isColor)，isColor标签如果是True则每一帧是彩色图，否则是灰度图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):       <span class="comment"># 如果设备初始化成功</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line"><span class="keyword">if</span> ret==<span class="keyword">True</span>:</span><br><span class="line">    frame = cv2.flip(frame, <span class="number">0</span>) <span class="comment"># 图像翻转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将帧写入文件中</span></span><br><span class="line">out.write(frame)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放VideoCapture和VideoWriter对象</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FourCC 就是一个4 字节码，用来确定视频的编码格式。可用的编码列表<br>可以从 fourcc.org 查到。</p><h1 id="OpenCV中的绘图函数"><a href="#OpenCV中的绘图函数" class="headerlink" title="OpenCV中的绘图函数"></a>OpenCV中的绘图函数</h1><p>&emsp;&emsp;OpenCV中的绘图函数，常用的有：cv2.line()，cv2.circle()，cv2.rectangle()，<br>cv2.ellipse()，cv2.putText()等。这些函数都需要设置下面这些参数：</p><ul><li><strong>img</strong>：你想要绘制图形的那幅图像的文件句柄。</li><li><strong>color</strong>：形状的颜色。以RGB为例，需要传入一个元组，例如：（255,0,0）代表蓝色。对于灰度图则只需要传入灰度值。</li><li><strong>thickness</strong>：线条的粗细。如果给一个闭合图形设置为-1，那么这个图形就会被填充。默认值是1。</li><li><strong>linetype</strong>：线条的样式，端点连接方式，是否抗锯齿等。默认情况是连接方式。cv2.LINE_AA为抗锯齿，这样看起来会非常平滑。</li></ul><h2 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定像素点创建一张黑色的图作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画5px粗的蓝色斜线line(img, start, end, color, thickness)</span></span><br><span class="line">cv2.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>,img)  <span class="comment"># 写入图像</span></span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE3850ac3b21f0def1ba33027464e68400" title="image.png" class="gallery-item"><img src="WEBRESOURCE3850ac3b21f0def1ba33027464e68400" alt="image.png"></a></p><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定像素点创建一张黑色的图作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (img, lefttop_coord，rightbittom_coord，color， thickness)</span></span><br><span class="line">cv2.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>,img)  <span class="comment"># 写入图像</span></span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEa8b7285eba1daca6d15e7fddb2820258" title="image.png" class="gallery-item"><img src="WEBRESOURCEa8b7285eba1daca6d15e7fddb2820258" alt="image.png"></a></p><h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定像素点创建一张黑色的图作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (img, center，r，color，thickness)</span></span><br><span class="line">cv2.circle(img,(<span class="number">447</span>,<span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">-1</span>)    <span class="comment"># 闭合图形的粗细为-1表示填充</span></span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>,img)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEea78c6179f36cde0141c9e7975263e68" title="image.png" class="gallery-item"><img src="WEBRESOURCEea78c6179f36cde0141c9e7975263e68" alt="image.png"></a></p><h2 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定像素点创建一张黑色的图作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (img, (cx, cy), (rx, ry), rotate, (startAngle, endAnge), color[BGR], thickness)</span></span><br><span class="line">cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">180</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">22</span>),<span class="number">-1</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>,img)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE3049e4b4652c525f131868d7a800ac94" title="image.png" class="gallery-item"><img src="WEBRESOURCE3049e4b4652c525f131868d7a800ac94" alt="image.png"></a></p><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定像素点创建一张黑色的图作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定画多边形所需要的关键点</span></span><br><span class="line">points=np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">points=pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># (img, [point_lst], isClosepath, color, thickness)</span></span><br><span class="line">cv2.polylines(img,[points],<span class="keyword">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">33</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>,img)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE6116dfb069ff50371f6dd8d74890af5c" title="image.png" class="gallery-item"><img src="WEBRESOURCE6116dfb069ff50371f6dd8d74890af5c" alt="image.png"></a></p><h2 id="在图片上添加文字"><a href="#在图片上添加文字" class="headerlink" title="在图片上添加文字"></a>在图片上添加文字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定像素点创建一张黑色的图作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (img, text, position, fontFamily, fontsize color, thickness)</span></span><br><span class="line">font=cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv2.putText(img, <span class="string">'studyOpenCV'</span>, (<span class="number">20</span>,<span class="number">250</span>), font, <span class="number">2</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>,img)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE1337de1f5bc1a55b1150a59155d8dfa9" title="image.png" class="gallery-item"><img src="WEBRESOURCE1337de1f5bc1a55b1150a59155d8dfa9" alt="image.png"></a></p><h1 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h1><p>查看OpenCV中支持的鼠标事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">events=[i for i in dir(cv2) if &apos;EVENT&apos;in i]</span><br><span class="line">print(events)</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE0c1d35319dd3e94d7fd7ea4f924e4a84" title="image.png" class="gallery-item"><img src="WEBRESOURCE0c1d35319dd3e94d7fd7ea4f924e4a84" alt="image.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用鼠标做画笔(这个有点类似processing中的鼠标画笔)</span></span><br><span class="line"><span class="comment"># 与鼠标事件绑定后，特定鼠标事件被激发后，相应的信息如event对象，鼠标坐标x,y等都会作为参数传给这个鼠标事件的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags=<span class="number">0</span>,param=&#123;&#125;)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event==cv2.EVENT_LBUTTONDBLCLK:   <span class="comment"># 鼠标左键单击</span></span><br><span class="line">        cv2.circle(img,(x,y),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建背景图像与窗口，并将窗口与回调函数绑定</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)    <span class="comment"># 绑定鼠标回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>) == <span class="number">27</span>:    <span class="comment"># 按下'ESC'时关闭</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEf2ee1a507645f9d59276ebe13e3a1335" title="image" class="gallery-item"><img src="WEBRESOURCEf2ee1a507645f9d59276ebe13e3a1335" alt="image"></a></p><h1 id="使用滑动条"><a href="#使用滑动条" class="headerlink" title="使用滑动条"></a>使用滑动条</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一副黑色图像作为背景</span></span><br><span class="line">img=np.zeros((<span class="number">200</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line">cv2.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)    <span class="comment"># 创建滑动条，滑动条标识符'R'，值的变化区间在[0-255]，滑动条的值每次改变都会调用函数nothing()</span></span><br><span class="line">cv2.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"></span><br><span class="line">switch=<span class="string">'0:OFF\n1:ON'</span></span><br><span class="line">cv2.createTrackbar(switch,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)   <span class="comment"># 创建图像开关滑动条，只有0，1两个选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):   <span class="comment"># 时刻检查滑动条的值来更新图像的RGB值</span></span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)    <span class="comment"># 显示图像</span></span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    r=cv2.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)   <span class="comment"># 从标识符为'R'的滑动条中取得值</span></span><br><span class="line">    g=cv2.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">    b=cv2.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">    s=cv2.getTrackbarPos(switch,<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s==<span class="number">0</span>:</span><br><span class="line">        img[:]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:]=[b,g,r]    <span class="comment"># 图像的RGB像素更新为各滑动条中的值</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE84519f19ad5b7eeaf43bc0defa67882e" title="image" class="gallery-item"><img src="WEBRESOURCE84519f19ad5b7eeaf43bc0defa67882e" alt="image"></a></p><p>使用滑动条和鼠标事件来实现一个更复杂的效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当鼠标按下时变为True</span></span><br><span class="line">drawing=<span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果mode 为true 就绘制矩形。按下'm'则变成绘制曲线。</span></span><br><span class="line">mode=<span class="keyword">True</span></span><br><span class="line">ix,iy=<span class="number">-1</span>,<span class="number">-1</span><span class="comment"># 要绘制的矩形左上角的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span><br><span class="line">    r=cv2.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)   <span class="comment"># 获取滑动条的值</span></span><br><span class="line">    g=cv2.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">    b=cv2.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">    color=(b,g,r)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode    <span class="comment"># 在该函数内允许使用全局变量ix,iy,drawing,mode(这种语法有点类似PHP中的全局变量语法)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> event==cv2.EVENT_LBUTTONDOWN:    <span class="comment"># 当按下左键时返回起始位置坐标</span></span><br><span class="line">        drawing=<span class="keyword">True</span></span><br><span class="line">        ix,iy=x,y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当鼠标左键按下并移动时绘制图形。由event参数可得是否移动，由flag可得鼠标是否按下</span></span><br><span class="line">    <span class="keyword">elif</span> event==cv2.EVENT_MOUSEMOVE <span class="keyword">and</span> flags==cv2.EVENT_FLAG_LBUTTON:</span><br><span class="line">        <span class="keyword">if</span> drawing==<span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> mode==<span class="keyword">True</span>:</span><br><span class="line">                cv2.rectangle(img,(ix,iy),(x,y),color,<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 绘制圆圈，小圆点连在一起成了线，3 代表了笔画的粗细</span></span><br><span class="line">            cv2.circle(img,(x,y),<span class="number">3</span>,color,<span class="number">-1</span>)     <span class="comment"># 当鼠标松开停止绘画</span></span><br><span class="line">    <span class="keyword">elif</span> event==cv2.EVENT_LBUTTONUP:</span><br><span class="line">        drawing==<span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> mode==<span class="keyword">True</span>:</span><br><span class="line">          cv2.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          cv2.circle(img,(x,y),<span class="number">5</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># img是一个由全[0,0,0]组成的三维数组，在这里表示每一像素点的颜色值</span></span><br><span class="line">img=np.zeros((<span class="number">200</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)    <span class="comment"># 绑定鼠标回调事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> k==ord(<span class="string">'m'</span>):</span><br><span class="line">        mode=<span class="keyword">not</span> mode    <span class="comment"># 取反</span></span><br><span class="line">    <span class="keyword">elif</span> k==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE29b2a1435f34fed5a5344f08b5c35a71" title="image" class="gallery-item"><img src="WEBRESOURCE29b2a1435f34fed5a5344f08b5c35a71" alt="image"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="Python" scheme="https://baibainote.pro/categories/Python/"/>
    
    
      <category term="opencv-python" scheme="https://baibainote.pro/tags/opencv-python/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV核心操作</title>
    <link href="https://baibainote.pro/2020/03/15/OpenCV%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C/"/>
    <id>https://baibainote.pro/2020/03/15/OpenCV核心操作/</id>
    <published>2020-03-15T07:35:06.057Z</published>
    <updated>2020-03-15T07:35:06.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <ul=""><li><a href="#图像的基本操作">图像的基本操作</a><ul><li><a href="#获取并修改像素值">获取并修改像素值</a></li><li><a href="#获取的图像的属性">获取的图像的属性</a></li><li><a href="#图像ROI">图像ROI</a></li><li><a href="#拆分和合并图像通道">拆分和合并图像通道</a></li><li><a href="#为图像括边">为图像括边</a></li></ul></li><li><a href="#图像上的算术运算">图像上的算术运算</a><ul><li><a href="#图像加法">图像加法</a></li><li><a href="#图像混合">图像混合</a></li><li><a href="#按位计算">按位计算</a></li></ul></li><li><a href="#程序性能检测及优化">程序性能检测及优化</a><ul><li><a href="#使用OpenCV检测程序效率">使用OpenCV检测程序效率</a></li><li><a href="#OpenCV中的默认优化">OpenCV 中的默认优化</a></li></ul></li><h1 id="图像的基本操作"><a href="#图像的基本操作" class="headerlink" title="图像的基本操作"></a>图像的基本操作</h1><h2 id="获取并修改像素值"><a href="#获取并修改像素值" class="headerlink" title="获取并修改像素值"></a>获取并修改像素值</h2><p>&emsp;&emsp;可以根据像素的行与列的坐标来获取它的像素值。对BGR图像而言，返回值为B，G，R 的值。对灰度图像而言，会返回它的灰度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">px = img[<span class="number">100</span>, <span class="number">100</span>]         <span class="comment"># 某一像素点的颜色BGR表示</span></span><br><span class="line">print(px)</span><br><span class="line"></span><br><span class="line">blue = img[<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>]    <span class="comment"># 某一像素点的Blue颜色分量</span></span><br><span class="line">print(blue)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE6d7baca158d17692c83b8fa28ac74cb1" title="image.png" class="gallery-item"><img src="WEBRESOURCE6d7baca158d17692c83b8fa28ac74cb1" alt="image.png"></a></p><p>当然了，也可以用这种方法更改某一点的像素值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">img[<span class="number">100</span>,<span class="number">100</span>]=[<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br><span class="line">print(img[<span class="number">100</span>,<span class="number">100</span>])</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCEbaafbcf85a3bbcb1c07459ba5591d965" title="image.png" class="gallery-item"><img src="WEBRESOURCEbaafbcf85a3bbcb1c07459ba5591d965" alt="image.png"></a></p><p>&emsp;&emsp;上面用于更改某一点的像素值的方法被用来选取矩阵的一个区域，比如说前5行的后3<br>列。对于获取每一个像素值，可以使用Numpy 的array.item() 和array.<br>itemset() 来进行遍历操作。但这两个函数的返回值都是标量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">print(img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>))<span class="comment"># 输出(10,10,2)处像素点的值</span></span><br><span class="line">img.itemset((<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>),<span class="number">100</span>)<span class="comment"># 将(10,10,2)处的值设为100</span></span><br><span class="line">print(img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE78c77e4e2caa830fd7888551f703ba49" title="image.png" class="gallery-item"><img src="WEBRESOURCE78c77e4e2caa830fd7888551f703ba49" alt="image.png"></a></p><h2 id="获取的图像的属性"><a href="#获取的图像的属性" class="headerlink" title="获取的图像的属性"></a>获取的图像的属性</h2><p>图像的属性包括：行，列，通道，图像数据类型，像素数目等。</p><p>img.shape 可以获取图像的形状。他的返回值是一个包含行数，列数，颜色通道数的元组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">print(img.shape)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果图像是灰度图，img.shape的返回值就只有行数和列数。所以通过检查这个返回值就可以知道加载的是灰度图还是彩色图。</p><p><a href="WEBRESOURCE6c2a10b16b1cf512f3fcd3bc0e6909d3" title="image.png" class="gallery-item"><img src="WEBRESOURCE6c2a10b16b1cf512f3fcd3bc0e6909d3" alt="image.png"></a></p><p>img.size 可以返回图像的像素数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">print(img.size)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE35eeffd487e7f99b153f677db84f2320" title="image.png" class="gallery-item"><img src="WEBRESOURCE35eeffd487e7f99b153f677db84f2320" alt="image.png"></a></p><p>img.dtype 返回的是图像的数据类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">print(img.dtype)</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCEb9ceeb8d12d33a23e61749d42411bdea" title="image.png" class="gallery-item"><img src="WEBRESOURCEb9ceeb8d12d33a23e61749d42411bdea" alt="image.png"></a></p><h2 id="图像ROI"><a href="#图像ROI" class="headerlink" title="图像ROI"></a>图像ROI</h2><p>&emsp;&emsp;有时我们需要对一幅图像的特定区域进行操作。例如我们要检测一副图像中眼睛的位置，我们首先应该在图像中找到脸，再在脸的区域中找眼睛，而不是直接在一幅图像中搜索眼睛。灵活的使用ROI操作会提高程序的准确性和性能。ROI 是使用Numpy 索引来获得的。</p><div style="border: 1px solid #ddd;padding:2px;"><br><div style="background-color:#906060;color:white;text-align:center;padding:5px;border-radius:5px;">注意</div><p>&emsp;&emsp;图像不存在或内容为空时不能用[ ]取出其中的像素点，会报<code>&#39;NoneType&#39; object is not subscriptable</code>这样的错误。<br></p></div><br><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ball.png'</span>)</span><br><span class="line"></span><br><span class="line">ball=img[<span class="number">280</span>:<span class="number">340</span>,<span class="number">330</span>:<span class="number">390</span>]   <span class="comment"># 框定一个矩形取出选中的像素区域</span></span><br><span class="line">img[<span class="number">273</span>:<span class="number">333</span>,<span class="number">100</span>:<span class="number">160</span>]=ball   <span class="comment"># 将拷贝得到的子图复制到图像中的另一块区域</span></span><br></pre></td></tr></table></figure><h2 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h2><p>&emsp;&emsp;有时我们需要对BGR 三个通道分别进行操作，这时就需要把BGR拆分成单个通道进行处理，可以使用<code>cv2.split()</code>。<br>也可以使用<code>cv2.merge()</code>把独立通道的图片合并成一个BGR 图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"></span><br><span class="line">b,g,r = cv2.split(img)  <span class="comment"># 将BGR图像拆分成三个通道</span></span><br><span class="line">img=cv2.merge(b,g)    <span class="comment"># 合并两个通道</span></span><br><span class="line">b=img[:,:,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>cv2.split() 是一个比较耗时的操作，只有真正需要时才用它，平时尽量使用numpy索引取像素点。</p><p><a href="WEBRESOURCEfb351b487c60d81664b9153ef11dec3a" title="image.png" class="gallery-item"><img src="WEBRESOURCEfb351b487c60d81664b9153ef11dec3a" alt="image.png"></a></p><p>&emsp;&emsp;事实上，如果我们想让图像所有像素点的红色通道值都为0的话，不用拆分通道后再对其进行操作，可以直接使用numpy索引实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line">img[:,:,<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">cv2.imwrite(<span class="string">'paint.jpg'</span>, img)</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE309363e875f4341774a11a6845e568f4" title="image.png" class="gallery-item"><img src="WEBRESOURCE309363e875f4341774a11a6845e568f4" alt="image.png"></a></p><h2 id="为图像括边"><a href="#为图像括边" class="headerlink" title="为图像括边"></a>为图像括边</h2><p>&emsp;&emsp;如果你想在图像周围创建一个边，就像相框一样，你可以使用<code>cv2.copyMakeBorder()</code>函数。这经常在卷积运算或0 填充时被用到。</p><p>这个函数所需的参数如下：<br><a href="WEBRESOURCEb24e8b77cffe46404d302ded6bce0ccb" title="image.png" class="gallery-item"><img src="WEBRESOURCEb24e8b77cffe46404d302ded6bce0ccb" alt="image.png"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">BLUE=[<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">img1=cv2.imread(<span class="string">'ball.png'</span>)</span><br><span class="line"><span class="comment"># 设置不同的括边方式</span></span><br><span class="line">replicate = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REPLICATE)   <span class="comment"># 复制源图像img1的像素值并为其进行括边</span></span><br><span class="line">reflect = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_WRAP)</span><br><span class="line">constant= cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_CONSTANT,value=BLUE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加几个子图并显示</span></span><br><span class="line">plt.subplot(<span class="number">231</span>), plt.imshow(img1,<span class="string">'gray'</span>), plt.title(<span class="string">'ORIGINAL'</span>)</span><br><span class="line">plt.subplot(<span class="number">232</span>), plt.imshow(replicate,<span class="string">'gray'</span>), plt.title(<span class="string">'REPLICATE'</span>)</span><br><span class="line">plt.subplot(<span class="number">233</span>), plt.imshow(reflect,<span class="string">'gray'</span>), plt.title(<span class="string">'REFLECT'</span>)</span><br><span class="line">plt.subplot(<span class="number">234</span>), plt.imshow(reflect101,<span class="string">'gray'</span>), plt.title(<span class="string">'REFLECT_101'</span>)</span><br><span class="line">plt.subplot(<span class="number">235</span>), plt.imshow(wrap,<span class="string">'gray'</span>), plt.title(<span class="string">'WRAP'</span>)</span><br><span class="line">plt.subplot(<span class="number">236</span>), plt.imshow(constant,<span class="string">'gray'</span>), plt.title(<span class="string">'CONSTANT'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEaf17a5ad85522974fabcf07d95c96139" title="image.png" class="gallery-item"><img src="WEBRESOURCEaf17a5ad85522974fabcf07d95c96139" alt="image.png"></a></p><h1 id="图像上的算术运算"><a href="#图像上的算术运算" class="headerlink" title="图像上的算术运算"></a>图像上的算术运算</h1><h2 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h2><p>&emsp;&emsp;可以使用函数<code>cv2.add()</code>对两幅图像进行加法运算，当然也可以直接使用numpy，即<code>res=img1+img</code>。<font color="#609090">两幅图像的大小，类型必须一致</font>，或者第二个图像是一个简单的标量值。</p><div style="border: 1px solid #ddd;padding:2px;"><br><div style="background-color:#906060;color:white;text-align:center;padding:5px;border-radius:5px;">注意</div><p>&emsp;&emsp;OpenCV 中的加法与Numpy 的加法是有所不同的。OpenCV 的加法是一种饱和操作，而Numpy 的加法是一种模操作。<br></p></div><br><p></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">x = np.uint8([<span class="number">250</span>])</span><br><span class="line">y = np.uint8([<span class="number">10</span>])</span><br><span class="line">print(cv2.add(x, y)) <span class="comment"># OpenCV图像加法，250+10 = 260 =&gt; 255</span></span><br><span class="line">print(x+y)           <span class="comment"># numpy取模加法，250+10 = 260 % 256 = 4</span></span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEae11fe265ff70931f6e24ae6cf0f583c" title="image.png" class="gallery-item"><img src="WEBRESOURCEae11fe265ff70931f6e24ae6cf0f583c" alt="image.png"></a></p><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>&emsp;&emsp;图像混合其实也是一种图像加法，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合的计算公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g(x) = (1-\alpha)f_0(x) + \alpha f_1(x)</span><br></pre></td></tr></table></figure></p><p>通过改变<code>$\alpha$</code>的值可以实现图像的平滑效果。</p><p>&emsp;&emsp;下面我们把两幅图混合在一起。第一幅图的权重是0.7，第二幅图的权重是0.3。函数<code>cv2.addWeighted()</code>可以按下面的公式对图片进行混合操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = \alpha.img1 + \beta.img2 + \gamma</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img1=cv2.imread(<span class="string">'ml.png'</span>)</span><br><span class="line">img2=cv2.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line"></span><br><span class="line">dst=cv2.addWeighted(img1,<span class="number">0.7</span>,img2,<span class="number">0.3</span>, <span class="number">0</span>)   <span class="comment"># 第一幅图的权重是0.7，第二幅图的权重是0.3</span></span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>,dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindow()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE82ac39e0bfebcc238e7fd2d46f3877bb" title="image.png" class="gallery-item"><img src="WEBRESOURCE82ac39e0bfebcc238e7fd2d46f3877bb" alt="image.png"></a></p><h2 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h2><p>&emsp;&emsp;这里包括的按位操作有：AND，OR，NOT，XOR 等。当我们提取图像的一部分，选择非矩形ROI 时这些操作会很有用</p><p>&emsp;&emsp;现在我想把OpenCV 的标志放到另一幅图像上。如果使用加法，颜色会改变，如果使用混合，会得到透明效果，但是我不想要透明。如果它是矩形那么我可以使用ROI。但事实上它不是矩形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'ball.png'</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想把logo放在img1的左上角，所以这里先创建一个ROI区域</span></span><br><span class="line">rows,cols,channels = img2.shape    <span class="comment"># 根据img2的Logo尺寸在img1上开一个ROI区域</span></span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ]</span><br><span class="line"></span><br><span class="line">img2gray = cv2.cvtColor(img2,cv2.COLOR_BGR2GRAY)    <span class="comment"># 先将彩色图转换为灰度图(图像阈值化处理的前一步骤)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像阈值化处理</span></span><br><span class="line"><span class="comment"># 创建一个图像的掩膜和它翻转后的图像的掩膜(制作掩膜的目的是保护被掩膜覆盖的区域，之后的操作将只影响掩膜之外的区域)</span></span><br><span class="line"><span class="comment"># 使用cv2.threshold()将img2gray中大于175像素的值设为0(黑色)，小于175像素的设为255(白色)，cv2.THRESH_BINARY表示采用的是二进制阈值化模式</span></span><br><span class="line">ret, mask = cv2.threshold(img2gray, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">mask_inv = cv2.bitwise_not(mask)    <span class="comment"># 对掩膜进行'按位非'操作，黑色=&gt;白色</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 剔除logo图片中ROI区域之外的像素，取roi 中与mask 中不为零的值对应的像素的值，其他值为0</span></span><br><span class="line"><span class="comment"># 注意这里必须有mask=mask 或者mask=mask_inv, 这里的mask= 参数不能缺省</span></span><br><span class="line">img1_bg = cv2.bitwise_and(roi,roi,mask = mask)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取roi 中与mask_inv 中不为零的值对应的像素的值，其他值为0。</span></span><br><span class="line">img2_fg = cv2.bitwise_and(img2,img2,mask = mask_inv)    <span class="comment"># 从logo图片img2中取出掩膜mask_inv覆盖的区域作为前景</span></span><br><span class="line"></span><br><span class="line">dst = cv2.add(img1_bg,img2_fg)     <span class="comment"># 将img1_bg背景和img2_fg前景进行图像拼接操作，生成最终将要嵌入到源图像中的图像dst</span></span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols] = dst         <span class="comment"># 改变源图像中设置了ROI的区域</span></span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'res'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'mask'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'mask_inv'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'img1_bg'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'img2_fg'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'res'</span>,img1)</span><br><span class="line">cv2.imshow(<span class="string">'mask'</span>,mask)</span><br><span class="line">cv2.imshow(<span class="string">'mask_inv'</span>,mask_inv)</span><br><span class="line">cv2.imshow(<span class="string">'img1_bg'</span>,img1_bg)</span><br><span class="line">cv2.imshow(<span class="string">'img2_fg'</span>,img2_fg)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE2b2c5076bdfeee89393610f180f302e2" title="image.png" class="gallery-item"><img src="WEBRESOURCE2b2c5076bdfeee89393610f180f302e2" alt="image.png"></a></p><h1 id="程序性能检测及优化"><a href="#程序性能检测及优化" class="headerlink" title="程序性能检测及优化"></a>程序性能检测及优化</h1><p>&emsp;&emsp;在图像处理中每秒钟都要做大量的运算，所以给出的程序不仅要能得到正确的处理结果，同时还必须要快。</p><h2 id="使用OpenCV检测程序效率"><a href="#使用OpenCV检测程序效率" class="headerlink" title="使用OpenCV检测程序效率"></a>使用OpenCV检测程序效率</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"><span class="comment"># func()   函数执行代码段</span></span><br><span class="line">e2 = cv2.getTickCount()    <span class="comment"># 返回从参考点到这个函数被执行的时钟数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (e2 - e1)得到两次调用getTickFrequency()之间的时间间隔</span></span><br><span class="line">time = (e2 - e1)/ cv2.getTickFrequency()   <span class="comment"># cv2.getTickFrequency() 是时钟频率，即每秒钟的时钟数</span></span><br></pre></td></tr></table></figure><p>看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i!=<span class="number">0</span>:</span><br><span class="line">        img1 = cv2.medianBlur(img1,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">e2 = cv2.getTickCount()</span><br><span class="line"></span><br><span class="line">t = (e2 - e1)/cv2.getTickFrequency()</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCEf44e566b70abd030966e3abf0fa293c4" title="image.png" class="gallery-item"><img src="WEBRESOURCEf44e566b70abd030966e3abf0fa293c4" alt="image.png"></a></p><h2 id="OpenCV-中的默认优化"><a href="#OpenCV-中的默认优化" class="headerlink" title="OpenCV 中的默认优化"></a>OpenCV 中的默认优化</h2><p>&emsp;&emsp;事实上，OpenCV 中的很多函数都被优化过（SSE2，AVX 等），当然也包含一些没有被优化的代码。如果我们的系统支持优化的话那自然要充分利用这一点。在编译时优化是默认开启的，因此OpenCV运行的就是优化后的代码。你可以使用函数cv2.useOptimized()来查看优化是否被开启了，如果没有开启，使用函数cv2.setUseOptimized()来开启优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">img = cv2.imread(&apos;miss.jpg&apos;, 0)</span><br><span class="line"></span><br><span class="line">cv2.useOptimized()    # 查看是否开启了优化(默认开启)</span><br><span class="line">    </span><br><span class="line"># 观察同一段程序运行的时间，直观感受优化后的效率提升</span><br><span class="line">%timeit res = cv2.medianBlur(img,49)    # 图像中值滤波</span><br><span class="line"></span><br><span class="line">cv2.setUseOptimized(False)    # 关闭优化</span><br><span class="line">cv2.useOptimized()</span><br><span class="line">    </span><br><span class="line">%timeit res = cv2.medianBlur(img,49)    # 很明显这段语句相比上面开启了优化后的语句执行时间变长了</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE4526221ecbe96ddd16e16de8efcc7f8e" title="image.png" class="gallery-item"><img src="WEBRESOURCE4526221ecbe96ddd16e16de8efcc7f8e" alt="image.png"></a></p><p>&emsp;&emsp;再来比较一下cv2.countNonZero()和np.count_nonzero()这两个函数的运行效率，可见，opencv中的函数较numpy做了更多的优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'miss.jpg'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">%timeit z = cv2.countNonZero(img)</span><br><span class="line"><span class="comment"># 4.7 µs ± 5.65 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></span><br><span class="line"></span><br><span class="line">%timeit z = np.count_nonzero(img)</span><br><span class="line"><span class="comment"># 640 ns ± 2.29 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span></span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEe0703bcdc37ff4bf97300df029fb9023" title="image.png" class="gallery-item"><img src="WEBRESOURCEe0703bcdc37ff4bf97300df029fb9023" alt="image.png"></a></p><p>程序优化注意事项：<br><a href="WEBRESOURCE0ef307208c25fd58446882e407b9d7a5" title="image.png" class="gallery-item"><img src="WEBRESOURCE0ef307208c25fd58446882e407b9d7a5" alt="image.png"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="Python" scheme="https://baibainote.pro/categories/Python/"/>
    
    
      <category term="opencv-python" scheme="https://baibainote.pro/tags/opencv-python/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中的图像处理</title>
    <link href="https://baibainote.pro/2020/03/15/OpenCV%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>https://baibainote.pro/2020/03/15/OpenCV中的图像处理/</id>
    <published>2020-03-15T07:35:06.055Z</published>
    <updated>2020-03-15T07:35:06.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h1="" id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换<h2 id="转换颜色空间"><a href="#转换颜色空间" class="headerlink" title="转换颜色空间"></a>转换颜色空间</h2><p>&emsp;&emsp;OpenCV提供了超过150 种进行颜色空间转换的方法，但是以后经常用到的其实也就两种：BGR&rarr;Gray 和BGR&rarr;HSV。进行颜色空间转换的函数是：<code>cv2.cvtColor(input_image，flag)</code>，其中flag就是要转换到的类型。</p><p>&emsp;&emsp;对于BGR&rarr;Gray 的转换，我们要使用的flag 就是cv2.COLOR_ BGR2GRAY。而对于BGR&rarr;HSV 的转换，我们用的flag 就是cv2.COLOR_BGR2HSV。</p><p>可以使用下面的程序输出opencv中支持的所有用于颜色空间转换的flag：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">flags=[i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> i.startswith(<span class="string">'COLOR_'</span>)]</span><br><span class="line">print(flags)</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE0e328e78ef5da029363c35b38d0fc051" title="image.png" class="gallery-item"><img src="WEBRESOURCE0e328e78ef5da029363c35b38d0fc051" alt="image.png"></a></p><div style="border: 1px solid #ddd;padding:2px;"><br><div style="background-color:#609090;color:white;text-align:center;padding:5px;border-radius:5px;">注意</div><p>&emsp;&emsp;在OpenCV 的HSV 格式中，H（色彩/色度）的取值范围是[0，179]，S（饱和度）的取值范围[0，255]，V（亮度）的取值范围[0，255]。但是不同软件使用的值可能不同，所以当你需要拿OpenCV 的HSV 值与其他软<br>件的HSV 值进行对比时，一定要记得归一化处理。<br></p></div><br><p></p><h2 id="物体跟踪"><a href="#物体跟踪" class="headerlink" title="物体跟踪"></a>物体跟踪</h2><p>&emsp;&emsp;我们已经知道怎样将一幅图像从BGR颜色空间转换到HSV了，这样一来，我们就可以利用这一点来提取带有某个特定颜色的物体。在HSV颜色空间中要比在BGR空间中更容易表示一个特定颜色。</p><p>在接下来的例子中我们要提取一个蓝色的物体，做下面几步操作：</p><ul><li>从视频中获取每一帧图像；</li><li>将图像转换到HSV 空间；</li><li>设置HSV 阈值到蓝色范围。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cap=cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 获取捕获到的每一帧</span></span><br><span class="line">    ret,frame=cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换到HSV颜色空间</span></span><br><span class="line">    hsv_img=cv2.cvtColor(frame,cv2.COLOR_BGR2HSV)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设定蓝色的阈值(颜色值达到什么样才判断为蓝色)</span></span><br><span class="line">    lower_blue=np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue=np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据阈值构建掩模(低于lower_blue为黑色，高于upper_blue的为白色)</span></span><br><span class="line">    mask=cv2.inRange(hsv_img,lower_blue,upper_blue)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对原图像和掩模进行按位与运算</span></span><br><span class="line">    res=cv2.bitwise_and(frame,frame,mask=mask)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示图像</span></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">    cv2.imshow(<span class="string">'mask'</span>,mask)</span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>,res)</span><br><span class="line">    k=cv2.waitKey(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> k==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 关闭窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE90bdfb92a45299da1b8d8eeae88459d6" title="image.png" class="gallery-item"><img src="WEBRESOURCE90bdfb92a45299da1b8d8eeae88459d6" alt="image.png"></a></p><p>上图掩膜中一些白色的点就是图像处理中的噪点。</p><h2 id="找到跟踪对象的HSV-值"><a href="#找到跟踪对象的HSV-值" class="headerlink" title="找到跟踪对象的HSV 值"></a>找到跟踪对象的HSV 值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能用[0,255,0]，而要用[[[0,255,0]]]</span></span><br><span class="line"><span class="comment"># 这里的三层括号应该分别对应于cvArray，cvMat，IplImage</span></span><br><span class="line">green=np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>]]])</span><br><span class="line">hsv_green=cv2.cvtColor(green,cv2.COLOR_BGR2HSV)    <span class="comment"># 绿色的HSV值</span></span><br><span class="line">print(hsv_green)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEf817a41fc9fb30078ced4506854a3886" title="image.png" class="gallery-item"><img src="WEBRESOURCEf817a41fc9fb30078ced4506854a3886" alt="image.png"></a></p><p>可见，BGR颜色空间中的绿色对应HSV的[60,255,255]。</p><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p>&emsp;&emsp;OpenCV 提供了两个变换函数，<code>cv2.warpAffine</code>和<code>cv2.warpPerspective</code>，使用这两个函数你可以实现所有类型的变换。cv2.warpAffine 接收的参数是2 <em> 3的变换矩阵，而cv2.warpPerspective 接收的参数是3 </em> 3 的变换矩阵。</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>&emsp;&emsp;扩展缩放只是改变图像的尺寸大小。OpenCV提供的函数<code>cv2,resize(src, dst, interpolation=CV_INTER_LINEAR)</code>可以实现这个功能，图像的尺寸可以自己手动设置，也可以指定缩放因子。我们可以选择使用不同的插值方法，在缩放时我们推荐使用cv2.INTER_ AREA，在扩展时我们推荐使用v2.INTER_ CUBIC（慢)和v2.INTER_ LINEAR。默认情况下所有改变图像尺寸大小的操作使用的插值方法都是cv2.INTER_LINEAR。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line"><span class="comment"># 下面的None所占的参数位置本应该是输出图像的尺寸，但是因为后边我们设置了缩放因子(fx,fy),因此这里直接写None就好</span></span><br><span class="line">res=cv2.resize(img,<span class="keyword">None</span>,fx=<span class="number">2</span>,fy=<span class="number">2</span>,interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里呢，我们直接设置输出图像的尺寸，所以不用设置缩放因子</span></span><br><span class="line">height,width=img.shape[:<span class="number">2</span>]    <span class="comment"># 得到原图像的宽高</span></span><br><span class="line">res=cv2.resize(img,(<span class="number">2</span>*width,<span class="number">2</span>*height),interpolation=cv2.INTER_CUBIC)    <span class="comment"># 对原图像放大两倍</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>,res)</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE8f91d7ece88ed49729f06b3eddda03af" title="image.png" class="gallery-item"><img src="WEBRESOURCE8f91d7ece88ed49729f06b3eddda03af" alt="image.png"></a></p><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>&emsp;&emsp;如果要使图像要沿（x，y）方向移动，移动的距离是（tx，ty），你可以以下面的方式构建移动矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M=\left[\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 0 &amp; t_x \\[8pt]</span><br><span class="line">0 &amp; 1 &amp; t_y</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p><p>可以使用Numpy 数组构建这个矩阵（数据类型是np.float32），然后把它传给函数cv2.warpAffine()即可完成平移。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>对一个图像绕图片左下角原点旋转θ角, 需要使用到下面形式的旋转矩阵:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M=\left[\begin&#123;matrix&#125;</span><br><span class="line">\cos\theta &amp; -\sin\theta \\[8pt]</span><br><span class="line">\sin\theta &amp; \cos\theta</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p><p>OpenCV支持绕任意点进行旋转的矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M=\left[\begin&#123;matrix&#125;</span><br><span class="line">\alpha &amp; \beta &amp; (1-\alpha)\cdot center\cdot x-\beta\cdot center\cdot y \\[8pt]</span><br><span class="line">-\beta &amp; \alpha &amp; \beta\cdot center\cdot x+(1-\alpha)\cdot center\cdot x</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p><p>其中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\alpha = scale\cdot \cos\theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\beta = scale\cdot \sin\theta</span><br></pre></td></tr></table></figure></p><p>为了构建这个旋转矩阵，OpenCV 提供了函数：<code>cv2.getRotationMatrix2D()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'miss.jpg'</span>,<span class="number">0</span>)</span><br><span class="line">rows,cols=img.shape    <span class="comment"># 得到图像的宽高</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (旋转中心，旋转角度，旋转后的缩放因子)</span></span><br><span class="line">M=cv2.getRotationMatrix2D((cols/<span class="number">2</span>,rows/<span class="number">2</span>),<span class="number">45</span>,<span class="number">0.6</span>)    <span class="comment"># 旋转45度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对图像img施加仿射变换M，第三个参数是输出图像的尺寸中心</span></span><br><span class="line">dst=cv2.warpAffine(img,M,(<span class="number">2</span>*cols,<span class="number">2</span>*rows))</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,dst)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>)==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEccd2f19140eb7c0cc5758e9c8127789d" title="image.png" class="gallery-item"><img src="WEBRESOURCEccd2f19140eb7c0cc5758e9c8127789d" alt="image.png"></a></p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>&emsp;&emsp;在仿射变换中，原图中所有的平行线在结果图像中同样平行(这是一种线性变换)。为了创建这个矩阵，我们需要从原图像中找到三个点以及他们在输出图像中的位置，然后利用<code>cv2.getAffineTransform()</code>创建一个2x3 的矩阵，最后这个矩阵会被传给函数<code>cv2.warpAffine()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'miss.jpg'</span>)</span><br><span class="line">rows,cols,channel=img.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选中原图像上的三个点</span></span><br><span class="line">before_points=np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line"><span class="comment"># 定义原图上那三个点在最终目标图片上的位置</span></span><br><span class="line">after_points=np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于before_points和after_points生成仿射变换矩阵</span></span><br><span class="line">M=cv2.getAffineTransform(before_points,after_points)</span><br><span class="line">dst=cv2.warpAffine(img,M,(cols,rows))    <span class="comment"># 对图像img施加定义好了的仿射变换</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEd03a91969a3a028c2d1e4b6b1784e6ac" title="image.png" class="gallery-item"><img src="WEBRESOURCEd03a91969a3a028c2d1e4b6b1784e6ac" alt="image.png"></a></p><p><a href="WEBRESOURCE618f5289a7f26d3e61233f3ec9f58b3d" title="image.png" class="gallery-item"><img src="WEBRESOURCE618f5289a7f26d3e61233f3ec9f58b3d" alt="image.png"></a></p><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>&emsp;&emsp;对于透视变换，我们需要一个 3x3 的变换矩阵。变换前后直线还是直线。<br><br>&emsp;&emsp;要构建这个变换矩阵，你需要在输入图像上找4个点，并指定它们在输出图像上对应的位置。这四个点中的任意三个都不能共线。这个变换矩阵可以用函数<code>cv2.getPerspectiveTransform()</code>构建。然后把这个矩阵传给函数<code>cv2.warpPerspective()</code>来对源图像进行透视变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'ball.png'</span>)</span><br><span class="line">rows,cols,ch=img.shape</span><br><span class="line"></span><br><span class="line">before_points = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">after_points = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">M=cv2.getPerspectiveTransform(before_points,after_points)</span><br><span class="line">dst=cv2.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE961f93fa82ae6dc52577d56ed0217d0d" title="image.png" class="gallery-item"><img src="WEBRESOURCE961f93fa82ae6dc52577d56ed0217d0d" alt="image.png"></a></p><h1 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h1><h2 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h2><p>&emsp;&emsp;使用<code>cv2.threshhold()</code>进行简单阈值处理，像素值高于阈值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。因为这个函数接受的是灰度图，所以像素值其实就是图像的亮度。<br><br>&emsp;&emsp;这个函数的第一个参数就是原图像，<font color="#906060">原图像应该是灰度图(不是灰度图则转换为灰度图)</font>；第二个参数就是用来对像素值进行分类的阈值；第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值。</p><p>OpenCV提供了多种不同的阈值方法，这是由第四个参数来决定的。这些方法包括：</p><ul><li>cv2.THRESH_BINARY</li><li>cv2.THRESH_BINARY_INV</li><li>cv2.THRESH_TRUNC</li><li>cv2.THRESH_TOZERO</li><li>cv2.THRESH_TOZERO_INV</li></ul><p><a href="WEBRESOURCEc6d9383d0a0ca8cfcd1c04b02c6f83ff" title="image.png" class="gallery-item"><img src="WEBRESOURCEc6d9383d0a0ca8cfcd1c04b02c6f83ff" alt="image.png"></a></p><p><code>cv2.threshhold()</code>有两个返回值，第一个为retVal，第二个就是阈值化处理之后的结果图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">'gradient.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对源图像进行各种类型的阈值化处理</span></span><br><span class="line">ret,thresh1=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)    <span class="comment"># 高于127时赋值为255(白色)，低于127时赋值为0(黑色)</span></span><br><span class="line">ret,thresh2=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">ret,thresh4=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">ret,thresh5=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])    <span class="comment"># 隐藏子图的刻度</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEacd847f77772f568707c528caf2ee05d" title="image.png" class="gallery-item"><img src="WEBRESOURCEacd847f77772f568707c528caf2ee05d" alt="image.png"></a></p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>&emsp;&emsp;前面所说的简单阈值其实是全局阈值，即整幅图像采用同一个数作为阈值。但这种方法显然并不适合于所有情况，尤其是当同一幅图像上的不同部分具有不同亮度时。这种情况下我们就需要采用自适应阈值。<br><br>&emsp;&emsp;此时的阈值是根据图像上的每一个小区域计算与其对应的阈值。因此在同一幅图像上的不同区域采用的实际上是不同的阈值，从而使我们能在图像各部分亮度差异很大的情况下得到更好的结果。</p><p>下面的程序展示了简单阈值和自适应阈值的区别：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'dave.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波(除噪点)</span></span><br><span class="line">img = cv2.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 这里是简单阈值</span></span><br><span class="line">ret,th1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cv2.adaptiveThreshold()开启自适应阈值，分别使用两种计算阈值的方法：</span></span><br><span class="line"><span class="comment"># ADAPTIVE_THRESH_MEAN_C阈值取自相邻区域的平均值 和 </span></span><br><span class="line"><span class="comment"># ADAPTIVE_THRESH_GAUSSIAN_C阈值取值相邻区域的加权和，权重为一个高斯窗口</span></span><br><span class="line">th2 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 11 为邻域大小Block size(用来计算阈值的区域大小), 2 为C 值(一个常数，阈值就等于的平均值或者加权平均值减去这个常数)</span></span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Image'</span>, <span class="string">'Global Thresholding (v = 127)'</span>, <span class="string">'Adaptive Mean Thresholding'</span>, <span class="string">'Adaptive Gaussian Thresholding'</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE6f6d04f3d8979190b2cb172fb60e9a6c" title="image.png" class="gallery-item"><img src="WEBRESOURCE6f6d04f3d8979190b2cb172fb60e9a6c" alt="image.png"></a></p><h2 id="Otsu’s-二值化"><a href="#Otsu’s-二值化" class="headerlink" title="Otsu’s 二值化"></a>Otsu’s 二值化</h2><p>&emsp;&emsp;前面提到的<code>cv2.threshold()</code>的第一个返回值retVal，当我们使用 Otsu’s 二值化时就会用到它。</p><p>&emsp;&emsp;在使用全局(简单)阈值时，我们就是随便给了一个数来做阈值，那我们怎么知道我们选取的这个数的好坏呢？答案就是不停的尝试。如果是一副双峰图像（双峰图像是指图像直方图中存在两个峰）呢？我们岂不是应该在两个峰之间的峰谷选一个值作为阈值？这就是Otsu’s二值化要做的。简单来说就是对一副双峰图像自动根据其直方图计算出一个阈值。（对于非双峰图像，这种方法得到的结果可能会不理想）。</p><p>&emsp;&emsp;进行Otsu’s 二值化处理用到的函数还是<code>cv2.threshold()</code>，但是需要多传入一个参数(flag) cv2.THRESH_OTSU。这时要把阈值设为0。然后算法会自动找到最优阈值，这个最优阈值就是返回值retVal。如果不使用Otsu’s二值化即不传入后面的那个参数，<code>cv2.threshold()</code>返回的retVal值与设定的阈值相等。</p><p>&emsp;&emsp;下面的例子中，输入图像是一副带有噪声的图像。我们将使用几种方法来对其进行阈值处理，第一种方法，我们设127为全局阈值。第二种方法，直接使用Otsu二值化。第三种方法，我们首先使用一个5x5 的高斯过滤除去噪音，然后再使用Otsu二值化。这里可以看看噪音去除后对结果的影响有多大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'fingerprint.jpg'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用全局阈值</span></span><br><span class="line">ret1,th1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 直接使用Otsu's二值化</span></span><br><span class="line">ret2,th2 = cv2.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line"><span class="comment"># 高斯滤波之后再使用Otsu's二值化,（5,5）为高斯核的大小，0 为标准差</span></span><br><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv2.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)    <span class="comment"># 这里threshold()的阈值一定要设为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面画出这三种阈值处理后的目标图像和它们的直方图</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">img, <span class="number">0</span>, th2,</span><br><span class="line">blur, <span class="number">0</span>, th3]</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original Noisy Image'</span>,<span class="string">'Histogram'</span>,<span class="string">'Global Thresholding (v=127)'</span>,</span><br><span class="line"><span class="string">'Original Noisy Image'</span>,<span class="string">'Histogram'</span>,<span class="string">"Otsu's Thresholding"</span>,</span><br><span class="line"><span class="string">'Gaussian filtered Image'</span>,<span class="string">'Histogram'</span>,<span class="string">"Otsu's Thresholding"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)    <span class="comment"># 使用plt.hist(参数为一维数组)画直方图，使用array.ravel()将多维数组转换为一维</span></span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE55605a5458afbd85a2d688328a02f24e" title="image.png" class="gallery-item"><img src="WEBRESOURCE55605a5458afbd85a2d688328a02f24e" alt="image.png"></a></p><h2 id="Otsu’s-二值化的工作原理"><a href="#Otsu’s-二值化的工作原理" class="headerlink" title="Otsu’s 二值化的工作原理"></a>Otsu’s 二值化的工作原理</h2><p>&emsp;&emsp;因为是双峰图，Otsu 算法就是要找到一个阈值（t）, 使得同一类加权方<br>差最小，需要满足下列关系式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sigma^2_w(t) = q_1(t)\sigma^2_1(t) + q_2(t)\sigma^2_2(t)</span><br></pre></td></tr></table></figure><p>其中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q_1(t) = \sum_&#123;i=1&#125;^t P(i)\hspace&#123;2em&#125;\&amp;\hspace&#123;2em&#125; q_1(t) = \sum_&#123;i=t+1&#125;^I P(i)</span><br><span class="line"></span><br><span class="line">\mu_1(t) = \sum_&#123;i=1&#125;^t = \frac&#123;i P(i)&#125;&#123;q_1(t)&#125;\hspace&#123;2em&#125; \&amp; \hspace&#123;2em&#125;\mu_2(t) = \sum_&#123;i=t+1&#125;^I \frac&#123;iP(i)&#125;&#123;q_2(t)&#125;</span><br><span class="line"></span><br><span class="line">\sigma_1^2(t) = \sum_&#123;i=1&#125;^t\left[i-\mu_1(t)\right]^2 \frac&#123;P(i)&#125;&#123;q_1(t)&#125;\hspace&#123;2em&#125; \&amp; \hspace&#123;2em&#125;\sigma_2^2(t) = \sum_&#123;i=t+1&#125;^I\left[i-\mu_1(t)\right]^2 \frac&#123;iP(i)&#125;&#123;q_2(t)&#125;</span><br></pre></td></tr></table></figure></p><p>其实就是在两个峰之间找到一个阈值t，将这两个峰分开，并且使每一个峰内的方差最小。</p><h1 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h1><h2 id="2D卷积"><a href="#2D卷积" class="headerlink" title="2D卷积"></a>2D卷积</h2><p>&emsp;&emsp;与数字信号一样，我们也可以对2D图像实施加低通滤波（LPF），高通滤波（HPF）等。LPF 帮助我们去除噪音，模糊图像。HPF帮助我们找到图像的边缘。OpenCV提供的函数<code>cv.filter2D()</code>可以让我们对一幅图像进行卷积操作。</p><p>下面我们将对一幅图像使用平均滤波器，一个5x5 的平均滤波器核如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">K=\frac1&#123;25&#125;\left[\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]</span><br><span class="line">1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]</span><br><span class="line">1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]</span><br><span class="line">1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\[6pt]</span><br><span class="line">1 &amp; 1 &amp; 1 &amp; 1 &amp; 1</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;操作过程大致是这样的：将核放在图像的一个像素A 上，求与核对应的图像上25（5x5）个像素的和，再取平均数，用这个平均数替代像素A的值。重复以上操作直到将图像的每一个像素值都更新一边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv.Filter2D(src, dst, kernel, anchor=(-1, -1))</span></span><br><span class="line"><span class="comment">#ddepth =&gt; desired depth of the destination image，期望的目标图像的深度</span></span><br><span class="line"></span><br><span class="line">dst = cv2.filter2D(img,<span class="number">-1</span>,kernel)    <span class="comment"># 当ddepth=-1时，则输出的目标图像与源图像有相同的深度</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">'Averaging'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>以下src.depth()和ddepth的组合是可以使用的:</p><ul><li>src.depth() = CV_8U, ddepth = -1 | CV_16S | CV_32F | CV_64F</li><li>src.depth() = CV_16U | CV_16S, ddepth = -1 | CV_32F | CV_64F</li><li>src.depth() = CV_32F, ddepth = -1 | CV_32F | CV_64F</li><li>src.depth() = CV_64F, ddepth = -1 | CV_64F</li></ul><p><a href="WEBRESOURCEbe839a5dd3c13d2a0de23d2a6e03f88c" title="image.png" class="gallery-item"><img src="WEBRESOURCEbe839a5dd3c13d2a0de23d2a6e03f88c" alt="image.png"></a></p><h2 id="图像模糊"><a href="#图像模糊" class="headerlink" title="图像模糊"></a>图像模糊</h2><p>&emsp;&emsp;使用低通滤波器可以达到图像模糊的目的，这对于去除噪音很有帮助。这个处理其实就是去除图像中的高频成分（比如：噪音，边界），所以边界也会被模糊一点。。OpenCV提供了四种模糊技术。</p><h3 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h3><p>&emsp;&emsp;这是由一个归一化卷积框完成的，它通过用卷积框覆盖区域内所有像素的平均值来代替中心元素。可以使用函数<code>cv2.blur()</code>和<code>cv2.boxFilter()</code>来完这个任务。我们需要设定卷积框的宽和高。</p><p>下面是一个3x3 的归一化卷积框：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K=\frac1&#123;9&#125;\left[\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 1 &amp; 1 \\[6pt]</span><br><span class="line">1 &amp; 1 &amp; 1 \\[6pt]</span><br><span class="line">1 &amp; 1 &amp; 1</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p><p>下面这个例子只是在上面例子做了一下更改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line"><span class="comment"># 使用归一化卷积来模糊图像</span></span><br><span class="line">blur = cv2.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">'Blurred'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE2716c0090e4386f150d10e2022219a8b" title="image.png" class="gallery-item"><img src="WEBRESOURCE2716c0090e4386f150d10e2022219a8b" alt="image.png"></a></p><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>&emsp;&emsp;现在把卷积核换成高斯核（简单来说就是，方框不变，原来每个方框的值是相等的，现在里面的值是符合高斯分布的，方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包。原来是求平均数现在变成求加权平均数）。<br><br>&emsp;&emsp;实现的函数是<code>cv2.GaussianBlur()</code>。我们需要指定高斯核的宽和高（必须是奇数）以及高斯函数沿X，Y 方向的标准差。如果我们只指定了X方向的的标准差，Y方向也会取相同值。如果两个标准差都是0，那么函数会根据核函数的大小自己计算。<br><br>&emsp;&emsp;高斯滤波可以有效的从图像中去除高斯噪音。如果需要的话，你也可以使用函数<code>cv2.getGaussianKernel()</code>自己构建一个高斯核。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line"><span class="comment"># 参数0 表示要根据窗口大小（5,5）来计算高斯函数标准差</span></span><br><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">'Blurred'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE1ac953b844d259ba7c2dcf2c004bbbea" title="image.png" class="gallery-item"><img src="WEBRESOURCE1ac953b844d259ba7c2dcf2c004bbbea" alt="image.png"></a></p><h3 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h3><p>&emsp;&emsp;所谓中值模糊，就是用与卷积框对应像素的中值来替代中心像素的值。这个滤波器经常用来去除椒盐噪声。前面的滤波器都是用计算得到的一个新值来取代中心像素的值，而中值滤波是用中心像素周围的值来取代它。它能有效的去除噪声。卷积核的大小也应该是一个奇数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'opencv-logo.png'</span>)</span><br><span class="line">median = cv2.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">'Blurred'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEe17bb2a5a343fca2cc43a6391c9c080d" title="image.png" class="gallery-item"><img src="WEBRESOURCEe17bb2a5a343fca2cc43a6391c9c080d" alt="image.png"></a></p><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>&emsp;&emsp;函数<code>cv2.bilateralFilter()</code>能在保持边界清晰的情况下有效的去除噪音，但是这种操作与其他滤波器相比会比较慢。<br><br>&emsp;&emsp;我们已经知道高斯滤波器是求中心点邻近区域像素的高斯加权平均值，这种高斯滤波器只考虑了像素之间的空间关系(像素分布)，而没有考虑像素值之间的关系（像素的相似度），所以这种方法并不会考虑一个像素是否位于边界，因此边界也会被模糊掉，而这不是我们想要的。<br><br>&emsp;&emsp;双边滤波同时使用了空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以这种方法会确保边界不会被模糊掉，因为边界处的灰度值变化会比较大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'wood.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)</span></span><br><span class="line"><span class="comment">#d =&gt; 过滤过程中使用的每个像素邻域的直径。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数9表示邻域直径，两个75 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差</span></span><br><span class="line">blur = cv2.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">'Blurred'</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE2ac226620840df1928d8149e7354d22a" title="image.png" class="gallery-item"><img src="WEBRESOURCE2ac226620840df1928d8149e7354d22a" alt="image.png"></a></p><p>可见，双边滤波不会模糊边界。</p><h1 id="形态学转换"><a href="#形态学转换" class="headerlink" title="形态学转换"></a>形态学转换</h1><p>&emsp;&emsp;形态学操作是指根据图像形状进行的简单操作。一般情况下，对二值化图像进行的操作需要输入两个参数，一个是原始图像，第二个被称为结构化元素或核，它是用来决定操作的性质的。两个基本的形态学操作是<strong>腐蚀</strong>和<strong>膨胀</strong>。他们的变体则构成了<strong>开运算</strong>，<strong>闭运算</strong>，<strong>梯度</strong>等。</p><h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><p>&emsp;&emsp;就像土壤侵蚀一样，这个操作会把前景物体的边界腐蚀掉（但是前景仍然是白色）。那这是怎么做到的呢？卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是1，那么中心元素就保持原来的像素值，否则就变为零。这会产生什么影响呢？根据卷积核的大小，靠近前景的所有像素都会被腐蚀掉（变为0），所以前景物体会变小，整幅图像的白色区域会减少。这对于去除白色噪声很有用，也可以用来断开两个连在一块的物体等。</p><p>这里我们有一个例子，使用一个5x5 的卷积核。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ball.png'</span>,<span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建5*5的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 腐蚀操作</span></span><br><span class="line">erosion = cv2.erode(img,kernel,iterations = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, erosion)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEa777be42c754dd331e6d0581bbc70860" title="image.png" class="gallery-item"><img src="WEBRESOURCEa777be42c754dd331e6d0581bbc70860" alt="image.png"></a></p><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>&emsp;&emsp;与腐蚀相反，与卷积核对应的原图像的像素值中只要有一个是1，中心元素的像素值就是1。所以这个操作会增加图像中的白色区域（前景）。<br><br>&emsp;&emsp;一般在去噪声时先用腐蚀再用膨胀。因为腐蚀在去掉白噪声的同时，也会使前景对象变小。所以我们再对它进行膨胀。这时噪声已经被去除了，不会再回来了，但是前景还在增加。膨胀也可以用来连接两个分开的物体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'src'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建5*5的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 膨胀操作</span></span><br><span class="line">dilation = cv2.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, dilation)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEed0707358428dcc496e018959fa39ace" title="image.png" class="gallery-item"><img src="WEBRESOURCEed0707358428dcc496e018959fa39ace" alt="image.png"></a></p><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p>&emsp;&emsp;先进行腐蚀再进行膨胀就叫做开运算。，它被用来去除噪声。这里我们用到的函数是<code>cv2.morphologyEx()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j_noise.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'src'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建5*5的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 开运算</span></span><br><span class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, opening)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE762aa11b1c2d969d23defba15d5d8b31" title="image.png" class="gallery-item"><img src="WEBRESOURCE762aa11b1c2d969d23defba15d5d8b31" alt="image.png"></a></p><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p>闭运算其实就是先膨胀再腐蚀。它经常被用来填充前景物体中的小洞，或者前景物体上的小黑点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j_noise2.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'src'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建5*5的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 闭运算</span></span><br><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, closing)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEd9b007e8e78b5cb572a76841b76a08fe" title="image.png" class="gallery-item"><img src="WEBRESOURCEd9b007e8e78b5cb572a76841b76a08fe" alt="image.png"></a></p><h2 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h2><p>所谓形态学梯度，其实就是一幅图像膨胀之后与腐蚀之后的差别。结果看上去就像前景物体的轮廓。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建5*5的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"><span class="comment"># 形态学梯度</span></span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, gradient)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEf602f3a3dc9c819e58138b36c1b4cbfa" title="image.png" class="gallery-item"><img src="WEBRESOURCEf602f3a3dc9c819e58138b36c1b4cbfa" alt="image.png"></a></p><h2 id="礼帽"><a href="#礼帽" class="headerlink" title="礼帽"></a>礼帽</h2><p>原始图像与进行开运算之后得到的图像的差。</p><p>下面的例子是用一个9x9 的核进行礼帽操作的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'src'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建9*9的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">9</span>,<span class="number">9</span>),np.uint8)</span><br><span class="line"><span class="comment"># 礼帽操作</span></span><br><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, tophat)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE6b99891b1be3f86951761e825a72d774" title="image.png" class="gallery-item"><img src="WEBRESOURCE6b99891b1be3f86951761e825a72d774" alt="image.png"></a></p><h2 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h2><p>进行闭运算之后得到的图像与原始图像的差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'src'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">'dst'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'src'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建9*9的卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">9</span>,<span class="number">9</span>),np.uint8)</span><br><span class="line"><span class="comment"># 黑帽操作</span></span><br><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>, blackhat)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEdc9279e9e27cd4ab249d247a0b31864c" title="image.png" class="gallery-item"><img src="WEBRESOURCEdc9279e9e27cd4ab249d247a0b31864c" alt="image.png"></a></p><h2 id="形态学操作之间的关系"><a href="#形态学操作之间的关系" class="headerlink" title="形态学操作之间的关系"></a>形态学操作之间的关系</h2><p><a href="WEBRESOURCEe3adb9726a76595465e2f9e31cab6fd4" title="image.png" class="gallery-item"><img src="WEBRESOURCEe3adb9726a76595465e2f9e31cab6fd4" alt="image.png"></a></p><h2 id="更多种类的结构化元素"><a href="#更多种类的结构化元素" class="headerlink" title="更多种类的结构化元素"></a>更多种类的结构化元素</h2><p>&emsp;&emsp;在前面的例子中，我们使用的都是Numpy 构建的结构化元素(核(，它是正方形的，但<br>有时我们需要构建一个椭圆形/圆形的核。为了实现这种要求，OpenCV提供了函数<code>cv2.getStructuringElement()</code>。你只需要告诉他你需要的核的形状和大小它会自动帮你生成特定形状的核。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Rectangular Kernel，正方形核</span><br><span class="line">&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))</span><br><span class="line">array([[1, 1, 1, 1, 1],</span><br><span class="line">       [1, 1, 1, 1, 1],</span><br><span class="line">       [1, 1, 1, 1, 1],</span><br><span class="line">       [1, 1, 1, 1, 1],</span><br><span class="line">       [1, 1, 1, 1, 1]], dtype=uint8)</span><br><span class="line">       </span><br><span class="line"># Elliptical Kernel，椭圆形核</span><br><span class="line">&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5))</span><br><span class="line">array([[0, 0, 1, 0, 0],</span><br><span class="line">[1, 1, 1, 1, 1],</span><br><span class="line">[1, 1, 1, 1, 1],</span><br><span class="line">[1, 1, 1, 1, 1],</span><br><span class="line">[0, 0, 1, 0, 0]], dtype=uint8)</span><br><span class="line"></span><br><span class="line"># Cross-shaped Kernel,十字形核</span><br><span class="line">&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_CROSS,(5,5))</span><br><span class="line">array([[0, 0, 1, 0, 0],</span><br><span class="line">[0, 0, 1, 0, 0],</span><br><span class="line">[1, 1, 1, 1, 1],</span><br><span class="line">[0, 0, 1, 0, 0],</span><br><span class="line">[0, 0, 1, 0, 0]], dtype=uint8)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE65e3b15ad1b26e9f29d63db0adb2726a" title="image.png" class="gallery-item"><img src="WEBRESOURCE65e3b15ad1b26e9f29d63db0adb2726a" alt="image.png"></a></p><h1 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h1><p>&emsp;&emsp;所谓图像梯度，简单来说，就是求导。OpenCV提供了三种不同的梯度滤波器，或者说是高通滤波器：Sobel，Scharr 和Laplacian。<br><br>&emsp;&emsp;Sobel，Scharr 其实就是求一阶或二阶导数，Scharr 是对Sobel（使用小的卷积核求解梯度角度时）的优化。Laplacian 则是求二阶导数。</p><h2 id="Sobel-算子和Scharr-算子"><a href="#Sobel-算子和Scharr-算子" class="headerlink" title="Sobel 算子和Scharr 算子"></a>Sobel 算子和Scharr 算子</h2><p>&emsp;&emsp;Sobel 算子是高斯平滑与微分操作的结合体，所以它的抗噪声能力很好。你可以设定求导的方向（xorder 或yorder）。还可以设定使用的卷积核的大小（ksize）。如果ksize=-1，可以使用3x3 的Scharr 滤波器，它的的效果要比3x3 的Sobel 滤波器好（而且速度相同，所以在使用3x3 滤波器时应该尽量使用Scharr 滤波器）。</p><p>3x3 的Scharr 滤波器卷积核如下：</p><p><a href="WEBRESOURCEb5f3da01120ff85e176c0f1ecd1e0255" title="image.png" class="gallery-item"><img src="WEBRESOURCEb5f3da01120ff85e176c0f1ecd1e0255" alt="image.png"></a></p><h2 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a>Laplacian 算子</h2><p>&emsp;&emsp;拉普拉斯算子可以使用二阶导数的形式定义，可假设其离散实现类似于二阶Sobel 导数，事实上，OpenCV 在计算拉普拉斯算子时直接调用的Sobel 算子。</p><p>其计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Delta src = \frac&#123;\partial^2 src&#125;&#123;\partial x^2&#125; + \frac&#123;\partial^2 src&#125;&#123;\partial y^2&#125;</span><br></pre></td></tr></table></figure><p>拉普拉斯滤波器使用的卷积核：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel = \left[\begin&#123;matrix&#125;</span><br><span class="line">0 &amp; 1 &amp; 0 \\[6pt]</span><br><span class="line">1 &amp; -4 &amp; 1 \\[6pt]</span><br><span class="line">0 &amp; 1 &amp; 0</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE3e12c2e35fea1c1173036424265563e5" title="image.png" class="gallery-item"><img src="WEBRESOURCE3e12c2e35fea1c1173036424265563e5" alt="image.png"></a></p><p>&emsp;&emsp;上面反复提到过，我们可以通过设置输出类型为-1来让输出图像的深度（数据类型）与原图像保持一致，但可以看到，我们在代码中使用的并不是-1，而是cv2.CV_64F。这是为什么呢？<br><br>&emsp;&emsp;这里可以想象一下一个从黑到白的边界的导数是整数，而一个从白到黑的边界点导数却是负数。如果原图像的深度是np.int8，那么所有的负值都会被截断变成0，换句话说就是会把边界信息丢失掉。<br><br>&emsp;&emsp;所以如果这两种边界都想检测到，最好的的办法就是将输出的数据类型设置的更高，比如cv2.CV_16S，cv2.CV_64F 等，再取绝对值将它转回到cv2.CV_8U类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'boxs.png'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出类型设为cv2.CV_8U</span></span><br><span class="line">sobelx8u = cv2.Sobel(img,cv2.CV_8U,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类型设为cv2.CV_64F，然后取其绝对值转换为cv2.CV_8U类型</span></span><br><span class="line">sobelx64f = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span><br><span class="line">abs_sobel64f = np.absolute(sobelx64f)</span><br><span class="line">sobel_8u = np.uint8(abs_sobel64f)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>),plt.imshow(img,cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Original'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>),plt.imshow(sobelx8u,cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Sobel CV_8U'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>),plt.imshow(sobel_8u,cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Sobel abs(CV_64F)'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE8723a5158f88e0a611d4ac68ee1b77cb" title="image.png" class="gallery-item"><img src="WEBRESOURCE8723a5158f88e0a611d4ac68ee1b77cb" alt="image.png"></a></p><h1 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h1><p>&emsp;&emsp;Canny 边缘检测是一种非常流行的边缘检测算法，是John F.Canny 在1986 年提出的，它是一个由很多步组成的算法。</p><h2 id="去噪"><a href="#去噪" class="headerlink" title="去噪"></a>去噪</h2><p>由于边缘检测很容易受到噪声影响，所以第一步是使用5x5 的高斯滤波器去除噪声。</p><h2 id="计算图像梯度"><a href="#计算图像梯度" class="headerlink" title="计算图像梯度"></a>计算图像梯度</h2><p>&emsp;&emsp;对平滑后的图像使用Sobel 算子计算水平方向和竖直方向的一阶导数（图像梯度，Gx 和Gy）。根据得到的这两幅梯度图（Gx 和Gy）找到边界的梯度和方向，公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Edge\_Gradient(G) = \sqrt&#123;G_x^2 + G_y^2&#125;</span><br><span class="line"></span><br><span class="line">Angle(\theta) = tan^&#123;-1&#125;\left(\frac&#123;G_x&#125;&#123;G_y&#125;\right)</span><br></pre></td></tr></table></figure><p>梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线。</p><h2 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h2><p>&emsp;&emsp;在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</p><p>如下图所示:</p><p><a href="WEBRESOURCEe338c845d3af82ca5445866da8146d5c" title="image.png" class="gallery-item"><img src="WEBRESOURCEe338c845d3af82ca5445866da8146d5c" alt="image.png"></a></p><h2 id="滞后阈值"><a href="#滞后阈值" class="headerlink" title="滞后阈值"></a>滞后阈值</h2><p>&emsp;&emsp;现在要确定的是哪些边界才是真正的边界。这时我们需要设置两个阈值：minVal 和maxVal。当图像的灰度梯度高于maxVal 时被认为是真的边界，那些低于minVal 的开始被认为是边界的像素会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p><p>如下图：</p><p><a href="WEBRESOURCEce4c16d944af5656a97c6e9bc01397ad" title="image.png" class="gallery-item"><img src="WEBRESOURCEce4c16d944af5656a97c6e9bc01397ad" alt="image.png"></a></p><p>&emsp;&emsp;我们分析一下上图，A 高于阈值maxVal ，所以是真正的边界点，C 虽然低于maxVal 但高于minVal 并且与A 相连，所以也被认为是真正的边界点。而B 就会被抛弃，因为它不仅低于maxVal 而且不与真正的边界点相连。<br><br>&emsp;&emsp;可见，选择合适的maxVal和minVal对于能否得到好的结果非常重要。在这一步，一些小的噪声点也会被除去，因为我们假设边界都是一些长的线段。</p><h1 id="OpenCV-中的Canny-边界检测"><a href="#OpenCV-中的Canny-边界检测" class="headerlink" title="OpenCV 中的Canny 边界检测"></a>OpenCV 中的Canny 边界检测</h1><p>&emsp;&emsp;实际上，在OpenCV中使用Canny算法进行边缘检测没有我们想的那么复杂，OpenCV对这几步操作进行了封装，只需要使用一个函数：<code>cv2.Canny()</code>，就可以完成以上几步。<br><br>&emsp;&emsp;这个函数的第一个参数是输入图像。第二和第三个分别是minVal和maxVal。第四个参数设置用来计算图像梯度的Sobel卷积核的大小，默认值为3。最后一个参数是L2gradient，它可以用来设定求梯度大小的方程。如果设为True，就会使用我们上面提到过的方程，否则将使用<code>$Edge\_Gradient(G) = |G_x^2| + |G_y^2|$</code>作为代替，默认值为False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ball.png'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># cv2.Canny(src, minVal, maxVal)</span></span><br><span class="line">edges = cv2.Canny(img,<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Original Image'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(edges,cmap = <span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'Edge Image'</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE50bc7b9133bc87e6fbc18cfcc74f4ac7" title="image.png" class="gallery-item"><img src="WEBRESOURCE50bc7b9133bc87e6fbc18cfcc74f4ac7" alt="image.png"></a></p><h1 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h1><p>&emsp;&emsp;一般情况下，我们要处理是一副具有固定分辨率的图像。但是有些情况下，我们需要对同一图像的不同分辨率的子图像进行处理。比如，我们要在一幅图像中查找某个目标，比如脸，我们不知道目标在图像中的尺寸大小。<br><br>&emsp;&emsp;这种情况下，我们需要创建一组图像，这些图像是具有不同分辨率的原始图像。我们把这组图像叫做图像金字塔（简单来说就是同一图像的不同分辨率的子图集合）。如果我们把最大的图像放在底部，最小的放在顶部，看起来像一座金字塔，图像金字塔因而得名。<br><br>&emsp;&emsp;有两类图像金字塔：<strong>高斯金字塔</strong>和<strong>拉普拉斯金字塔</strong>。高斯金字塔的顶部是通过将底部图像中的连续的行和列去除得到的。顶部图像中的每个像素值等于下一层图像中5 个像素的高斯加权平均值。这样，操作一次一个M <em> N 的图像就变成了一个M/2 </em> N/2的图像。所以这幅图像的面积就变为原来图像面积的四分之一。<br><br>&emsp;&emsp;连续进行这样的操作我们就会得到一个分辨率不断下降的图像金字塔。我们可以使用函数<code>cv2.pyrDown()</code>和<code>cv2.pyrUp()</code>来构建图像金字塔。</p><p>&emsp;&emsp;函数<code>cv2.pyrDown()</code>从一个高分辨率大尺寸的图像向上构建一个金子塔（尺寸变小，分辨率降低）。</p><p>&emsp;&emsp;函数<code>cv2.pyrUp()</code>则从一个低分辨率小尺寸的图像向下构建一个金子塔（尺寸变大，但分辨率不会增加）。</p><h1 id="OpenCV中的轮廓"><a href="#OpenCV中的轮廓" class="headerlink" title="OpenCV中的轮廓"></a>OpenCV中的轮廓</h1><h2 id="什么是轮廓"><a href="#什么是轮廓" class="headerlink" title="什么是轮廓"></a>什么是轮廓</h2><p>&emsp;&emsp;轮廓可以简单认为是将连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。</p><ul><li>为了更加准确，要使用二值化图像。在寻找轮廓之前，要进行阈值化处理或者Canny 边界检测。</li><li>查找轮廓的函数会修改原始图像。如果你在找到轮廓之后还想使用原始图像的话，你应该将原始图像存储到其他变量中。</li><li>在OpenCV 中，查找轮廓就像在黑色背景中超白色物体。你应该记住，要找的物体应该是白色而背景应该是黑色。</li></ul><p>让我们看看如何在OpenCV中使用<code>cv2.findContours()</code>在一个二值图像中查找轮廓：</p><p>&emsp;&emsp;该函数有三个参数，第一个是输入图像，第二个是轮廓检索模式，第三个是轮廓近似方法。返回值有三个，第一个是图像，第二个是轮廓，第三个是（轮廓的）层析结构。轮廓（第二个返回值）是一个Python列表，其中存储着图像中的所有轮廓。每一个轮廓都是一个Numpy 数组，包含对象边界点（x，y）的坐标。</p><h2 id="怎样绘制轮廓"><a href="#怎样绘制轮廓" class="headerlink" title="怎样绘制轮廓"></a>怎样绘制轮廓</h2><p>&emsp;&emsp;函数<code>cv2.drawContours()</code>可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。它的第一个参数是原始图像，第二个参数是轮廓，一个Python列表。第三个参数是轮廓的索引（在绘制独立轮廓是很有用，当设置为-1时表示绘制所有轮廓）。接下来的参数是轮廓的颜色和厚度等。</p><p>下面的例子在一幅图像上绘制所有的轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">im = cv2.imread(<span class="string">'test.jpg'</span>)</span><br><span class="line">imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret,thresh = cv2.threshold(imgray,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure><p>使用以下代码可以绘制单个独立的轮廓：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.drawContour(img, contours, -1, (0,255,0), 3)</span><br></pre></td></tr></table></figure></p><h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><p>图像的矩可以帮助我们计算图像的质心，面积等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">'ball.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">M = cv2.moments(cnt)    <span class="comment"># 使用cv2.moments()取得轮廓的矩，返回值是字典类型</span></span><br><span class="line">print(M)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEd288752d7ed729de88cd5eebfd3e5ac4" title="image.png" class="gallery-item"><img src="WEBRESOURCEd288752d7ed729de88cd5eebfd3e5ac4" alt="image.png"></a></p><p>根据这些矩的值，我们可以计算出对象的重心: <code>$C_x = \frac{M_{10}}{M_{100}}, C_y=\frac{M_{01}}{M_{100}}$</code>，亦即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cx = int(M[&apos;m10&apos;]/M[&apos;m00&apos;])</span><br><span class="line">cy = int(M[&apos;m01&apos;]/M[&apos;m00&apos;])</span><br></pre></td></tr></table></figure></p><h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><p>&emsp;&emsp;轮廓的面积可以使用函数<code>cv2.contourArea()</code>计算得到，也可以使用矩（0 阶矩），即M[‘m00’]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ml.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">perimeter = cv2.arcLength(cnt,<span class="keyword">True</span>)</span><br><span class="line">print(perimeter)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE84773f1a7592cce78842eef3d9881a67" title="image.png" class="gallery-item"><img src="WEBRESOURCE84773f1a7592cce78842eef3d9881a67" alt="image.png"></a></p><h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><p>&emsp;&emsp;也被称为弧长。可以使用函数<code>cv2.arcLength()</code> 计算得到。这个函数的第二参数可以用来指定对象的形状是闭合的（True），还是打开的（一条曲线）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ball.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">perimeter = cv2.arcLength(contours,<span class="keyword">True</span>)</span><br><span class="line">print(perimeter)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE8325e6507dcdf068ad2fc1ca6efd0f9e" title="image.png" class="gallery-item"><img src="WEBRESOURCE8325e6507dcdf068ad2fc1ca6efd0f9e" alt="image.png"></a></p><h3 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h3><p>&emsp;&emsp;将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定。使用的是Douglas-Peucker算法。</p><p>&emsp;&emsp;为了帮助理解，假设我们要在一幅图像中查找一个矩形，但是由于图像的种种原因，我们不能得到一个完美的矩形，而是一个“坏形状”。现在你就可以使用这个函数来近似这个形状了。这个函数的第二个参数叫epsilon，它是从原始轮廓到近似轮廓的最大距离。它是一个准确度参数。选择一个好的epsilon 对于得到满意结果非常重要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ml.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">epsilon = <span class="number">0.1</span>*cv2.arcLength(cnt,<span class="keyword">True</span>)</span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="keyword">True</span>)</span><br><span class="line">print(approx)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE329b0c9dc2a9587cb959bcadf6cf3a53" title="image.png" class="gallery-item"><img src="WEBRESOURCE329b0c9dc2a9587cb959bcadf6cf3a53" alt="image.png"></a></p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>&emsp;&emsp;凸包与轮廓相似，但它们是不同的两个特征，虽然有些情况下它们给出的结果是一样的。函数<code>cv2.convexHull()</code>可以用来检测一个曲线是否具有凸性缺陷，并能纠正缺陷。<br><br>&emsp;&emsp;一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去了就被叫做凸性缺陷。例如下图中的手。红色曲线显示了手的凸包，凸性缺陷被双箭头标出来了。</p><p><a href="WEBRESOURCE1d737d91ebf7db1e7db78bd9a1299564" title="image.png" class="gallery-item"><img src="WEBRESOURCE1d737d91ebf7db1e7db78bd9a1299564" alt="image.png"></a></p><p>计算轮廓的凸包需要使用cv2.covexHull()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]]</span><br></pre></td></tr></table></figure></p><p>它的各参数含义如下：</p><ul><li>points 我们要传入的轮廓</li><li>hull 输出的像素列表，通常不需要</li><li>clockwise 方向标志。如果设置为True，则输出的凸包是顺时针方向的，否则为逆时针方向。</li><li>returnPoints 默认值为True,它会返回凸包上点的坐标。如果设置为False，就会返回与凸包点对应的轮廓上的点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ml.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">hull = cv2.convexHull(cnt)    <span class="comment"># 计算凸包</span></span><br><span class="line">print(hull)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE6a0aa9204bedf71d015d407e50f1fc63" title="image.png" class="gallery-item"><img src="WEBRESOURCE6a0aa9204bedf71d015d407e50f1fc63" alt="image.png"></a></p><h3 id="凸性检测"><a href="#凸性检测" class="headerlink" title="凸性检测"></a>凸性检测</h3><p>函数cv2.isContourConvex() 可以用来检测一个曲线是不是凸的，它只能返回True 或False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'ml.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">k = cv2.isContourConvex(cnt)</span><br><span class="line">print(k)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEdc0872e13c35bda8af71a382c384e00a" title="image.png" class="gallery-item"><img src="WEBRESOURCEdc0872e13c35bda8af71a382c384e00a" alt="image.png"></a></p><h3 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h3><p>有两类边界矩形。</p><p><strong>直边界矩形</strong> 一个直矩形（就是没有旋转的矩形）是不会考虑对象是否旋转的，所以这个边界矩形的面积不是最小的。可以使用函数<code>cv2.boundingRect()</code>查找得到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># (x,y)为矩形左上角的坐标，(w,h)为矩形的宽高</span></span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)   <span class="comment"># 画出边界矩形</span></span><br><span class="line">cv2.imshow(<span class="string">'boundingRect'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE969817ae30b63eecb6bd765fc2e8e4b1" title="image.png" class="gallery-item"><img src="WEBRESOURCE969817ae30b63eecb6bd765fc2e8e4b1" alt="image.png"></a></p><p><strong>旋转的边界矩形</strong> 这个边界矩形是面积最小的，因为它考虑了对象的旋转。用到的函数为<code>cv2.minAreaRect()</code>，返回的是一个Box2D结构，其中包含矩形左上角角点的坐标（x，y），矩形的宽和高（w，h），以及旋转角度。但是要绘制这个矩形需要矩形的4个角点，可以通过函数<code>cv2.boxPoints()</code> 获得。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x,y,angle = cv2.minAreaRect(cnt)</span><br><span class="line">print(angle)</span><br></pre></td></tr></table></figure><p>下图中，红色的矩形为直边界矩形,绿色的矩形为旋转的边界矩形:</p><p><a href="WEBRESOURCE79e73b40da18617690e82bdd2cc902ad" title="image.png" class="gallery-item"><img src="WEBRESOURCE79e73b40da18617690e82bdd2cc902ad" alt="image.png"></a></p><h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>&emsp;&emsp;函数<code>cv2.minEnclosingCircle()</code> 可以帮我们找到一个对象的外切圆，它是所有能够包括对象的圆中面积最小的一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">(x,y),radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">center = (int(x),int(y))</span><br><span class="line">radius = int(radius)</span><br><span class="line">img = cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)    <span class="comment"># 画出最小外接圆</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'minEnclosingCircle'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE47630db5070b24bec1018b64f1c2d018" title="image.png" class="gallery-item"><img src="WEBRESOURCE47630db5070b24bec1018b64f1c2d018" alt="image.png"></a></p><h3 id="椭圆拟合"><a href="#椭圆拟合" class="headerlink" title="椭圆拟合"></a>椭圆拟合</h3><p>使用的函数为cv2.ellipse()，返回值其实就是旋转边界矩形的内切圆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">img = cv2.ellipse(img,ellipse,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)    <span class="comment"># 在原图上画出椭圆</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'minEnclosingCircle'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE580696ba1ecf43ffe94b697c58de41d7" title="image.png" class="gallery-item"><img src="WEBRESOURCE580696ba1ecf43ffe94b697c58de41d7" alt="image.png"></a></p><h3 id="直线拟合"><a href="#直线拟合" class="headerlink" title="直线拟合"></a>直线拟合</h3><p>我们可以根据一组点拟合出一条直线，同样我们也可以为图像中的白色点拟合出一条直线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span><br><span class="line">[vx,vy,x,y] = cv2.fitLine(cnt, cv2.DIST_L2,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>)</span><br><span class="line">lefty = int((-x*vy/vx) + y)</span><br><span class="line">righty = int(((cols-x)*vy/vx)+y)</span><br><span class="line">img = cv2.line(img,(cols<span class="number">-1</span>,righty),(<span class="number">0</span>,lefty),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'line'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE3d58de354780265626a38c2cc7664f32" title="image.png" class="gallery-item"><img src="WEBRESOURCE3d58de354780265626a38c2cc7664f32" alt="image.png"></a></p><h2 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h2><h3 id="长宽比"><a href="#长宽比" class="headerlink" title="长宽比"></a>长宽比</h3><p>边界矩形的宽高比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">aspect_ratio = float(w)/h</span><br><span class="line">print(aspect_ratio)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEac045e4efdc7c14b437113a586b826de" title="image.png" class="gallery-item"><img src="WEBRESOURCEac045e4efdc7c14b437113a586b826de" alt="image.png"></a></p><h3 id="Extent"><a href="#Extent" class="headerlink" title="Extent"></a>Extent</h3><p>轮廓面积与边界矩形面积的比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extent = \frac&#123;Object Area&#125;&#123;Bounding Rectangle Area&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">rect_area = w*h</span><br><span class="line">extent = float(area)/rect_area</span><br><span class="line"></span><br><span class="line">print(extent)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCEa1043dc4b0db301d228b74f9aaad4267" title="image.png" class="gallery-item"><img src="WEBRESOURCEa1043dc4b0db301d228b74f9aaad4267" alt="image.png"></a></p><h3 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h3><p>轮廓面积与凸包面积的比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Solidity = \frac&#123;Contour Area&#125;&#123;ConvexHull Area&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line">hull_area = cv2.contourArea(hull)</span><br><span class="line">solidity = float(area)/hull_area</span><br><span class="line"></span><br><span class="line">print(solidity)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE19632f2c170caea6527610b59acef7e9" title="image.png" class="gallery-item"><img src="WEBRESOURCE19632f2c170caea6527610b59acef7e9" alt="image.png"></a></p><h3 id="Equivalent-Diameter"><a href="#Equivalent-Diameter" class="headerlink" title="Equivalent Diameter"></a>Equivalent Diameter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Equivalent Diameter = \frac&#123;\sqrt&#123;4\times Contour Area&#125;&#125;&#123;\pi&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">equi_diameter = np.sqrt(<span class="number">4</span>*area/np.pi)</span><br><span class="line"></span><br><span class="line">print(equi_diameter)</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE93e75bd6330166f15a29c532bad84a81" title="image.png" class="gallery-item"><img src="WEBRESOURCE93e75bd6330166f15a29c532bad84a81" alt="image.png"></a></p><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>也就是对象的方向，下面的方法<code>cv2.fitEllipse()</code>还会返回长轴和短轴的长度:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">(x,y),(MA,ma),angle = cv2.fitEllipse(cnt)</span><br><span class="line"></span><br><span class="line">print(str(x) + <span class="string">", "</span> + str(y) + <span class="string">', '</span> + str(angle))</span><br><span class="line">print(str(MA) + <span class="string">', '</span> + str(ma))</span><br></pre></td></tr></table></figure><p><a href="WEBRESOURCE341e267661de5f836fe7cb9339eb1624" title="image.png" class="gallery-item"><img src="WEBRESOURCE341e267661de5f836fe7cb9339eb1624" alt="image.png"></a></p><h3 id="极点"><a href="#极点" class="headerlink" title="极点"></a>极点</h3><p>一个对象最上面，最下面，最左边，最右边的点。</p><p><a href="WEBRESOURCE739119999303a817f10c3b168626d3ef" title="image.png" class="gallery-item"><img src="WEBRESOURCE739119999303a817f10c3b168626d3ef" alt="image.png"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lightning.png'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">leftmost = tuple(cnt[cnt[:,:,<span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost = tuple(cnt[cnt[:,:,<span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost = tuple(cnt[cnt[:,:,<span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = tuple(cnt[cnt[:,:,<span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">print(leftmost)</span><br><span class="line">print(rightmost)</span><br><span class="line">print(topmost)</span><br><span class="line">print(bottommost)</span><br></pre></td></tr></table></figure></p><p><a href="WEBRESOURCE7823e8a650b8b22752b15854fa3ae0ce" title="image.png" class="gallery-item"><img src="WEBRESOURCE7823e8a650b8b22752b15854fa3ae0ce" alt="image.png"></a></p><h1 id="轮廓的层次结构"><a href="#轮廓的层次结构" class="headerlink" title="轮廓的层次结构"></a>轮廓的层次结构</h1></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="Python" scheme="https://baibainote.pro/categories/Python/"/>
    
    
      <category term="opencv-python" scheme="https://baibainote.pro/tags/opencv-python/"/>
    
  </entry>
  
  <entry>
    <title>C++函数</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%87%BD%E6%95%B0/"/>
    <id>https://baibainote.pro/2018/12/07/C++函数/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h4="" id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递<p><strong>值传递</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 使用值传递，当实参值过大或过多时，赋值给形参这个过程会大大降低程序运行的效率 */</span><br><span class="line">void swap(int a, int b) &#123;</span><br><span class="line">// 很明显，使用值传递是无法实现x, y交换的目的的</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">x = 10;</span><br><span class="line">y = 5;</span><br><span class="line">swap1(x, y);</span><br><span class="line">// x, y的值传给形参a, b</span><br></pre></td></tr></table></figure></p><p><strong>指针传递</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap2(int *a, int *b) &#123;</span><br><span class="line">// 通过x, y的指针直接改变x, y指向的数据，函数内的操作可以影响外部</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line">x = 10;</span><br><span class="line">y = 5;</span><br><span class="line">swap2(&amp;x, &amp;y);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 对数组进行操作一般使用指针传递</span><br><span class="line">void sortArr(int arr[6]) &#123;   //这里的 6 只是一个期望值，实际上对形参并没有约束作用,即等价于int arr[]或int *arr</span><br><span class="line">    for (int i = 0; i &lt; 6 - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 6 - i - 1; j++) &#123;</span><br><span class="line">            if (a[j] &gt; a[j+1]) &#123;</span><br><span class="line">                int temp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">    要想确定数组的大小，还是得显示指定</span><br><span class="line">    数组尺寸 n,即sortArr(int a[], int n)</span><br><span class="line">*/</span><br><span class="line">void main() &#123;</span><br><span class="line">    int b[] = &#123; 21, 13, 4, 1, 7, 5 &#125;;</span><br><span class="line">    sortArr(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用传递</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    int x = 5, y = 10;</span><br><span class="line">    swap(x, y);</span><br><span class="line">    cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;\ty = &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果：</span><br><span class="line">    x = 10    y = 5</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 由于传给函数形参的本质上是实参的地址，故不能向函数传入常数</span><br><span class="line">int x = 5;</span><br><span class="line">swap(3, 4);  // error</span><br><span class="line">swap(x, 9);  // error</span><br><span class="line">swap(6, x);  // error</span><br></pre></td></tr></table></figure><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> f = <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 使用默认参数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><i>使用默认参数要注意以下三点：</i></u><br></p><p>&emsp;&emsp;①在指定某个函数的默认值时,如果它有函数原型,就只能在函数原型中指定对应数的默认值,不能在定义函数时再重复指定参数默认值。当然,若函数是直接定义的,没有函频原型,若要指定参数默认值,在定义时指定就行了。<br><br>&emsp;&emsp;②在具有多个参数的函数中指定默认值时,所有默认参数都必须出现在无默认值参数的右边。即,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f(int i1, int i2, int i3 = 0);</span><br><span class="line">int g(int i1, int 12 = 0, int i3);    // error,i3没有默认值</span><br><span class="line">int h(int i1=0, int i2, int i3=0);    // error,i1默认后,其右边的i2没有默认值</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;③可以用表达式作为默认参数,只要表达式可以转换成形参所需的类型即可。但是,局部量不能作为默认参数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// 定义全局变量</span><br><span class="line">string name = &quot;tom&quot;;</span><br><span class="line">double h = 0.8, len = 1.1;</span><br><span class="line">void dog(string dogname = name, double high = h, double length = len) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Dogname： &quot; &lt;&lt; dogname &lt;&lt; &quot;\tHigh：&quot; &lt;&lt; h &lt;&lt; &quot;\tLength：&quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    name = &quot;Jake&quot;;     // 修改全局变量以改变参数name的默认值</span><br><span class="line">    double h = 2.1;    // 重新定义一个局部变量h，与全局变量h无关，对参数high的默认值无影响</span><br><span class="line">    dog();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果如下：</span><br><span class="line">Dogname：Jake    High：0.8    Length：1.1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>默认返回值和void的返回值</strong></p><p>&emsp;&emsp;每个函数最后都是通过return语句来结束调用的(返回值为void的函数没有return语句，但系统会在该函数的最后一条语句的后面隐式地执行return语句)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int maxArr(int a[], int n) &#123;</span><br><span class="line">// 在最新的C++11中的标准中，函数没有默认返回值了(在C语言和早期的C++中，函数的默认返回值为int)</span><br><span class="line">    int max = a[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (max &lt; a[i])</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">    if (a = b)</span><br><span class="line">        return;</span><br><span class="line">    else &#123;</span><br><span class="line">        int t = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>返回引用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int temp;</span><br><span class="line">int&amp; f(int i1, int i2) &#123;</span><br><span class="line">    temp = i1 + i2;</span><br><span class="line">    return temp;   // 返回 temp的引用</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    int t = f(1, 3);</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; &quot;  &quot;;</span><br><span class="line">    f(2, 8)++;</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; &quot;  &quot;;</span><br><span class="line">    f(2, 3) = 9;</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果如下：</span><br><span class="line">    4    11    9</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int &amp;g(int i1, int i2) &#123;    // error</span><br><span class="line">// 返回值为引用的函数应该return一个变量，而不能是表达式</span><br><span class="line">    return i1 + i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">g</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i1 + i2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数返回值为常量引用值时可以return表达式</span></span><br><span class="line"><span class="comment">/* 函数返回表达式的隐式过程：</span></span><br><span class="line"><span class="comment">int temp = i1 + i2;</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">一般情况下，函数返回temp的值后，temp就会被回收</span></span><br><span class="line"><span class="comment">但返回值为const type&amp;时，temp会被保留，将temp的地址作为返回值，直到使用函数返回值的那个变量的作用域结束后才被回收</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 重载函数必须具有不同的形参列表 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Abs(int x) &#123; return x &gt; 0 ? x : -x; &#125;</span><br><span class="line">float Abs(float x) &#123; return x &gt; 0 ? x : -x &#125;</span><br><span class="line">double Abs(double x) &#123; return x &gt; 0 ? x : -x; &#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cout &lt;&lt; Abs(-9) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Abs(-9.9f) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Abs(-9.8) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><i>重载函数注意事项:</i></u></p><p>&emsp;&emsp;① 返回值不同并不能作为重载函数的依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 重载函数</span><br><span class="line">int f(int, int)</span><br><span class="line">double f(int)</span><br><span class="line">int f(char)</span><br><span class="line">// 只有返回类型不同，而函数名和参数表都完全相同的函数只能看作是同一函数的重复声明</span><br><span class="line">int f(int);</span><br><span class="line">double f(int);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;② 在定义和调用重载函数时，要注意它的二义性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">f(a);      <span class="comment">// error,产生二义性，无法确定调用的是f(int&amp; x)还是f(int x)</span></span><br></pre></td></tr></table></figure></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++命名空间</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://baibainote.pro/2018/12/07/C++命名空间/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p=""><strong>命名空间的概念</strong><p></p><p>&emsp;在程序设计时,要求同一程序在全局作用域中声明的每个变量,函数,类型,常量等都必须具有唯一的名称,如有重复,就会产生命名冲突。程序员不一定对系统的全部库函数名和全局变量符号都熟悉,容易定义与系统已有名称重复的变量名。另外,如果一个程序由许多程序员共同编写,彼此并不知道对方定义的标识符名称,回名在所难免,诸如此类原因还有很多,如在程序中引入另一个系统或第三方软件商提供的库文件,它们定义的全局名称(如全局变量,函数、类型等的名称)也容易与当前程序的已有名称相同,上述情况引发的名字冲突问题称为全局命名空间污染问题,处理起来并不容易,在大型程序中尤其困难,C标准引入命名空间来解决此问题。<br><br>&emsp;&emsp;命名空间就是每个程序员或每个不同的函数库各自独立地定义的一个名称,将自己设计的全部对象(包括变量,函数、类型、类等)都包含在此名称之下。这样,每个变量的全名就是“命名空间对象名称”,只要命名空间不同名,就能够有效地区分程序中的同名变量。</p><p><strong>命名空间定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命名空间定义句法：</span><br><span class="line">namespace name &#123;</span><br><span class="line">    members;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace ABC &#123;</span><br><span class="line">    int count;</span><br><span class="line">    typedef float, house_price;</span><br><span class="line">    struct student &#123;</span><br><span class="line">        char* name;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;;</span><br><span class="line">    double add(int a, int b) &#123; return (double)a + b; &#125;</span><br><span class="line">    inline int min(int a, int b);</span><br><span class="line">&#125;;</span><br><span class="line">int ABC::min(int a, int b) &#123; return a &gt; b ? a : b; &#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间的应用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    ABC::count = 1;    // 访问ABC空间中的count</span><br><span class="line">    int count = 9;     // 这是main函数中的局部变量count，与ABC中的count无关</span><br><span class="line">    ABC::student s;    // 使用ABC中的结构体定义变量</span><br><span class="line">    s.age = 9;</span><br><span class="line">    int x = ABC::min(4, 5);   // 调用命名空间ABC中的函数min()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>① 使用<code>using namespace_name::identifier</code>引用命名空间的单个成员。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ABC::count;</span><br><span class="line">    <span class="comment">// 引用命名空间ABC中的count，引用之后，就不用在count前面加上ABC::了</span></span><br><span class="line">    count = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// int count = 9;</span></span><br><span class="line">    count = count + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②使用<code>using namespace ABC</code>引用命名空间的全部成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using namespace ABC;</span><br><span class="line">void main() &#123;</span><br><span class="line">    int count = 9;   // 已引入了ABC中定义的count,这是重复定义</span><br><span class="line">    student s;</span><br><span class="line">    count = 5;</span><br><span class="line">    s.age = min(43, 32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++常量</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%B8%B8%E9%87%8F/"/>
    <id>https://baibainote.pro/2018/12/07/C++常量/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <iframe="" src="https://www.desmos.com/calculator/tskywapslo?embed" width="500px" height="500px" style="border: 1px solid #ccc" frameborder="0"><p><strong>常量的定义</strong></p><p>在C++中，定义常量可以使用const或constexpr。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const char c = &apos;A&apos;;  // 常量必须在定义时进行初始化</span><br><span class="line">int i, j = 10;</span><br><span class="line">const int k = i + j + 5;   // 表达式可以用来初始化常量</span><br><span class="line"></span><br><span class="line">/* constexpr与const基本类似，</span><br><span class="line">但constexpr常量必须在编译时就被初始化，</span><br><span class="line">而const常量可以延迟到运行时被初始化</span><br><span class="line">*/</span><br><span class="line">const int n = f();</span><br><span class="line">constexpr int num = f();   // error,编译时不知道f()的返回值</span><br><span class="line">constexpr int t = j + 10;  // error,j是变量,编译时还不知道j的值</span><br><span class="line"></span><br><span class="line">int f() &#123;</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>const与指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 指针实际上可以看作是两部分，对象的地址和所指向对象的值 */</span><br><span class="line">/*</span><br><span class="line">    =&gt; 底层const：</span><br><span class="line">      const type *p1;   // *p1不可变(该内存处存储的变量不可变)，p1可变</span><br><span class="line">    =&gt; 顶层const：</span><br><span class="line">      type *const p2;   // p2不可变(始终指向同一块内存),*p2可变</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *const p0;    // error,p0未初始化</span><br><span class="line">    char *const p1 = &quot;dukang&quot;;</span><br><span class="line">    char const *p2;</span><br><span class="line">    const char *p3 = &quot;dukang&quot;;</span><br><span class="line">    const char *const p4 = &quot;dukang&quot;;</span><br><span class="line">    const char *const p5;   // error,p5是常量，必须初始化</span><br><span class="line">    p1 = &quot;wankang&quot;;         // error,p1是常量，不可变更</span><br><span class="line">    p2 = &quot;wankang&quot;;</span><br><span class="line">    p3 = &quot;wankang&quot;;</span><br><span class="line">    p4 = &quot;wankang&quot;;         // error,p4是常量，不可变更</span><br><span class="line">    p1[0] = &apos;w&apos;;</span><br><span class="line">    p2[0] = &apos;w&apos;;            // error,*p2是常量</span><br><span class="line">    p3[0] = &apos;w&apos;;            // error,*p3是常量</span><br><span class="line">    p4[0] = &apos;w&apos;;            // error,*p4是常量</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const与引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 9;</span><br><span class="line">int &amp;rr = i;</span><br><span class="line">const int &amp;ri = i;</span><br><span class="line">rr = 8;</span><br><span class="line">ri = 7;    // error,ri是常量，不允许通过它来修改i的值</span><br></pre></td></tr></table></figure><p><code>`int i = 2;const double &amp;ff = 10.0;  // 常量引用可以用常量初始化// 等价于 double temp = 10.0;const double &amp;ff = tempconst int &amp;ri = i + 10;int &amp;ii = 3;   // error,非常量引用不能用常量初始化</code></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++引用</title>
    <link href="https://baibainote.pro/2018/12/07/C++%E5%BC%95%E7%94%A8/"/>
    <id>https://baibainote.pro/2018/12/07/C++引用/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.053Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <figure=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    int i = 9;</span><br><span class="line">    int &amp;ri = i;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">    ri = 20;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">    i = 12;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;    &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;i 的地址是：&quot; &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ri 的地址是：&quot; &lt;&lt; &amp;ri &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果：</span><br><span class="line">    i = 9    ri = 9</span><br><span class="line">    i = 20    ri = 20</span><br><span class="line">    i = 12    ri = 12</span><br><span class="line">    i 的地址是： 0029FDB0</span><br><span class="line">    ri 的地址是： 0029FDB0</span><br><span class="line">*/</span><br></pre></td></tr></table><p>可以看到，ri和i指的实际上是同一个变量(内存地址)，对ri的操作实际上就是对i的操作，ri可以看做是i的别名。<br><a href="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/ff61098393b04a6e0be38516cd6422dc/25835" class="gallery-item" target="_blank" rel="noopener"><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/ff61098393b04a6e0be38516cd6422dc/25835" alt=""></a><br><i>使用引用时需要注意以下几个问题：</i><br><br>&emsp;&emsp;① 在定义引用时，&amp;在类型与引用名之间的位置是灵活的，故以下几种定义完全等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp; ri = i;    int &amp; ri = i;    int &amp;ri = i;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;② 在变量声明时出现的&amp;才是引用运算符(包括函数参数声明和函数返回类型的声明)，其它地方出现的&amp;则是地址操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int &amp;r = i;     // 引用</span><br><span class="line">int&amp; f(int &amp;i1, int &amp;);     // 引用参数(声明参数变量)</span><br><span class="line">int *p = &amp;i;    // &amp;取i的地址</span><br><span class="line">cout &lt;&lt; &amp;p;     // &amp;取p的地址</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;③ 引用必须在定义时初始化，不能在定义完成后再给它赋值<b>;</b>为引用提供的初始值可以是一个变量名，也可以是另一个引用名，也可以是另一个引用名<b>;</b>同一个变量可以定义多个引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float f;</span><br><span class="line">float &amp;fr;   // error,引用定义时未初始化</span><br><span class="line">float &amp;r1 = f;   // r1 &lt;=&gt; f</span><br><span class="line">float &amp;r2 = f;   // r2 &lt;=&gt; f</span><br><span class="line">float &amp;r3 = r1;  // r3 &lt;=&gt; r1 &lt;=&gt; f</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;④引用对应着变量的左值，代表变量的内存区域，实际是一种隐式指针，但与指针存在区别。<br><br>&emsp;&emsp;引用与指针的区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    int i = 9;</span><br><span class="line">    int *pi = &amp;i;   // 取地址</span><br><span class="line">    int &amp;ri = i;    // 定义引用</span><br><span class="line">    *pi = 2;</span><br><span class="line">    ri = 8;         // ri等价于*pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/29a08d9b1efd597d0cd30813de70e334/25021" class="gallery-item" target="_blank" rel="noopener"><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/29a08d9b1efd597d0cd30813de70e334/25021" alt=""></a></p><p>可以看到，引用本质上也是指针的一种隐式封装，即将*pi简化为ri。但它与指针至少存在两点区别：</p><ul><li>指针必须通过解引用运算符”*”才能访问它所指向的内存单元，而引用则与普通变量的访问方法差不多;</li><li>指针是一个变量，它有自己独立的内存区域，可以对它重新赋值，让它指向其他地址。但引用只是某个变量的别名，甚至没有自己独立的内存区域，必须在定义时进行初始化，并且一经定义就再也不能作为其他变量的引用了。</li></ul><p>&emsp;&emsp;⑤ 当用&amp;运算符获取一个引用的地址时，实际取出的是引用对应的变量的地址。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ri = i;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ri;   <span class="comment">// pi的值实际上是i(ri是i的别名引用)的地址</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;⑥ 建立引用时，引用应当类型匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double d;</span><br><span class="line">int &amp;rd = d;   // 引用类型与它对应的变量类型不匹配</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;⑦ 引用与数组。可以建立数组或数组元素的引用，但不能建立引用数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;, *b[10];</span><br><span class="line">int (&amp;ra)[10] = a;   // ra是具有10个元素的整型数组的引用</span><br><span class="line">int &amp;aa = a[0];      // 数组元素的引用</span><br><span class="line">int *(&amp;rpa)[10] = b; // rpa是具有10个整型指针的数组的引用</span><br><span class="line">int &amp;ai[10] = a;     // error,ai是引用数组(每个数组元素都是引用)，这是不允定义的</span><br><span class="line">ra[3] = 0;           // 数组引用的用法</span><br><span class="line">rpa[3] = &amp;i;         //</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;⑧ 引用与指针。可以建立指针的引用，但不能创建指向引用的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, a[10];</span><br><span class="line">int &amp;*ip = i;     // error,ip是指向引用的指针</span><br><span class="line">int *pi = &amp;i;</span><br><span class="line">int *pr = pi;     // pr是指针的引用</span><br></pre></td></tr></table></figure></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++z作用域与生命周期</title>
    <link href="https://baibainote.pro/2018/12/07/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F/"/>
    <id>https://baibainote.pro/2018/12/07/作用域和生命期/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h4="" id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域<p>&emsp;&emsp;C++的作用域大致可以分为<font color="#609090"><code>全局作用域</code></font>、<font color="#609090"><code>局部作用域</code></font>和<font color="#609090"><code>文件作用域</code></font>三种。还有一种更细的分法，按照作用域范围从大到小分为<font color="#609090"><code>程序作用域</code></font>，<font color="#609090"><code>文件作用域</code></font>，<font color="#609090"><code>类作用域</code></font>，<font color="#609090"><code>函数作用域</code></font>和<font color="#609090"><code>块作用域</code></font>5种类型。</p><p><strong>①程序作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指一个标识符在整个程序范围内有效。若一个程序由多个文件组成,具有这种作用域的标识符可以在该程序的各文件中应用。具有程序作用域的标识符只能在某个文件中定义一次,在要使用它的文件中用 extern声明。例如,如果有10个文件都要用到某个变量,这个变量也只能在一个文件中定义,在其他9个文件中必须用extern声明后才能使用。<br></p></blockquote><p><strong>②文件作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指在一个文件中所有函数定义之外定义的名字(包括函数名),其有效范围为从定义它的语句位置开始,直到文件结束。具有文件作用域的名字只能在定义它的文件中使用,但不能在组成同一程序的其他文件中使用。<br></p></blockquote><p><strong>③函数作用域:</strong><br></p><blockquote><p>&emsp;&emsp;指在函数范围内有效的标志符。<br></p></blockquote><p><strong>④块作用域:</strong><br></p><blockquote><p>&emsp;&emsp;写在{}内的一条或多条语句就构成了一个语句块,在其中定义的标识符就只能在这对“{}”中使用,而且只在定义(或声明)它的语句位置到离它最近的“}”之间有效,即只能在这段代码区域内引用它,这就是块作用域<br>在C++中,任何在“{}”中定义或声明的标识符都具有块作用域。局限在一个函数内部的标识符都具有块作用域,包括在函数内部定义的变量或对象、函数的形式参数等。<br></p></blockquote><p><strong>⑤作用域限定符:</strong><br></p><blockquote><p>&emsp;&emsp;在函数中,一旦在当前作用域中找到了需要的名字,编译器就会忽略外层作用域中的同名实体。也就是说,若局部变量和某个全局变量同名,局部变量名会隐藏全局变量名。在这种情况下,可用作用域限定符“:”存取全局变量的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 最外层的i和函数f()具有文件作用域 */</span><br><span class="line">/* f()内为块作用域 */</span><br><span class="line">int i;</span><br><span class="line">int f() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    i = 1;           // 修改f()中定义的局部变量i</span><br><span class="line">    ::i = 0;         // 修改全局变量i</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        static int k;</span><br><span class="line">        i = 2;       // 修改f()中定义的局部变量i</span><br><span class="line">        ::i = 3;     // 修改全局变量i</span><br><span class="line">    &#125;</span><br><span class="line">    j = 2;           // error,k已被回收</span><br><span class="line">    return k;        // k已失去作用域</span><br><span class="line">&#125;</span><br><span class="line">/* 由于局部变量在函数运行结束时它的那个内存地址会被回收以重新分配给其他数据，所以不要在函数内返回局部变量的地址和引用。 */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* if语句里的作用域 */</span><br><span class="line">if(int i = 5) &#123;      // i的作用域自此开始</span><br><span class="line">    int p = 0;       // p的作用域自此开始</span><br><span class="line">&#125;                    // p的作用域到此结束</span><br><span class="line">else &#123;</span><br><span class="line">    i = 1;</span><br><span class="line">    p = 2            // error, p已无定义</span><br><span class="line">&#125;                    // i的作用域到此结束</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* switch语句中的变量作用域 */</span><br><span class="line">void f(int i) &#123;</span><br><span class="line">    switch(int j = i) &#123;    // j的作用域自此开始</span><br><span class="line">        case 1: j = j + 1;</span><br><span class="line">        case 2:</span><br><span class="line">        case 3: cout &lt;&lt; j;</span><br><span class="line">    &#125;                      // j的作用域到此结束</span><br><span class="line">    cout &lt;&lt; j &lt;&lt; endl;     // error,j已无定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 循环语句中的作用域 */</span><br><span class="line">// C++新标准中，for循环中允许初始化i变量</span><br><span class="line">void f1(int z) &#123;</span><br><span class="line">    for(int i = 0; i &lt; z; i++) &#123;    // i的作用域开始</span><br><span class="line">        int j = i;</span><br><span class="line">        cout &lt;&lt; i * j &lt;&lt; endl;</span><br><span class="line">    &#125;                               // i的作用域到此结束</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;              // error, i已无定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量类型与生命期"><a href="#变量类型与生命期" class="headerlink" title="变量类型与生命期"></a>变量类型与生命期</h4><table><tr><td><br>&emsp;&emsp;根据变量的作用域范围,变量可分为全局变量和局部变量两大类。在函数内部定义的变量就是局部变量(包括函数参数),它们只能在定义它的函数中使用;在函数之外且不在任何一对“{”内定义的变量(不属于任何函数)就是全局变量,其有效范围从其在文件中的定义位置开始到文件结束。<br><br>&emsp;&emsp;变量的生命期是指变量在内存中存在的时间,生命期与变量所在的内存区域有关。为了更清楚地理解这个问题,先看看运行程序对内存的应用情况。个程序在其运行期间,它的程序代码和数据会被分别存储在4个不同的内存区域中,如图所示。<br></td></tr></table><p><a href="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/a63faddcaaff39211668400680aa307c/25039" class="gallery-item" target="_blank" rel="noopener"><img src="https://note.youdao.com/yws/public/resource/221712b3563701a749b4b8925395f5d3/xmlnote/a63faddcaaff39211668400680aa307c/25039" alt=""></a></p><ul><li><code>程序代码区</code>:程序代码(即程序的各函数代码)存放在此区域中。</li><li><code>全局数据区</code>:程序的全局数据(如全局变量)和静态数据( static)存放在此区域中。</li><li><code>栈区</code>:程序的局部数据(在函数中定义的数据)存放在此区域中。</li><li><code>堆区</code>:程序的动态数据(new、 malloc就在此区域中分配存储空间)存放在此区域中。<br></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br><br>&emsp;&emsp;全局数据区中的数据由C++编译器建立,对于定义时没有初始化的变量,系统会自动将其初始化为0.这个区域中的数据一直保存,直到程序结束时才由系统负责回收。<br><br>&emsp;&emsp;堆区的数据由程序员管理,程序员可用<code>new</code>或<code>malloc</code>分配其中的存储单元给指针变量,用完之后,由程序员用<code>delete</code>或<code>free</code>将其归还系统,以便其他程序使用。<br><br>&emsp;&emsp;在函数中定义的局部变量(除了static类型的局部变量外,static类型的变量在全局数据区中),只有当函数被调用时,系统才会为函数建立堆栈,并在栈区中为函数中定义的局部变量分配存储空间,且不会对分配的存储单元做初始化工作。一旦函数调用完成,系统就会回收这些变量在栈区中的存储单元。<br><br>&emsp;&emsp;全局变量和静态变量存储在全局数据区中,它们具有较长的生命期。非静态的局部变量存储在栈区中,其生命期很短,只在函数调用期间有效。<br><br>&emsp;&emsp;<u>静态变量可分为静态全局变量和静态局部变量</u>,前者的作用域是整个程序范围,后者的作用域局限于定义它的语句块。静态局部变量的作用域与普通局部变量的作用域是相同的,但它与全局变量有着同样长的生命期,即程序结束时它才会被释放。普通局部变量的生命期只有函数调用期向才存在,函数调用完成后就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static int n;        // n被初始化为0</span><br><span class="line">void f() &#123;</span><br><span class="line">    static int i;    // i被初始化为0</span><br><span class="line">    int j = 0;</span><br><span class="line">    i += 2;</span><br><span class="line">    j += 2;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; &quot;, &quot;;</span><br><span class="line">    cout &lt;&lt; &quot;j = &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    n += 5;</span><br><span class="line">    f();             // 输出i = 2, j = 2</span><br><span class="line">    i = 2;           // error,i作用域为f()内部</span><br><span class="line">    f();             // 输出i = 4, j = 2</span><br><span class="line">&#125;                    // i, n的生命期到此结束</span><br></pre></td></tr></table></figure><h4 id="初始化列表，变量初始化与赋值"><a href="#初始化列表，变量初始化与赋值" class="headerlink" title="初始化列表，变量初始化与赋值"></a>初始化列表，变量初始化与赋值</h4><p>&emsp;&emsp;变量在被创建时就获得一个指定的值，称为<font color="906060">初始化</font>。初始化值可以是任意复杂的表达式，当同时定义多个变量时，位于前面的变量马上就能够用于初始化另一个变量，即<code>int i = 10, j = i * 10</code>。<br><br>&emsp;&emsp;初始化的方式一般有以下几种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 这四种初始化方式是等价的 */</span><br><span class="line">int x = 0;</span><br><span class="line">int x(0);</span><br><span class="line">/* 后两种称为初始化列表方式 */</span><br><span class="line">int x = &#123;0&#125;;</span><br><span class="line">int x&#123;0&#125;;</span><br></pre></td></tr></table></figure></p><font size="2" color="#609060">&emsp;&emsp;后两种方式是C++ 11新标准的一部分，”{}”除了用于变量初始化，还可用于赋值。而在此前的C++标准中，只有部分场合才允许使用这种初始化方式，如数组初始化。</font><p><u><i>初始化与赋值:</i></u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line"></span><br><span class="line">int x;</span><br><span class="line">x = 10;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然x的最终值都是10，但<code>x = 10</code>是赋值语句，可以理解为:先除掉x对应内存单元中的值，再写入10，而<code>int x = 10</code>没有这个过程，它是在为x分配内存单元的同时就写入10。<br><br><u><i>全局变量，静态变量与局部变量的存储位置:</i></u></p><p> &emsp;&emsp;<font color="#906060">变量初始化的默认规则是</font>:如果定义变量时提供了初始值表达式,系统就用这个表达式的值作为变量的初值:如果定义变量时没有为它提供初值,则全局数据区中的变量将被系统自动初始化为0,栈和堆中的变量不被初始化。<br><br>&emsp;&emsp;全局变量、命名空间的变量、静态变量会被保存在全局数据区中,所以它们会被系统自动初始化为0;局部变量(也叫自动变量)被存储在栈区中;动态分配的变量(用malloc和new建立)被存储在堆区中,它们都不会被系统用默认值初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 全局变量，静态变量，局部变量的初始化 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;                   // 初始化为0</span><br><span class="line">void f() &#123;</span><br><span class="line">    static int i;        // 初始化为0</span><br><span class="line">    int j;               // 未初始化，j值不确定</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; &quot;, &quot;;</span><br><span class="line">    cout &lt;&lt; &quot;j = &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int *p1;                // p1被初始化为0</span><br><span class="line">void main() &#123;</span><br><span class="line">    int *p2;            // p2未被初始化，值未知</span><br><span class="line">    int m;              // m未被初始化，值未知</span><br><span class="line">    f();                // 输出i = 0, j = ?, ?表示一个不确定的一个值</span><br><span class="line">    cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;    // 输出n = 0</span><br><span class="line">    cout &lt;&lt; &quot;m = &quot; &lt;&lt; m &lt;&lt; endl;    // 输出m = ?,  ?表示一个不确定的一个值</span><br><span class="line">    if (p1)</span><br><span class="line">        cout &lt;&lt; &quot;p1 = &quot; &lt;&lt; p1 &lt;&lt; endl;    // p1 = 0, 无输出</span><br><span class="line">    if (p2)</span><br><span class="line">        cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2 &lt;&lt; endl;    // 输出p2 = ?, ?表示不确定地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;综上所述，最好对变量初始化，以免局部变量的不确定值引起程序错误。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>文件的读写</title>
    <link href="https://baibainote.pro/2018/12/07/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"/>
    <id>https://baibainote.pro/2018/12/07/文件输入与输出/</id>
    <published>2018-12-07T11:34:45.000Z</published>
    <updated>2020-03-15T07:35:06.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">&emsp;&emsp;程序与文件的数据交换方法同它与标准输入/输出设配的数据交换方法相同。从文件读取数据与从键盘输入数据的方法相似，将数据写入文件与将数据输出到显示器的方法相似。但<code>iostream</code>中定义的数据类型和函数只能用于标准输入/输出设配的数据处理。C++将处理文件的数据类型放在了头文件<code>fstream</code>里，分为<code>ofstream</code>和<code>ifstream</code>。<br><br>文件流操作一般包括五个步骤:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;1&gt; 包含头文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;2&gt; 定义文件流句柄file_handler */</span></span><br><span class="line">ifstream inData;</span><br><span class="line">ofstream outData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;3&gt; 将文件流句柄与磁盘文件filename关联起来 */</span></span><br><span class="line">file_handler.open(filename, mode)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    打开或建立文件的模式mode的可选值:</span></span><br><span class="line"><span class="comment">    ios::in            // 打开输入文件，ifstream类型变量的默认方式</span></span><br><span class="line"><span class="comment">    ios::out           // 建立输出文件，ofstream类型变量的默认方式</span></span><br><span class="line"><span class="comment">    ios::app           // 增加方式，若文件存在，将在文件尾增加数据，否则就建立文件</span></span><br><span class="line"><span class="comment">    ios::trunk         // 若文件存在，则文件中已有内容将被清除</span></span><br><span class="line"><span class="comment">    ios::nocreate      // 若文件不存在，则打开操作失败</span></span><br><span class="line"><span class="comment">    ios::noreplace     // 若文件存在，则打开操作失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 打开一个文件:</span></span><br><span class="line"><span class="comment">    ofstream outData;</span></span><br><span class="line"><span class="comment">    outData.open("abc.txt", ios:in);</span></span><br><span class="line"><span class="comment">或将&lt;2&gt;,&lt;3&gt;合为一步:</span></span><br><span class="line"><span class="comment">    ofstream outData("abc.txt", ios::in)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;4&gt; 用文件流(&lt;&lt;或&gt;&gt;)操作文件，读/写文件数据，将输入文件流与&gt;&gt;连接，就能够从文件中读入数据，与cin用法相同。将输出文件流与&lt;&lt;连接，就能够从文件中读入数据，与cout用法相同。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;5&gt; 关闭文件 */</span></span><br><span class="line">inData.close();</span><br><span class="line">ourData.close();</span><br></pre></td></tr></table></figure><p></p><p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    ofstream outData(&quot;C:\\data.txt&quot;);    // 前一个 / 用于转义</span><br><span class="line">    ifstream inData;</span><br><span class="line">    int x, a[10];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        outData &lt;&lt; x &lt;&lt; &quot; &quot;;  // 将x的值写入文件流句柄outData指向的文件data.txt中</span><br><span class="line">    &#125;</span><br><span class="line">    outData.close();</span><br><span class="line">    inData.open(&quot;D:\\data.txt&quot;);</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(!inData.eof())</span><br><span class="line">        inData &gt;&gt; a[j++];   // 将data.txt中的数据载入数组a[]中</span><br><span class="line">    inData.close();</span><br><span class="line">    int s = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;the sum is: &quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="C++" scheme="https://baibainote.pro/categories/C/"/>
    
    
      <category term="C++" scheme="https://baibainote.pro/tags/C/"/>
    
  </entry>
  
</feed>
