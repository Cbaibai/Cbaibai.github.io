<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++命名空间]]></title>
    <url>%2F2018%2F12%2F07%2FC%2B%2B%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命名空间的概念 &emsp;在程序设计时,要求同一程序在全局作用域中声明的每个变量,函数,类型,常量等都必须具有唯一的名称,如有重复,就会产生命名冲突。程序员不一定对系统的全部库函数名和全局变量符号都熟悉,容易定义与系统已有名称重复的变量名。另外,如果一个程序由许多程序员共同编写,彼此并不知道对方定义的标识符名称,回名在所难免,诸如此类原因还有很多,如在程序中引入另一个系统或第三方软件商提供的库文件,它们定义的全局名称(如全局变量,函数、类型等的名称)也容易与当前程序的已有名称相同,上述情况引发的名字冲突问题称为全局命名空间污染问题,处理起来并不容易,在大型程序中尤其困难,C标准引入命名空间来解决此问题。&emsp;&emsp;命名空间就是每个程序员或每个不同的函数库各自独立地定义的一个名称,将自己设计的全部对象(包括变量,函数、类型、类等)都包含在此名称之下。这样,每个变量的全名就是“命名空间对象名称”,只要命名空间不同名,就能够有效地区分程序中的同名变量。 命名空间定义1234// 命名空间定义句法：namespace name &#123; members;&#125; 1234567891011namespace ABC &#123; int count; typedef float, house_price; struct student &#123; char* name; int age; &#125;; double add(int a, int b) &#123; return (double)a + b; &#125; inline int min(int a, int b);&#125;;int ABC::min(int a, int b) &#123; return a &gt; b ? a : b; &#125; 命名空间的应用1234567void main() &#123; ABC::count = 1; // 访问ABC空间中的count int count = 9; // 这是main函数中的局部变量count，与ABC中的count无关 ABC::student s; // 使用ABC中的结构体定义变量 s.age = 9; int x = ABC::min(4, 5); // 调用命名空间ABC中的函数min()&#125; ① 使用using namespace_name::identifier引用命名空间的单个成员。1234567void main() &#123; using ABC::count; // 引用命名空间ABC中的count，引用之后，就不用在count前面加上ABC::了 count = 2; // int count = 9; count = count + 2;&#125; ②使用using namespace ABC引用命名空间的全部成员。1234567using namespace ABC;void main() &#123; int count = 9; // 已引入了ABC中定义的count,这是重复定义 student s; count = 5; s.age = min(43, 32);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数]]></title>
    <url>%2F2018%2F12%2F07%2FC%2B%2B%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参数传递值传递1234567891011/* 使用值传递，当实参值过大或过多时，赋值给形参这个过程会大大降低程序运行的效率 */void swap(int a, int b) &#123;// 很明显，使用值传递是无法实现x, y交换的目的的 int temp = a; a = b; b = temp;&#125;x = 10;y = 5;swap1(x, y);// x, y的值传给形参a, b 指针传递123456789void swap2(int *a, int *b) &#123;// 通过x, y的指针直接改变x, y指向的数据，函数内的操作可以影响外部 int temp = *a; *a = *b; *b = temp;&#125;x = 10;y = 5;swap2(&amp;x, &amp;y); 1234567891011121314151617181920// 对数组进行操作一般使用指针传递void sortArr(int arr[6]) &#123; //这里的 6 只是一个期望值，实际上对形参并没有约束作用,即等价于int arr[]或int *arr for (int i = 0; i &lt; 6 - 1; i++) &#123; for (int j = 0; j &lt; 6 - i - 1; j++) &#123; if (a[j] &gt; a[j+1]) &#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;&#125;/* 要想确定数组的大小，还是得显示指定 数组尺寸 n,即sortArr(int a[], int n)*/void main() &#123; int b[] = &#123; 21, 13, 4, 1, 7, 5 &#125;; sortArr(b);&#125; 引用传递 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;void swap(int &amp;a, int &amp;b) &#123; int temp = a; a = b; b = temp;&#125;void main() &#123; int x = 5, y = 10; swap(x, y); cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;\ty = &quot; &lt;&lt; y &lt;&lt; endl;&#125;/* 运行结果： x = 10 y = 5*/// 由于传给函数形参的本质上是实参的地址，故不能向函数传入常数int x = 5;swap(3, 4); // errorswap(x, 9); // errorswap(6, x); // error 函数默认参数1234567891011#include &lt;iostream&gt;using namespace std;double sqrt(double f = 1.0);void main() &#123; cout &lt;&lt; sqrt() &lt;&lt; endl; // 使用默认参数 cout &lt;&lt; sqrt(5) &lt;&lt; endl;&#125;double sqrt(double f) &#123; return f * f;&#125; 使用默认参数要注意以下三点： &emsp;&emsp;①在指定某个函数的默认值时,如果它有函数原型,就只能在函数原型中指定对应数的默认值,不能在定义函数时再重复指定参数默认值。当然,若函数是直接定义的,没有函频原型,若要指定参数默认值,在定义时指定就行了。&emsp;&emsp;②在具有多个参数的函数中指定默认值时,所有默认参数都必须出现在无默认值参数的右边。即,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值。123int f(int i1, int i2, int i3 = 0);int g(int i1, int 12 = 0, int i3); // error,i3没有默认值int h(int i1=0, int i2, int i3=0); // error,i1默认后,其右边的i2没有默认值 &emsp;&emsp;③可以用表达式作为默认参数,只要表达式可以转换成形参所需的类型即可。但是,局部量不能作为默认参数值。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 定义全局变量string name = &quot;tom&quot;;double h = 0.8, len = 1.1;void dog(string dogname = name, double high = h, double length = len) &#123; cout &lt;&lt; &quot;Dogname： &quot; &lt;&lt; dogname &lt;&lt; &quot;\tHigh：&quot; &lt;&lt; h &lt;&lt; &quot;\tLength：&quot; &lt;&lt; len &lt;&lt; endl;&#125;int main() &#123; name = &quot;Jake&quot;; // 修改全局变量以改变参数name的默认值 double h = 2.1; // 重新定义一个局部变量h，与全局变量h无关，对参数high的默认值无影响 dog(); return 0;&#125;/* 运行结果如下：Dogname：Jake High：0.8 Length：1.1*/ 函数返回值默认返回值和void的返回值 &emsp;&emsp;每个函数最后都是通过return语句来结束调用的(返回值为void的函数没有return语句，但系统会在该函数的最后一条语句的后面隐式地执行return语句)123456789101112131415161718int maxArr(int a[], int n) &#123;// 在最新的C++11中的标准中，函数没有默认返回值了(在C语言和早期的C++中，函数的默认返回值为int) int max = a[0]; for (int i = 1; i &lt; n; i++) &#123; if (max &lt; a[i]) max = a[i]; &#125; return max;&#125;void swap(int &amp;a, int &amp;b) &#123; if (a = b) return; else &#123; int t = a; a = b; b = t; &#125;&#125; 返回引用12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int temp;int&amp; f(int i1, int i2) &#123; temp = i1 + i2; return temp; // 返回 temp的引用&#125;void main() &#123; int t = f(1, 3); cout &lt;&lt; temp &lt;&lt; &quot; &quot;; f(2, 8)++; cout &lt;&lt; temp &lt;&lt; &quot; &quot;; f(2, 3) = 9; cout &lt;&lt; temp &lt;&lt; endl;&#125;/* 运行结果如下： 4 11 9*/ 1234int &amp;g(int i1, int i2) &#123; // error// 返回值为引用的函数应该return一个变量，而不能是表达式 return i1 + i2;&#125; 12345678910const int &amp;g(int i1, int i2) &#123; return i1 + i2;&#125;// 函数返回值为常量引用值时可以return表达式/* 函数返回表达式的隐式过程：int temp = i1 + i2;return temp;一般情况下，函数返回temp的值后，temp就会被回收但返回值为const type&amp;时，temp会被保留，将temp的地址作为返回值，直到使用函数返回值的那个变量的作用域结束后才被回收*/ 函数重载123456789101112/* 重载函数必须具有不同的形参列表 */#include &lt;iostream&gt;using namespace std;int Abs(int x) &#123; return x &gt; 0 ? x : -x; &#125;float Abs(float x) &#123; return x &gt; 0 ? x : -x &#125;double Abs(double x) &#123; return x &gt; 0 ? x : -x; &#125;void main() &#123; cout &lt;&lt; Abs(-9) &lt;&lt; endl; cout &lt;&lt; Abs(-9.9f) &lt;&lt; endl; cout &lt;&lt; Abs(-9.8) &lt;&lt; endl;&#125; 重载函数注意事项: &emsp;&emsp;① 返回值不同并不能作为重载函数的依据。1234567// 重载函数int f(int, int)double f(int)int f(char)// 只有返回类型不同，而函数名和参数表都完全相同的函数只能看作是同一函数的重复声明int f(int);double f(int); &emsp;&emsp;② 在定义和调用重载函数时，要注意它的二义性。12345int f(int&amp; x) &#123;...&#125;double f(int x) &#123;...&#125;int a = 1;f(a); // error,产生二义性，无法确定调用的是f(int&amp; x)还是f(int x)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++z作用域与生命周期]]></title>
    <url>%2F2018%2F12%2F07%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[作用域&emsp;&emsp;C++的作用域大致可以分为全局作用域、局部作用域和文件作用域三种。还有一种更细的分法，按照作用域范围从大到小分为程序作用域，文件作用域，类作用域，函数作用域和块作用域5种类型。 ①程序作用域: &emsp;&emsp;指一个标识符在整个程序范围内有效。若一个程序由多个文件组成,具有这种作用域的标识符可以在该程序的各文件中应用。具有程序作用域的标识符只能在某个文件中定义一次,在要使用它的文件中用 extern声明。例如,如果有10个文件都要用到某个变量,这个变量也只能在一个文件中定义,在其他9个文件中必须用extern声明后才能使用。 ②文件作用域: &emsp;&emsp;指在一个文件中所有函数定义之外定义的名字(包括函数名),其有效范围为从定义它的语句位置开始,直到文件结束。具有文件作用域的名字只能在定义它的文件中使用,但不能在组成同一程序的其他文件中使用。 ③函数作用域: &emsp;&emsp;指在函数范围内有效的标志符。 ④块作用域: &emsp;&emsp;写在{}内的一条或多条语句就构成了一个语句块,在其中定义的标识符就只能在这对“{}”中使用,而且只在定义(或声明)它的语句位置到离它最近的“}”之间有效,即只能在这段代码区域内引用它,这就是块作用域在C++中,任何在“{}”中定义或声明的标识符都具有块作用域。局限在一个函数内部的标识符都具有块作用域,包括在函数内部定义的变量或对象、函数的形式参数等。 ⑤作用域限定符: &emsp;&emsp;在函数中,一旦在当前作用域中找到了需要的名字,编译器就会忽略外层作用域中的同名实体。也就是说,若局部变量和某个全局变量同名,局部变量名会隐藏全局变量名。在这种情况下,可用作用域限定符“:”存取全局变量的值。 1234567891011121314151617/* 最外层的i和函数f()具有文件作用域 *//* f()内为块作用域 */int i;int f() &#123; int i; i = 1; // 修改f()中定义的局部变量i ::i = 0; // 修改全局变量i &#123; int j = 0; static int k; i = 2; // 修改f()中定义的局部变量i ::i = 3; // 修改全局变量i &#125; j = 2; // error,k已被回收 return k; // k已失去作用域&#125;/* 由于局部变量在函数运行结束时它的那个内存地址会被回收以重新分配给其他数据，所以不要在函数内返回局部变量的地址和引用。 */ 12345678/* if语句里的作用域 */if(int i = 5) &#123; // i的作用域自此开始 int p = 0; // p的作用域自此开始&#125; // p的作用域到此结束else &#123; i = 1; p = 2 // error, p已无定义&#125; // i的作用域到此结束 123456789/* switch语句中的变量作用域 */void f(int i) &#123; switch(int j = i) &#123; // j的作用域自此开始 case 1: j = j + 1; case 2: case 3: cout &lt;&lt; j; &#125; // j的作用域到此结束 cout &lt;&lt; j &lt;&lt; endl; // error,j已无定义&#125; 123456789/* 循环语句中的作用域 */// C++新标准中，for循环中允许初始化i变量void f1(int z) &#123; for(int i = 0; i &lt; z; i++) &#123; // i的作用域开始 int j = i; cout &lt;&lt; i * j &lt;&lt; endl; &#125; // i的作用域到此结束 cout &lt;&lt; i &lt;&lt; endl; // error, i已无定义&#125; 变量类型与生命期&emsp;&emsp;根据变量的作用域范围,变量可分为全局变量和局部变量两大类。在函数内部定义的变量就是局部变量(包括函数参数),它们只能在定义它的函数中使用;在函数之外且不在任何一对“{”内定义的变量(不属于任何函数)就是全局变量,其有效范围从其在文件中的定义位置开始到文件结束。&emsp;&emsp;变量的生命期是指变量在内存中存在的时间,生命期与变量所在的内存区域有关。为了更清楚地理解这个问题,先看看运行程序对内存的应用情况。个程序在其运行期间,它的程序代码和数据会被分别存储在4个不同的内存区域中,如图所示。 程序代码区:程序代码(即程序的各函数代码)存放在此区域中。 全局数据区:程序的全局数据(如全局变量)和静态数据( static)存放在此区域中。 栈区:程序的局部数据(在函数中定义的数据)存放在此区域中。 堆区:程序的动态数据(new、 malloc就在此区域中分配存储空间)存放在此区域中。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;全局数据区中的数据由C++编译器建立,对于定义时没有初始化的变量,系统会自动将其初始化为0.这个区域中的数据一直保存,直到程序结束时才由系统负责回收。&emsp;&emsp;堆区的数据由程序员管理,程序员可用new或malloc分配其中的存储单元给指针变量,用完之后,由程序员用delete或free将其归还系统,以便其他程序使用。&emsp;&emsp;在函数中定义的局部变量(除了static类型的局部变量外,static类型的变量在全局数据区中),只有当函数被调用时,系统才会为函数建立堆栈,并在栈区中为函数中定义的局部变量分配存储空间,且不会对分配的存储单元做初始化工作。一旦函数调用完成,系统就会回收这些变量在栈区中的存储单元。&emsp;&emsp;全局变量和静态变量存储在全局数据区中,它们具有较长的生命期。非静态的局部变量存储在栈区中,其生命期很短,只在函数调用期间有效。&emsp;&emsp;静态变量可分为静态全局变量和静态局部变量,前者的作用域是整个程序范围,后者的作用域局限于定义它的语句块。静态局部变量的作用域与普通局部变量的作用域是相同的,但它与全局变量有着同样长的生命期,即程序结束时它才会被释放。普通局部变量的生命期只有函数调用期向才存在,函数调用完成后就结束了。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;static int n; // n被初始化为0void f() &#123; static int i; // i被初始化为0 int j = 0; i += 2; j += 2; cout &lt;&lt; &quot;i = &quot; &lt;&lt; &quot;, &quot;; cout &lt;&lt; &quot;j = &quot; &lt;&lt; endl;&#125;void main() &#123; n += 5; f(); // 输出i = 2, j = 2 i = 2; // error,i作用域为f()内部 f(); // 输出i = 4, j = 2&#125; // i, n的生命期到此结束 初始化列表，变量初始化与赋值&emsp;&emsp;变量在被创建时就获得一个指定的值，称为初始化。初始化值可以是任意复杂的表达式，当同时定义多个变量时，位于前面的变量马上就能够用于初始化另一个变量，即int i = 10, j = i * 10。&emsp;&emsp;初始化的方式一般有以下几种:123456/* 这四种初始化方式是等价的 */int x = 0;int x(0);/* 后两种称为初始化列表方式 */int x = &#123;0&#125;;int x&#123;0&#125;; &emsp;&emsp;后两种方式是C++ 11新标准的一部分，”{}”除了用于变量初始化，还可用于赋值。而在此前的C++标准中，只有部分场合才允许使用这种初始化方式，如数组初始化。 初始化与赋值:1234int x = 10;int x;x = 10; &emsp;&emsp;虽然x的最终值都是10，但x = 10是赋值语句，可以理解为:先除掉x对应内存单元中的值，再写入10，而int x = 10没有这个过程，它是在为x分配内存单元的同时就写入10。全局变量，静态变量与局部变量的存储位置: &emsp;&emsp;变量初始化的默认规则是:如果定义变量时提供了初始值表达式,系统就用这个表达式的值作为变量的初值:如果定义变量时没有为它提供初值,则全局数据区中的变量将被系统自动初始化为0,栈和堆中的变量不被初始化。&emsp;&emsp;全局变量、命名空间的变量、静态变量会被保存在全局数据区中,所以它们会被系统自动初始化为0;局部变量(也叫自动变量)被存储在栈区中;动态分配的变量(用malloc和new建立)被存储在堆区中,它们都不会被系统用默认值初始化。 1234567891011121314151617181920212223/* 全局变量，静态变量，局部变量的初始化 */#include &lt;iostream&gt;using namespace std;int n; // 初始化为0void f() &#123; static int i; // 初始化为0 int j; // 未初始化，j值不确定 cout &lt;&lt; &quot;i = &quot; &lt;&lt; &quot;, &quot;; cout &lt;&lt; &quot;j = &quot; &lt;&lt; endl;&#125;int *p1; // p1被初始化为0void main() &#123; int *p2; // p2未被初始化，值未知 int m; // m未被初始化，值未知 f(); // 输出i = 0, j = ?, ?表示一个不确定的一个值 cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // 输出n = 0 cout &lt;&lt; &quot;m = &quot; &lt;&lt; m &lt;&lt; endl; // 输出m = ?, ?表示一个不确定的一个值 if (p1) cout &lt;&lt; &quot;p1 = &quot; &lt;&lt; p1 &lt;&lt; endl; // p1 = 0, 无输出 if (p2) cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2 &lt;&lt; endl; // 输出p2 = ?, ?表示不确定地址&#125; &emsp;&emsp;综上所述，最好对变量初始化，以免局部变量的不确定值引起程序错误。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常量]]></title>
    <url>%2F2018%2F12%2F07%2FC%2B%2B%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[常量的定义 在C++中，定义常量可以使用const或constexpr。123456789101112131415const char c = &apos;A&apos;; // 常量必须在定义时进行初始化int i, j = 10;const int k = i + j + 5; // 表达式可以用来初始化常量/* constexpr与const基本类似，但constexpr常量必须在编译时就被初始化，而const常量可以延迟到运行时被初始化*/const int n = f();constexpr int num = f(); // error,编译时不知道f()的返回值constexpr int t = j + 10; // error,j是变量,编译时还不知道j的值int f() &#123; return 10;&#125; const与指针 123456789101112131415161718192021222324252627/* 指针实际上可以看作是两部分，对象的地址和所指向对象的值 *//* =&gt; 底层const： const type *p1; // *p1不可变(该内存处存储的变量不可变)，p1可变 =&gt; 顶层const： type *const p2; // p2不可变(始终指向同一块内存),*p2可变*/#include &lt;iostream&gt;using namespace std;int main() &#123; char *const p0; // error,p0未初始化 char *const p1 = &quot;dukang&quot;; char const *p2; const char *p3 = &quot;dukang&quot;; const char *const p4 = &quot;dukang&quot;; const char *const p5; // error,p5是常量，必须初始化 p1 = &quot;wankang&quot;; // error,p1是常量，不可变更 p2 = &quot;wankang&quot;; p3 = &quot;wankang&quot;; p4 = &quot;wankang&quot;; // error,p4是常量，不可变更 p1[0] = &apos;w&apos;; p2[0] = &apos;w&apos;; // error,*p2是常量 p3[0] = &apos;w&apos;; // error,*p3是常量 p4[0] = &apos;w&apos;; // error,*p4是常量 return 0;&#125; const与引用 12345int i = 9;int &amp;rr = i;const int &amp;ri = i;rr = 8;ri = 7; // error,ri是常量，不允许通过它来修改i的值 12345int i = 2;const double &amp;ff = 10.0; // 常量引用可以用常量初始化// 等价于 double temp = 10.0;const double &amp;ff = tempconst int &amp;ri = i + 10;int &amp;ii = 3; // error,非常量引用不能用常量初始化]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件的读写]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;程序与文件的数据交换方法同它与标准输入/输出设配的数据交换方法相同。从文件读取数据与从键盘输入数据的方法相似，将数据写入文件与将数据输出到显示器的方法相似。但iostream中定义的数据类型和函数只能用于标准输入/输出设配的数据处理。C++将处理文件的数据类型放在了头文件fstream里，分为ofstream和ifstream。文件流操作一般包括五个步骤:12345678910111213141516171819202122232425262728293031/* &lt;1&gt; 包含头文件 */#include &lt;fstream&gt;using namespace std;/* &lt;2&gt; 定义文件流句柄file_handler */ifstream inData;ofstream outData;/* &lt;3&gt; 将文件流句柄与磁盘文件filename关联起来 */file_handler.open(filename, mode)/* 打开或建立文件的模式mode的可选值: ios::in // 打开输入文件，ifstream类型变量的默认方式 ios::out // 建立输出文件，ofstream类型变量的默认方式 ios::app // 增加方式，若文件存在，将在文件尾增加数据，否则就建立文件 ios::trunk // 若文件存在，则文件中已有内容将被清除 ios::nocreate // 若文件不存在，则打开操作失败 ios::noreplace // 若文件存在，则打开操作失败*//* 打开一个文件: ofstream outData; outData.open("abc.txt", ios:in);或将&lt;2&gt;,&lt;3&gt;合为一步: ofstream outData("abc.txt", ios::in)*//* &lt;4&gt; 用文件流(&lt;&lt;或&gt;&gt;)操作文件，读/写文件数据，将输入文件流与&gt;&gt;连接，就能够从文件中读入数据，与cin用法相同。将输出文件流与&lt;&lt;连接，就能够从文件中读入数据，与cout用法相同。 *//* &lt;5&gt; 关闭文件 */inData.close();ourData.close(); 示例1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;void main() &#123; ofstream outData(&quot;C:\\data.txt&quot;); // 前一个 / 用于转义 ifstream inData; int x, a[10]; for (int i = 0; i &lt; 10; i++) &#123; cin &gt;&gt; x; outData &lt;&lt; x &lt;&lt; &quot; &quot;; // 将x的值写入文件流句柄outData指向的文件data.txt中 &#125; outData.close(); inData.open(&quot;D:\\data.txt&quot;); int j = 0; while(!inData.eof()) inData &gt;&gt; a[j++]; // 将data.txt中的数据载入数组a[]中 inData.close(); int s = 0; for (int i = 0; i &lt; 10; i++) &#123; s += a[i]; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;the sum is: &quot; &lt;&lt; s &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++引用]]></title>
    <url>%2F2018%2F12%2F07%2FC%2B%2B%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;void main() &#123; int i = 9; int &amp;ri = i; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl; ri = 20; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl; i = 12; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;ri = &quot; &lt;&lt; ri &lt;&lt; endl; cout &lt;&lt; &quot;i 的地址是：&quot; &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; &quot;ri 的地址是：&quot; &lt;&lt; &amp;ri &lt;&lt; endl; &#125;/* 运行结果： i = 9 ri = 9 i = 20 ri = 20 i = 12 ri = 12 i 的地址是： 0029FDB0 ri 的地址是： 0029FDB0*/ 可以看到，ri和i指的实际上是同一个变量(内存地址)，对ri的操作实际上就是对i的操作，ri可以看做是i的别名。使用引用时需要注意以下几个问题：&emsp;&emsp;① 在定义引用时，&amp;在类型与引用名之间的位置是灵活的，故以下几种定义完全等价：1int&amp; ri = i; int &amp; ri = i; int &amp;ri = i; &emsp;&emsp;② 在变量声明时出现的&amp;才是引用运算符(包括函数参数声明和函数返回类型的声明)，其它地方出现的&amp;则是地址操作符。12345int i;int &amp;r = i; // 引用int&amp; f(int &amp;i1, int &amp;); // 引用参数(声明参数变量)int *p = &amp;i; // &amp;取i的地址cout &lt;&lt; &amp;p; // &amp;取p的地址 &emsp;&emsp;③ 引用必须在定义时初始化，不能在定义完成后再给它赋值;为引用提供的初始值可以是一个变量名，也可以是另一个引用名，也可以是另一个引用名;同一个变量可以定义多个引用。12345float f;float &amp;fr; // error,引用定义时未初始化float &amp;r1 = f; // r1 &lt;=&gt; ffloat &amp;r2 = f; // r2 &lt;=&gt; ffloat &amp;r3 = r1; // r3 &lt;=&gt; r1 &lt;=&gt; f &emsp;&emsp;④引用对应着变量的左值，代表变量的内存区域，实际是一种隐式指针，但与指针存在区别。&emsp;&emsp;引用与指针的区别。1234567void main() &#123; int i = 9; int *pi = &amp;i; // 取地址 int &amp;ri = i; // 定义引用 *pi = 2; ri = 8; // ri等价于*pi&#125; 可以看到，引用本质上也是指针的一种隐式封装，即将*pi简化为ri。但它与指针至少存在两点区别： 指针必须通过解引用运算符”*”才能访问它所指向的内存单元，而引用则与普通变量的访问方法差不多; 指针是一个变量，它有自己独立的内存区域，可以对它重新赋值，让它指向其他地址。但引用只是某个变量的别名，甚至没有自己独立的内存区域，必须在定义时进行初始化，并且一经定义就再也不能作为其他变量的引用了。 &emsp;&emsp;⑤ 当用&amp;运算符获取一个引用的地址时，实际取出的是引用对应的变量的地址。例如：123int i = 9;int &amp;ri = i;int *pi = &amp;ri; // pi的值实际上是i(ri是i的别名引用)的地址 &emsp;&emsp;⑥ 建立引用时，引用应当类型匹配。12double d;int &amp;rd = d; // 引用类型与它对应的变量类型不匹配 &emsp;&emsp;⑦ 引用与数组。可以建立数组或数组元素的引用，但不能建立引用数组。1234567int i = 0, a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;, *b[10];int (&amp;ra)[10] = a; // ra是具有10个元素的整型数组的引用int &amp;aa = a[0]; // 数组元素的引用int *(&amp;rpa)[10] = b; // rpa是具有10个整型指针的数组的引用int &amp;ai[10] = a; // error,ai是引用数组(每个数组元素都是引用)，这是不允定义的ra[3] = 0; // 数组引用的用法rpa[3] = &amp;i; // &emsp;&emsp;⑧ 引用与指针。可以建立指针的引用，但不能创建指向引用的指针。1234int i = 0, a[10];int &amp;*ip = i; // error,ip是指向引用的指针int *pi = &amp;i;int *pr = pi; // pr是指针的引用]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
