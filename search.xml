<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Qt控件及对话框]]></title>
    <url>%2F2018%2F12%2F01%2FQt%E6%8E%A7%E4%BB%B6%E5%8F%8A%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;当QML第一版发布时，QML缺少开发应用程序所必须的一些通用控件，这需要开发者自己编写，但效果往往差强人意。 &emsp;&emsp;Qt 5.1为QML增加了独立的模块Qt Quick Controls和Qt Quick Dialog，这些模块提供了很多QML通用的控件以及通用对话框，用于构建完整的应用程序界面。 第一个实例首先我们先来看看使用Qt Quick Controls模块的第一个例子:123456789101112131415161718192021import QtQuick 2.2import QtQuick.Controls 1.2import QtQucik.Window 2.1ApplicationWindow &#123; title: qsTr(&quot;Hello World&quot;) width: 640; height: 480 menuBar: MenuBar &#123; Menu &#123; title: qsTr(&quot;File&quot;) MenuItem &#123; text: qsTr(&quot;Exit&quot;) onTriggered: Qt.quit() &#125; &#125; &#125; Button &#123; text: qsTr(&quot;Hello World&quot;) anchors.horizontalCenter: parent.horizontalCenter anchors.verticalCenter &#125;&#125; &emsp;&emsp;QtQuick Controls的根容器是ApplicationWindow，这是一个类似于QMainWindow的类型，拥有自己的菜单栏，工具栏和状态栏。 ApplicationWindow应用程序窗口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Layouts 1.1ApplicationWindow &#123; id: window; width: 800; height: 600 contentItem.minimumWidth: 400; contentItem.minimumHeight: 300; contentItem.maximumWidth: 800; contentItem.maximumHeight: 600 // 中心区域 TextArea &#123; id: myContent; anchors.fill: parent &#125; Action &#123; id: quitAction; text: qsTr(&quot;Quit&quot;) shortcut: &quot;ctrl+q&quot;; iconSource: &quot;images/quit.png&quot; onTrigger: Qt.quit() &#125; Action &#123; id: quitAction; text: qsTr(&quot;Cut&quot;) shortcut: &quot;ctrl+x&quot;; iconSource: &quot;images/cut.png&quot; onTrigger: myContent.Cut() &#125; Action &#123; id: quitAction; text: qsTr(&quot;Copy&quot;) shortcut: &quot;ctrl+c&quot;; iconSource: &quot;images/copy.png&quot; onTrigger: myContent.Copy() &#125; Action &#123; id: quitAction; text: qsTr(&quot;Paste&quot;) shortcut: &quot;ctrl+v&quot;; iconSource: &quot;images/paste.png&quot; onTrigger: myContent.Paste() &#125; // 菜单栏 menuBar: MenuBar &#123; Menu &#123; title: qsTr(&quot;&amp;File&quot;) MenuItem: &#123; action: quitAction &#125; &#125; Menu &#123; title: qsTr(&quot;&amp;Edit&quot;) MenuItem &#123; action: cutAction &#125; MenuItem &#123; action: copyAction &#125; MenuItem &#123; action: pasteAction &#125; &#125; &#125; // 工具栏 toolBar: ToolBar &#123; id: mainToolBar width: parent.width Row &#123; anchors.fill: parent ToolButton &#123; action: cutAction &#125; ToolButton &#123; action: copyAction &#125; ToolButton &#123; action: pasteAction &#125; &#125; &#125; // 状态栏 statusBar: StatusBar &#123; RowLayout &#123; Label &#123; text: &quot;Ready.&quot; &#125; Label &#123; text: &quot;Welcome.&quot; &#125; &#125; &#125;&#125; 1. Action&emsp;&emsp;Action控件类似于QAction类，其内封装了应用程序中的动作命令，Action可以添加到菜单，工具条中，由用户触发或通过快捷键调用。 &emsp;&emsp;使用Action最大的好处是多个位置的action可以自动同步，比如，如果将一个action加入到菜单栏和工具栏，当action被修改时，菜单栏和工具栏对应的按钮就会同步做出改变。QtQuick支持为Button，ToolButton和MenuItem添加Action。 2. 菜单类控件&emsp;&emsp;ApplicationWindow有一个menuBar属性，拥有设置菜单栏，menuBar属性要指定一个MenuBar类型对象。MenuBar只有menus和style两个属性，其中menus是list类型，这意味着可以向MenuBar添加Menu类型的子控件。Menu对应着QMenu，它可以作为菜单栏的顶层菜单，也可以作为另外菜单的子菜单，独立菜单或上下文菜单。 &emsp;&emsp;Menu有一个items属性，用来设置菜单的子项目，虽然这个属性的类型是list，但实际上，它仅支持Menu，MenuItem和MenuSeparator这三种类型的对象作为其输入。&emsp;&emsp;其中，Menu可以作为当前菜单的子菜单;MenuItem可以作为当前菜单的菜单栏，MenuSeparator作为当前菜单的分隔符。 &emsp;&emsp;Menu类型包含了一系列有用的方法，例如添加菜单项addItem()，添加子菜单addMenu()，添加分隔符addSeparator()，插入菜单项insertItem()，插入菜单insertMenu()，插入分隔符insertSeparator()，移除项removeItem()以及在光标划过处打开菜单popup()。 3. StatusBar&emsp;&emsp;ApplicationWindow的statusBar属性用于向应用程序窗口添加状态栏，这个属性的类型是Item，隐因此可以将任何Item对象设置为状态栏，但最常见的还是使用StatusBar控件。 &emsp;&emsp;使用时，要自己为StatusBar添加布局管理器，一般是RowLayout布局管理器，用于排列添加到状态栏的控件。 4. 工具栏类控件&emsp;&emsp;ToolBar与StatusBar类似，这个属性的类型也是Item，一般为其添加RowLayout布局管理器。添加到工具栏的按钮可以是ToolButton类型，ToolButton是Button的子类，这是一种专门为工具栏显示优化的按钮。 WindowApplicationWindow是Window的子类。1234567891011121314151617181920212223242526import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; width: 400; height: 400 color: &quot;gray&quot;; opacity: 0.6 x: 300; y: 300 Window &#123; id: dialog; title: &quot;Dialog&quot; width: 200; height: 200 flags: Qt.Dialog // Window.flag设置为Qt.Dialog表示该窗口是一个对话框 Label &#123; width: parent.width; height: parent.height text: &quot;This is a dialog&quot; horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter &#125; onClosing: console.log(&quot;quit!&quot;); // 窗口关闭信号close的信号处理器 &#125; Button &#123; text: qsTr(&quot;Open&quot;); anchors.centerIn: parent onClicked: &#123; dialog.show(); &#125; &#125;&#125; 按钮类控件&emsp;&emsp;QtQuick Controls中提供了5类按钮:Button，checkBox，RadioButton，Switch和ToolButton。 1. ExclusiveGroup&emsp;&emsp;一般的按钮都包含一个ExclusiveGroup属性，需要为其指定一个ExclusiveGroup类型的对象。ExclusiveGroup类型可以包含多个Action对象，使得这些Action能够彼此互斥。当Action被添加到ExclusiveGroup时，ExclusiveGroup对象会自动赋值给每一个Action对象的Action::exclusiveGroup属性。 1234567891011121314151617181920import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; ExclusiveGroup &#123; id: radioInputGroup Action &#123; id: dabRadioInput; text: &quot;DAB&quot;; checkable: true &#125; Action &#123; id: fmRadioInput; text: &quot;FM&quot;; checkable: true &#125; Action &#123; id: amRadioInput; text: &quot;AM&quot;; checkable: true &#125; &#125; toolBar: ToolBar &#123; id: mainToolBar; width:parent.width Row &#123; anchors.fill: parent ToolButton &#123; action: dabRadioInput &#125; ToolButton &#123; action: fmRadioInput &#125; ToolButton &#123; action: amRadioInput &#125; &#125; &#125;&#125; &emsp;&emsp;ExclusiveGroup仅支持将Action对象添加为自己的子元素，所以当我们需要使用其他控件时，只能显式地将ExcludiveGroup对象赋值给这些元素各自的exclusiveGroup属性。 123456789101112131415161718192021222324import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; ExclusiveGroup &#123; id: radioInputGroup &#125; toolBar: ToolBar &#123; id: mainToolBar; width: parent.width Row &#123; anchors.fill: parent ToolButton &#123; id: dabRadioInput; text: &quot;DAB&quot;; checkable: true; exclusiveGroup: radioInputGroup &#125; ToolButton &#123; id: fmRadioInput; text: &quot;FM&quot;; checkable: true; exclusiveGroup: radioInputGroup &#125; ToolButton &#123; id: amRadioInput; text: &quot;AM&quot; checkable: true; exclusiveGroup: radioInputGroup &#125; &#125; &#125;&#125; 2. Button&emsp;&emsp;Button对应着Qt中的QPushButton，Button既可以使用Action进行初始化，也可以通过自身属性初始化。 &emsp;&emsp;Button有一个menu属性，可以为这个按钮添加菜单:12345678910111213import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; Button &#123; x: 10; y: 10; width: 140 text: qsTr(&quot;Button with menu&quot;) menu: Menu &#123; MenuItem &#123; text: qsTr(&quot;Item1&quot;) &#125; MenuItem &#123; text: qsTr(&quot;Item2&quot;) &#125; &#125; &#125;&#125; &emsp;&emsp;与QPushButton一样，Button也提供了checkable和checked属性，可以将按钮设置为有状态的形式，Button的exclusiveGroup属性可以将几个Button对象组成一个互斥的组，当其中之一被选择时，其余的按钮会自动取消选择。 3. CheckBox&emsp;&emsp;CheckBox对应着Qt中的QCheckBox。CheckBox有选中和未选中状态，实际上，CheckBox还有处于一种”部分选中”的状态，可以将partiallyCheckedEnabled设为true来开启这种状态。 12345678910import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; CheckBox &#123; width: 140 text: qsTr(&quot;3 - state CheckBox&quot;) partiallyCheckedEnabled: true &#125;&#125; &emsp;&emsp;CheckBox的exclusiveGroup属性可以将几个CheckBox对象组成一个互斥的组，当其中之一被选择时，其余会自动取消选择。 4. RadioButton123456789101112131415161718import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; Column &#123; // 定义一个ExclusiveGroup组 ExclusiveGroup &#123; id: group &#125; RadioButton &#123; text: qsTr(&quot;From top&quot;) exclusiveGroup: group // 属于同一组的按钮互斥 checkable:.true &#125; RadioButton &#123; text: qsTr(&quot;From cursor&quot;) exclusiveGroup: group &#125; &#125;&#125; 5. Switch&emsp;&emsp;Switch是从移动平台引入的一个控件，用于表示相对独立的，具有启用和禁用两种状态的情况，它非常类似CheckBox。 12345678910import QtQuick 2.3import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; Column &#123; spacing: 8 Switch &#123; checkable: true &#125; Switch &#123; checkable: false &#125; &#125;&#125; 数据选择类控件1. ComboBox下拉选择框。12345ComboBox &#123; width: 200 // 数据模型 model: [ &quot;Banana&quot;, &quot;Apple&quot;, &quot;Coconut&quot; ]&#125; ComboBox还可以使用ListModel作为数据模型。123456789101112131415import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; ComboBox &#123; width: 200; currentIndex: 2 model: ListModel &#123; id: cbItems ListElement &#123; text: &quot;Banana&quot;; color: &quot;Yellow&quot; &#125; ListElement &#123; text: &quot;Apple&quot;; color: &quot;Green&quot; &#125; ListElement &#123; text: &quot;Coconut&quot;; color: &quot;Brown&quot; &#125; &#125; onCurrentIndexChanged: console.debug(cbItems.get(currentItem).text + &quot;, &quot; + cbItems.get(currentIndex).color) &#125;&#125; &emsp;&emsp;ComboBox的editable属性可以设置这个ComboBox是否可编辑，将其设为true时，下拉框允许用户编辑数据。accepted信号确定是否可以将用户输入的数据添加到下拉框中，不过，在添加新数据之前，需要确定下拉框中是否存在重复项。 123456789101112131415161718192021import QtQuick2 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; ComboBox &#123; id: editableCombo; editable: true model: ListModel &#123; id: model ListElement &#123; text: &quot;Banana&quot;; color: &quot;Yellow&quot; &#125; ListElement &#123; text: &quot;Apple&quot;; color: &quot;Green&quot; &#125; ListElement &#123; text: &quot;Coconut&quot;; color: &quot;Brown&quot; &#125; &#125; onAccepted: &#123; if(editableComboBox.find(currentText) === -1) &#123; // currentText即用户输入的内容 model.append(&#123;text: editText&#125;) currentIndex = editableCombo.find(editText) &#125; &#125; &#125;&#125; 2. Slider123456789import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; Slider &#123; minimumValue: 0; maximumValue: 100 stepSize: 1; onValueChanged: console.log(value) &#125;&#125; 3. SpinBox&emsp;&emsp;SpinBox对应着Qt中的QSpinBox，允许用户通过单击上下按钮或使用上下键来改变数值，SpinBox的默认范围是[0-99]，默认精度decimals是0。 12345678910import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; SpinBox &#123; minimumValue: -5; maximumValue: 10 prefix: &quot;Today&quot;; suffix: &quot;Degree&quot; decimals: 1; stepSize: 0.1 &#125;&#125; 文本类控件1. TextField&emsp;&emsp;TextField对应Qt中的QLineEdit，是一个单行的输入框允许用户输入和编辑单行的文本，TextField可以使用cut()，copy()和paste()实现剪贴板的剪贴，复制和粘贴等操作。在粘贴之前，可以使用canPaste测试其是否允许粘贴操作。 &emsp;&emsp;与QLineEdit类似，TextField有四种显示模式，使用echoMode属性进行设置，其值是一个enumeration类型，允许的值包括: TextInput.Normal: 默认值，正常显示输入的内容 TextInput.Password: 密码样式，以黑点或星号显示 TextInput.NoEcho: 不显示任何输入 TextInput.PasswordEchoOnEdit:在编辑时显示正常输入的内容，其余情况下则显示为密码样式 &emsp;&emsp;TextField支持输入掩码限制输入的内容，输入掩码使用inputMask属性设置，可以利用一些特殊字符指定输入的格式和内容，也可以validator属性给TextField设置验证器。 12345678910111213import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; TextField &#123; y: 10; width: 200 placeholderText: &quot;Please enter a password&quot; // 占位符 echoMode: TextInput.PasswordEchoOnEdit validator: IntValidator&#123;bottom: 11; top: 31&#125; // 输入限制在11-31字 onAccepted: console.debug(text) &#125; TextField &#123; y: 40; width: 200 &#125;&#125; 2. TextArea&emsp;&emsp;TextArea对应着QTextEdit,是一个多行的文本输入框，与TextField的纯文本不同，TextArea支持富文本显示，这可以通过textFormat来设置。 12345678910111213141516import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; TextArea &#123; id: textArea_1; width: 240; height: 100 textFormat: TextEdit.RichText font.pointSize: 13 text: &quot;&lt;b&gt;Hello&lt;/b&gt;&lt;i&gt;World!&lt;/i&gt;&quot; &#125; TextArea &#123; id: textArea_2; y: 100; width: 240 textFormat: TextEdit.PlainText text: &quot;&lt;b&gt;Hello&lt;/b&gt;&lt;i&gt;World!&lt;/i&gt;&quot; &#125;&#125; 其他控件1. Label&emsp;&emsp;Label对应着QLabel，用于显示普通文本，与TextArea类似，Label既可以纯文本，也可以显示富文本。Label继承自Text类型，所以包含了Text的所有特点。 123456789101112import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; Label &#123; textFormat: TextEdit.PlainText text: &quot;&lt;b&gt;Hello&lt;/b&gt;&lt;i&gt;World!&lt;/i&gt;&quot; font.pixelSize: 22 font.italic: true color: &quot;steelblue&quot; &#125;&#125; 2. GroupBox&emsp;&emsp;GroupBox对应着Qt中的QGroupBox，用来组织一组相关的控件，GroupBox通常有一个标题，同时还可以有一个边框将整个控件围绕起来。使用时，GroupBox可以根据自己的大小设置自己的尺寸，但如果需要定位GroupBox内的子控件，必须显式指定GroupBox的宽度和高度。 &emsp;&emsp;GroupBox可以设置为可被选中的，此时，GroupBox左上角会显示一个复选框，只有当用户选中GroupBox时，其子控件才可用。 12345678910111213141516import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; width: 300; height: 200 GroupBox &#123; title: qsTr(&quot;Group 2&quot;); checkable: true x: 10; y: 10; width: 200; height: 100 Column &#123; spacing: 2 CheckBox &#123; text: qsTr(&quot;Update system&quot;) &#125; CheckBox &#123; text: qsTr(&quot;Update system&quot;) &#125; CheckBox &#123; text: qsTr(&quot;Update documentation&quot;) &#125; &#125; &#125;&#125; 3. BusyIndicator&emsp;&emsp;BusyIndicator是从移动平台借鉴来的一个控件，类似于忙碌的鼠标样式，用于在内容正在加载或UI阻塞的时候显示，提示用户正在运行，而在所等待的资源可用时，BusyIndicator应该停止。 12345678910111213import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; BusyIndicator &#123; id: busyIndicator; running: true &#125; MouseArea &#123; anchors.fill: parent onClicked: busyIndicator.running = false // busyIndicator为true时，显示，为false时，消失 &#125;&#125; 4. ProgressBar12345678910111213import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; ProgressBar &#123; id: progressBar minimumValue: 0; maximumValue: 100 &#125; Timer &#123; interval: 100; running: true; repeat: true onTriggered: progressBar.value++ &#125;&#125; 导航类视图&emsp;&emsp;ScrollView对应着Qt中的QScrollView，即带有滚动条的视图，ScrollView中只能包含一个组件，这个控件会隐式的充满整个视图。12345678910import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; width: 200; height: 200 ScrollView &#123; anchors.fill: parent Image &#123; source: &quot;screen.png&quot; &#125; &#125;&#125; 2. SplitView&emsp;&emsp;SplitView对应着Qt中的QSplitter，可以将多个组件水平或垂直排列起来，相邻组件由可被拖动的分隔块分隔。SplitView通常要与布局管理器结合使用。 12345678910111213141516171819202122import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Layouts 2.1ApplicationWindow &#123; width: 400; height: 200 SplitView &#123; anchors.fill: parent oritentation: Qt.Horizontal Rectangle &#123; width: 200; color: &quot;gray&quot; Layout.maximumWidth: 300 &#125; Rectangle &#123; id: centerItem; color: &quot;darkgray&quot; Layout.minimumWidth: 50 Layout.fillWidth: true &#125; Rectangle &#123; width: 200; color: &quot;gray&quot; &#125; &#125;&#125; 3. StackView&emsp;&emsp;StackView对应着C++中设置了QStackedLayout的QWidget。这是一种基于栈的导航模型，可以将一系列相关联的视图页面添加到这个栈中。这个“栈”遵循“先进后出”的操作方式：视图被压入栈中，只有最上面的才会被显示，当点击“后退”按钮时，顶层的视图会被弹出。 &emsp;&emsp;StackView提供了一系列用于实现导航的函数，比如push,pop和clear等。供StackView显示的第一个视图会被赋值给initialItem属性，被压入栈中的视图会获得3个Stack附加属性： Stack.index: 保存该视图在StackView的索引 Stack.view: 保存该视图所在的StackView对象 Stack.status: 保存该视图的状态，这个状态有下面几个有效值: Stack.Inactive: 该视图不可见 Stack.Activating：该视图正在变为可见状态 Stack.Active: 该视图可见，即处于栈顶 Stack.Deactivating: 该视图正在变为不可见状态 1. 基本操作&emsp;&emsp;StackView最常用的3个操作是push,pop和replace。压入操作相当于将导航前进一步，弹出操作相当于将导航后退一步，替换操作相当于更换当前视图。在界面进行切换时，StackView会添加过渡动画，但如果栈本来就是空的，那么第一次压入操作不会有动画出现。另外，如果一个栈只有一个或没有视图，弹出操作也不会起作用，这意味着弹出操作不会将栈清空，如果需要将栈彻底清空，需要使用专门的清空操作(clear)。 &emsp;&emsp;有时候，程序需要后退多步，例如退回主界面等。这种情况下，可以给弹出操作一个参数，这种操作成为“展开”，相当于将该元素上面的视图全部弹出。如果找不到指定视图，则会弹出除最下层的视图以外的全部上层视图，直接显示最底层视图也可以使用pop(null)来实现。 下面，我们通过一个例子，来理解StackView的基本操作： 假设StackView现在已有三个视图，栈中内容为[A,B,C]，现对其做如下操作: push(D)=&gt;[A,B,C,D]，压入的过渡动画出现在C,D之间 pop()=&gt;[A,B]，弹出的过渡动画出现在C，B之间 push(D, replace)=&gt;[A,B,D]，替换的过渡动画出现在C,D之间 pop(A)=&gt;[A]，弹出的过渡动画出现在C，A之间 &emsp;&emsp;除了针对单个视图进行的操作，StackView还支持对视图数组进行压入，弹出等操作，这种操作被称为”深链接”。压入一个视图数组，会将数组中所有视图压入栈中，但是，过渡动画只会出现在栈顶视图与最后一个视图之间。 &emsp;&emsp;依然是上面的例子，假设StackView已有3个视图，栈中的内容是[A,B,C]，我们现在对其进行”深链接”操作: push([D,E,F])=&gt;[A,B,C,D,E,F]，压入的过渡动画将出现在C，F之间 push([D,E,F], replace)=&gt;[A,B,D,E,F]，替换的过渡动画将出现在C,F之间 clear();push([D,E,F])=&gt;没有过渡动画，这个操作实质上相当于替换整个栈的内容 12345678910111213141516171819202122232425262728293031import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; width: 800; height: 600 MouseArea &#123; // 动态增加StackView的视图 anchors.fill: parent acceptedButtons: Qt.LeftButton | Qt.RightButton | Qt.MiddleButton onClicked: &#123; if(mouse.button == Qt.LeftButton) stackView.push([blueView, greenView, yellowView]); else if(mouse.button == Qt.RightButton) stackView.pop(); else stackView.push(&#123;item: orangeView, replace: true&#125;); &#125; &#125; Rectangle &#123; id: blueView; color: &quot;blue&quot; &#125; Rectangle &#123; id: greenView; color: &quot;green&quot; &#125; Rectangle &#123; id: yellowView; color: &quot;yellow&quot; &#125; Rectangle &#123; id: orangeView; color: &quot;orange&quot; &#125; StackView &#123; id: StackView; anchors.fill: parent // initialItem表示在窗口显示时就加载的最初控件 initialItem: Item &#123; id: redView Rectangle &#123; anchors.fill: parent; color:&quot;red&quot; &#125; &#125; &#125;&#125; &emsp;&emsp;如果要压入多个视图，最好使用数组，而不是一个一个压入，因为QtQuick对数组压入做了优化，即实质上只压入要显示的那张视图，数组内其余视图只有在需要显示的时候才会被载入。 &emsp;&emsp;上述代码中stackView.push(blueView)其实是stackView.push({item: blueView})的简写，push的完整参数应是:123456push(&#123;item: , properties: , immediate: , replace: , destroyOnPop: &#125;)// item: 必填属性，即被压入的视图// properties: 一个属性列表，这些属性会在加载或显示时赋值给被压入视图// immediate: 当该属性设为true时，可以跳过过渡动画，如果压入一个视图数组，只需要设置数组中第一个元素的属性即可// replace: 当该属性设为true时，会使用设置了该属性的视图替换栈顶视图。如果压入一个视图数组，可以将其设置为数组的第一个视图，那么，栈中原有的与数组视图个数相同的整个视图都会被替换// destroyOnPop: 当该属性设为true时，StackView会在弹出后销毁被弹出的视图 2. 生命周期&emsp;&emsp;当视图处于活动状态时，意味着这个视图正在屏幕显示，也就是所谓的”当前视图”，当视图没有在屏幕显示时，即便这个视图处于栈顶，也处于非活动状态。活动状态与非活动状态之间可以进行多次转换。 &emsp;&emsp;可以使用附加属性Stack.status追踪视图的生命周期，status属性在前面已经介绍过了。 &emsp;&emsp;结合Component.onComplete和Component.onDestruction两个信号，可以使用以下信号监控视图的生命周期。 视图被创建: Component.onComplete() 转换为活动状态: Stack.onStatusChanged(此时Stack.status为Stack.Activating) 转换为活动状态: Stack.onStatusChanged(Stack.status为Stack.Stack.Active) 转换为非活动状态: Stack.onStatusChanged(Stack.status为Stack.Inactive) 视图被销毁: Component.onDestruction() 3. 查找视图&emsp;&emsp;视图的查找操作通过StackView的find()函数来实现，这个函数接受一个回调函数作为参数，这个回调函数会依照栈中视图从上向下的顺序针对每一个遍历到的视图调用。如果回调函数返回true，说明找到了视图，find()会返回这个函数，如果始终没有找到视图，find()将返回null。123stackView.pop(stackView.find(function(item) &#123; return item.name == &quot;order_id&quot;;&#125;)); &emsp;&emsp;也可以使用get(index)函数获取特定索引的视图，这个函数适用于具有前后关系的视图，比如要找到特定视图view前面的一张视图，1previousItem = stackView.get(view.Stack.index - 1) 4. TabView&emsp;&emsp;TabView对应着Qt中的QTabWidget，用于显示带有标签页的控件。&emsp;&emsp;TabView的count属性返回该视图中共有几个标签页;currentIndex属性返回当前显示的标签页的索引;tabPosition属性设置标签栏的显示位置，可选值有Qt.TopEdge(默认值)和Qt.BottomEdge;如果暂时不想显示标签栏，可以设置tabsVisible属性;如果不想显示边框，可以设置frameVisible属性。&emsp;&emsp;TabView还提供了用于维护标签页的几个函数，比如addTab()，insertTab()，moveTab()和removeTab()等。 &emsp;&emsp;TabView需要添加Tab控件作为子视图，Tab控件继承自Loader，可以动态加载其他QML文档。 12345678910111213import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.2ApplicationWindow &#123; width: 300; height: 200 TabView &#123; anchors.fill: parent Tab &#123; title: &quot;Home&quot; &#125; Tab &#123; title: &quot;Edit&quot;&#125; Tab &#123; title: &quot;View&quot;&#125; Tab &#123; title: &quot;Help&quot;&#125; &#125;&#125; 5. TableView&emsp;&emsp;TableView对应着QTableView，但增加了滚动条，选择可改变大小的列头。TableView使用数据模型为表格模型为表格的每一行提供数据。1234567891011121314151617import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Window 2.1ApplicationWindow &#123; width: 600; height: 200 ListModel &#123; id: libraryModel ListElement &#123; title: &quot;A Masterpiece&quot;; author: &quot;Gabriel&quot; &#125; ListElement &#123; title: &quot;Brilliance&quot;; author: &quot;Jens&quot; &#125; ListElement &#123; title: &quot;Outstanding&quot;; author: &quot;Frederik&quot; &#125; &#125; TableView &#123; anchors.fill: parent; model: libraryModel TableViewColumn &#123; role: &quot;title&quot;; title: &quot;Title&quot;; width: 100 &#125; TableViewColumn &#123; role: &quot;author&quot;; title: &quot;Author&quot;; width: 200 &#125; &#125;&#125; &emsp;&emsp;在TableView中需要使用TableViewColumn来指定模型中的字段，每一个TableViewColumn对应一个字段。其中，需要指定role即模型中字段名称，title是要显示的每一列的列头。&emsp;&emsp;TableViewColumn类型中还包含了visible，width，resizable，movable，delegate等属性，其中delegate属性可以给特定的列使用委托来指定显示方式，在委托中可以访问特定的属性。 TableViewColumn的delegate中可以访问的属性: &emsp;&emsp;TableView可以通过itemDelegate属性，使用委托来绘制指定单元格，它与TableViewColumn的delegate效果相同，还可以通过rowDelegate和headerDelegate来委托绘制行或列头。&emsp;&emsp;TableView类型还提供了一些常用的函数，比如addColumn()，getColumn()，insertColumn()，removeColumn()和rowAt(x,y)等进行相关操作。 123456789101112131415TableView &#123; anchors.fill: parent; model: libraryModel TableViewColumn &#123; role: &quot;title&quot;; title: &quot;Title&quot;; width: 100 &#125; TableViewColumn &#123; role: &quot;author&quot;; title: &quot;Author&quot;; width: 200 &#125; itemDelegate &#123; Text &#123; anchors.horizontalCenter: parent.horizontalCenter color: styleData.selected ? &quot;red&quot; : &quot;blue&quot; font.pointSize: 10 text: styleData.row == 2 ? &quot;myrow&quot; : styleData.value &#125; &#125; // 当TableView中的行被点击后，会发射clicked信号 onClicked: console.debug(row)&#125; 标准对话框&emsp;&emsp;一个完整的应用程序通常需要使用对话框来完成一些交互，有些对话框提供一些通用功能，比如选择文件，选择颜色等。由于这部分对话框对于每个程序都是一样的，QML提供了一系列预定义的对话框，被称为标准对话框。 &emsp;&emsp;Dialogs模块中提供了4种标准对话框:ColorDialog，FileDialog，FontDialog和MessageDialog。 ColorDialog&emsp;&emsp;ColorDialog对应C++中的QColorDialog，用于进行颜色选择的对话框。初始状态下，该对话框是不可见的，需要先对属性进行设置，然后将其visible属性设置为true，或者调用open()显示。 1234567891011121314151617import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Dialogs 1.1ApplicationWindow &#123; id: window; width: 300; height: 300 Button &#123; width: 100; height: 50; text: &quot;Color Dialog&quot; anchors.centerIn: parent onClicked: colorDialog.open() &#125; ColorDialog &#123; id: colorDialog title: &quot;Please choose a color&quot; onAccepted: &#123; window.color = color &#125; onRejected: &#123; console.log(&quot;Canceled&quot;) &#125; &#125;&#125; FileDialog&emsp;&emsp;FileDialog对应着C++中的QFileDialog，用于显示选择文件的对话框，同ColorDialog，初始状态下，FileDialog也是不可见的。 &emsp;&emsp;选择的文件或文件列表(选择了多个文件)的路径可以通过fileUrl和fileUrls来获取，如果要选择多个文件，需要设置selectMultiple属性为true。如果要选择的是目录而不是文件，可以设置selectFolder为true，然后通过folder属性来获取选中的目录路径。如果在调用open()之前设置了folder属性，那么会打开指定的目录。还可以使用nameFilter来设置文件名过滤器，过滤器中可以使用？和*通配符，每个字符串之间使用空格隔开。 12345678910111213141516171819import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Dialogs 1.1ApplicationWindow &#123; id: window; width: 300; height: 300 Button &#123; width: 100; height: 50; text: &quot;file dialog&quot; anchors.centerIn: parent onClicked: fileDialog.open() &#125; fileDialog &#123; id: fileDialog title: &quot;Please choose a file&quot; nameFilter: [ &quot;image file(*.jpg *.png)&quot;, &quot;All files(*)&quot; ] folder: &quot;..&quot; onAccepted: &#123; window.title = fileDialog.fileUrl &#125; onRejected: &#123; console.log(&quot;Cancel&quot;) &#125; &#125;&#125; FontDialog&emsp;&emsp;FontDialog对应着C++中的QFontDialog，用于进行字体选择的对话框。FontDialog类型中可以在使用open()以前使用font属性来设置初始的字体，当关闭对话框后，可以使用font来获取选中的字体内容。 123456789101112131415161718import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Dialogs 1.1ApplicationWindow &#123; id: window; width: 300; height: 300 Button &#123; width: 100; height: 50; text: &quot;Font Dialog&quot; anchors.centerIn: parent onClicked: fontDialog.open() &#125; FontDialog &#123; id: fontDialog title: &quot;Please choose a font&quot; font: Qt.font(&#123; family: &quot;Arial&quot;, pointSize: 24; weight: Font.Normal &#125;) onAccepted: &#123; console.log(&quot;you choose&quot; + fontDialog.font) &#125; onRejected: &#123; console.log(&quot;Canceled&quot;) &#125; &#125;&#125; MessageDialog&emsp;&emsp;MessageDialog对应着C++中的QMessageBox，用于显示一些提示信息的标准对话框，比如警告，错误等。需要一个个设置MessageDialog的各个属性，以便达到需要的效果。 &emsp;&emsp;使用text属性可以设置主要显示的内容,使用detailedtext属性可以设置要显示的详细信息。 &emsp;&emsp;icon属性用来设置对话框的图标,一共有5种: Standardicon. nicon(没 有图标) Standardicon. Question(问题)、 Standardicon. Information(信息)、 Standardi con. Warning(警告) Standardicon. Critical(错误)。 &emsp;&emsp;使用standardbuttons属性可以设置对话框中的按钮。每一个按钮都包含一个ButtonRole,用来决定按钮被按下时发射的信号类型。例如Ok按钮对应的是AcceptRole,那么Ok按钮按下时就应该在onAccepted()信号处理器中进行相应操作;而Help按钮对应的是HelpRole,那么其对应的就是help()信号处理器。 MessageDialog中的标准按钮类型： 12345678910111213141516171819202122import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Dialogs 1.1Applicationwindow &#123; id: window; width: 300; height: 300 Button &#123; width: 100; height: 50; text: &quot;Message Dialog&quot; anchors.centerIn: parent onClicked: messageDialog.open() &#125; MessageDialog &#123; id: messageDialog title: &quot;May I have your attention please&quot; text: &quot;it&apos;s so cool that you are using Qt Quick.&quot; detailedText: &quot;this is the detailed text&quot; icon: StandardIcon.Question standardButtons: StandardButton.Yes | StandardButton.Help | Standardbutton.Open onYes: &#123; console. log(&quot;yes&quot;) &#125; onhelp: &#123; console.log(&quot;help&quot;) &#125; onAccepted: &#123; console.log(&quot;open.&quot;) &#125;&#125; 定义控件样式&emsp;&emsp;QtQuick模块提供的控件样式都是最基本的样式，在QtQuick Controls模块中，每一个控件都包含了一个style属性，需要指定对应的样式类型，样式类型就是在该控件类型名称的后面加上Style。例如，Button对应的就是ButtonStyle。在样式类型中包含了特定的属性和简单的委托来修改一个控件的外观和行为。 12345678910111213141516171819202122232425262728import QtQuick 2.2import QtQuick.Controls 1.2import QtQuick.Controls.Styles 1.2Application &#123; Button &#123; style: ButtonStyle &#123; label: Text &#123; text: &quot;A button&quot;; font.pointSize: 12 color: control.pressed ? &quot;blue&quot; : &quot;green&quot; &#125; background： Rectangle &#123; implicitWidth： 100; implicitHeight： 25 border.width： 100; control.activeFocus ? 2 ： 1 border.color： &quot;#888&quot;; radius： 4 gradient： Gradient &#123; GradientStop &#123; position： 0 color: control.pressed ? &quot;#ccc&quot; : &quot;#eee&quot; &#125; GradientStop &#123; position: 1 color: control.pressed ? &quot;#aaa&quot; : &quot;#ccc&quot; &#125; &#125; &#125; &#125; &#125;&#125; &emsp;&emsp;与ButtonStyle类似，其他控件对应的样式类型也可以通过委托组件的方式来定义控件的相关部分。]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Perl子程序(函数)]]></title>
    <url>%2F2018%2F10%2F26%2FPerl%20_process%2F</url>
    <content type="text"><![CDATA[Usage 1234# 子程序定义:sub subroutine &#123; &lt; statements &gt;&#125; 基本示例 1234567#!/usr/bin/perlsub Hello &#123; print "Hello, World!\n";&#125;Hello(); 向子程序传参 1234567891011121314sub Average &#123; $n = scalar(@_); # 子程序中的@_表示传入此子程序的参数数组(可以改变),_是数组名 $sum = 0; foreach $item (@_) &#123; # item(arr)取出数组中每项元素的值 $sum += $item; &#125; $average = $sum / $n; print '传入的参数: ', '@_\n'; print '第一个参数值为: $_[0]\n'; # _指向数组中的第一个元素,故$_表示参数数组中的第一个元素 print '传入参数的平均值: $average \ n';&#125; 向子程序传递列表 12345678sub printList &#123; my @list = @_; print "列表为: @list\n";&#125;@a = 10;@b = (1, 2, 3, 4);printList($a, @b); # 列表为: 10 1 2 3 4 向子程序传递哈希 123456789101112sub printHash &#123;# my定义函数内局部变量,若不加my类型修饰,则表示声明全局变量 my (%hash) = @_; foreach my $key ( keys %hash ) &#123; my $value = $hash&#123;$key&#125;; print "$key: $value\n"; &#125;&#125;%hash = ('name' =&gt; 'youj', 'age' =&gt; 3)printHash(%hash); 子程序返回值 12345678910sub add_a_b &#123; $_[0] + $_[1]; # 若没有return语句,则子程序最后语句即为返回值。&#125;sub add_a_b &#123; return $_[0] + $_[1];&#125;print add_a_b(1, 2) # 3 子程序的私有(局部)变量 12345678910# 用my定义函数私有变量$string = "Hello, World!";sub printHello &#123; my $string = "Hello"; print "函数内字符串: $string\n"&#125;printHello();print "函数外字符串: $string\n" 123# 以上代码输出:函数内字符串: Hello函数外字符串: Hello World 变量的临时赋值 1234567891011121314151617181920$string = "Hello World!";sub printsome &#123;# 使用local可对全局变量$string赋临时值,这个临时值的生效范围在本函数,及本函数所调用的函数 local $string = "Hello" printMe(); print "printsome 函数内字符串值: $string\n";&#125;sub printMe &#123; print "printMe 函数内字符串值: $string\n";&#125;sub printHello &#123; print "printHello 函数内字符串值: $string\n";&#125;printsome();printHello();print "函数外部字符串值: $string\n"; 12345# 以上代码输出:printMe 函数内字符串值: Helloprintsome 函数内字符串值: HelloprintHello 函数内字符串值: Hello, World!函数外部字符串值: Hello, World! 静态变量 1234567891011121314# static是词法变量,只在定义该变量的词法作用域中有效:use feature 'state';sub printCount &#123;# 静态变量可以看作是函数体内的全局变量,不因函数内存回收而销毁 state $count = 0; # 初始化变量 print "counter 值为: $count\n"; $count++;&#125;for (1..5) &#123; printCount();&#125; 123456# 上述代码输出:counter值为: 0counter值为: 1counter值为: 2counter值为: 3counter值为: 4 子程序定义上下文 子程序在调用过程中,会根据上下文来返回不同类型的值123456789# 标量上下文my $dateStr = localtime(time);print $dateStr;print "\n";# 列表上下文($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);printf("%d-%d-%d %d:%d:%d", $year+1990, $mon+1, $mday, $hour, $min, $sec);print "\n"; 123# 以上代码输出:Sun Jun 12 15:58:09 20162016-6-12 15:58:9 Download Now]]></content>
      <categories>
        <category>perl</category>
      </categories>
      <tags>
        <tag>perl</tag>
        <tag>函数</tag>
      </tags>
  </entry>
</search>
